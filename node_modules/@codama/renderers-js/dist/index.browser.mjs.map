{"version":3,"sources":["../src/utils/importMap.ts","../src/utils/nameTransformers.ts","../src/utils/fragment.ts","../src/utils/typeManifest.ts","../src/utils/async.ts","../src/utils/codecs.ts","../src/utils/customData.ts","../src/utils/formatCode.ts","../src/utils/linkOverrides.ts","../src/utils/packageJson.ts","../src/fragments/accountFetchHelpers.ts","../src/fragments/accountPdaHelpers.ts","../src/fragments/accountSizeHelpers.ts","../src/fragments/type.ts","../src/fragments/typeDecoder.ts","../src/fragments/typeEncoder.ts","../src/fragments/typeCodec.ts","../src/fragments/typeWithCodec.ts","../src/fragments/accountType.ts","../src/fragments/discriminatorConstants.ts","../src/fragments/accountPage.ts","../src/fragments/discriminatorCondition.ts","../src/fragments/errorPage.ts","../src/fragments/indexPage.ts","../src/fragments/instructionAccountMeta.ts","../src/fragments/instructionAccountTypeParam.ts","../src/fragments/instructionByteDelta.ts","../src/fragments/instructionData.ts","../src/fragments/instructionExtraArgs.ts","../src/fragments/instructionInputDefault.ts","../src/fragments/instructionInputResolved.ts","../src/fragments/instructionInputType.ts","../src/fragments/instructionRemainingAccounts.ts","../src/fragments/instructionFunction.ts","../src/fragments/instructionParseFunction.ts","../src/fragments/instructionType.ts","../src/fragments/instructionPage.ts","../src/fragments/pdaFunction.ts","../src/fragments/pdaPage.ts","../src/fragments/programAccounts.ts","../src/fragments/programConstant.ts","../src/fragments/programInstructions.ts","../src/fragments/programPage.ts","../src/fragments/rootIndexPage.ts","../src/fragments/sharedPage.ts","../src/fragments/typeDiscriminatedUnionHelpers.ts","../src/fragments/typePage.ts","../src/visitors/getTypeManifestVisitor.ts","../src/visitors/getRenderMapVisitor.ts","../src/visitors/renderVisitor.ts"],"names":["fragment","camelCase","isNode","joinPath","missingDependencies","CodamaError","ltVersion","typeManifest","getLastNodeFromPath","pipe","isDataEnum","isNodeFilter","visit","resolveNestedTypeNode","pascalCase","findProgramNodeFromPath","mapFragmentContent","structTypeNodeFromInstructionArgumentNodes","pdaSeeds","valueManifest","programAddress","getAccountTypeFragment","getRemainingAccountsFragment","getArgumentValueNodeFragment","getResolverValueNodeFragment","assertIsNode","getAllInstructionArguments","getTypeFragment","getInstructionTypeFragment","definedTypeNode","logWarn","getFunctionFragment","encoder","variantName","setFragmentContent","LinkableDictionary","NodeStack","staticVisitor","extendVisitor","getAllInstructionsWithSubs","recordNodeStackVisitor"],"mappings":"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","file":"index.browser.mjs","sourcesContent":["const DEFAULT_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/kit',\n    solanaAddresses: '@solana/kit',\n    solanaCodecsCore: '@solana/kit',\n    solanaCodecsDataStructures: '@solana/kit',\n    solanaCodecsNumbers: '@solana/kit',\n    solanaCodecsStrings: '@solana/kit',\n    solanaErrors: '@solana/kit',\n    solanaInstructions: '@solana/kit',\n    solanaOptions: '@solana/kit',\n    solanaPrograms: '@solana/kit',\n    solanaRpcTypes: '@solana/kit',\n    solanaSigners: '@solana/kit',\n};\n\nconst DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/accounts',\n    solanaAddresses: '@solana/addresses',\n    solanaCodecsCore: '@solana/codecs',\n    solanaCodecsDataStructures: '@solana/codecs',\n    solanaCodecsNumbers: '@solana/codecs',\n    solanaCodecsStrings: '@solana/codecs',\n    solanaErrors: '@solana/errors',\n    solanaInstructions: '@solana/instructions',\n    solanaOptions: '@solana/codecs',\n    solanaPrograms: '@solana/programs',\n    solanaRpcTypes: '@solana/rpc-types',\n    solanaSigners: '@solana/signers',\n};\n\nconst DEFAULT_INTERNAL_MODULE_MAP: Record<string, string> = {\n    errors: '../errors',\n    generated: '..',\n    generatedAccounts: '../accounts',\n    generatedErrors: '../errors',\n    generatedInstructions: '../instructions',\n    generatedPdas: '../pdas',\n    generatedPrograms: '../programs',\n    generatedTypes: '../types',\n    hooked: '../../hooked',\n    shared: '../shared',\n    types: '../types',\n};\n\ntype ImportInput = string;\ntype Module = string;\ntype UsedIdentifier = string;\ntype ImportInfo = Readonly<{\n    importedIdentifier: string;\n    isType: boolean;\n    usedIdentifier: UsedIdentifier;\n}>;\n\nexport type ImportMap = ReadonlyMap<Module, ReadonlyMap<UsedIdentifier, ImportInfo>>;\n\nexport function createImportMap(): ImportMap {\n    return Object.freeze(new Map());\n}\n\nexport function parseImportInput(input: ImportInput): ImportInfo {\n    const matches = input.match(/^(type )?([^ ]+)(?: as (.+))?$/);\n    if (!matches) return Object.freeze({ importedIdentifier: input, isType: false, usedIdentifier: input });\n\n    const [_, isType, name, alias] = matches;\n    return Object.freeze({\n        importedIdentifier: name,\n        isType: !!isType,\n        usedIdentifier: alias ?? name,\n    });\n}\n\nexport function addToImportMap(importMap: ImportMap, module: Module, imports: ImportInput[]): ImportMap {\n    const parsedImports = imports.map(parseImportInput).map(i => [i.usedIdentifier, i] as const);\n    return mergeImportMaps([importMap, new Map([[module, new Map(parsedImports)]])]);\n}\n\nexport function removeFromImportMap(\n    importMap: ImportMap,\n    module: Module,\n    usedIdentifiers: UsedIdentifier[],\n): ImportMap {\n    const newMap = new Map(importMap);\n    const newModuleMap = new Map(newMap.get(module));\n    usedIdentifiers.forEach(usedIdentifier => {\n        newModuleMap.delete(usedIdentifier);\n    });\n    if (newModuleMap.size === 0) {\n        newMap.delete(module);\n    } else {\n        newMap.set(module, newModuleMap);\n    }\n    return Object.freeze(newMap);\n}\n\nexport function mergeImportMaps(importMaps: ImportMap[]): ImportMap {\n    if (importMaps.length === 0) return createImportMap();\n    if (importMaps.length === 1) return importMaps[0];\n    const mergedMap = new Map(importMaps[0]);\n    for (const map of importMaps.slice(1)) {\n        for (const [module, imports] of map) {\n            const mergedModuleMap = (mergedMap.get(module) ?? new Map()) as Map<UsedIdentifier, ImportInfo>;\n            for (const [usedIdentifier, importInfo] of imports) {\n                const existingImportInfo = mergedModuleMap.get(usedIdentifier);\n                // If two identical imports exist such that\n                // one is a type import and the other is not,\n                // then we must only keep the non-type import.\n                const shouldOverwriteTypeOnly =\n                    existingImportInfo &&\n                    existingImportInfo.importedIdentifier === importInfo.importedIdentifier &&\n                    existingImportInfo.isType &&\n                    !importInfo.isType;\n                if (!existingImportInfo || shouldOverwriteTypeOnly) {\n                    mergedModuleMap.set(usedIdentifier, importInfo);\n                }\n            }\n            mergedMap.set(module, mergedModuleMap);\n        }\n    }\n    return Object.freeze(mergedMap);\n}\n\nexport function importMapToString(\n    importMap: ImportMap,\n    dependencyMap: Record<string, string> = {},\n    useGranularImports = false,\n): string {\n    const resolvedMap = resolveImportMapModules(importMap, dependencyMap, useGranularImports);\n\n    return [...resolvedMap.entries()]\n        .sort(([a], [b]) => {\n            const relative = Number(a.startsWith('.')) - Number(b.startsWith('.'));\n            // Relative imports go last.\n            if (relative !== 0) return relative;\n            // Otherwise, sort alphabetically.\n            return a.localeCompare(b);\n        })\n        .map(([module, imports]) => {\n            const innerImports = [...imports.values()]\n                .map(importInfoToString)\n                .sort((a, b) => a.localeCompare(b))\n                .join(', ');\n            return `import { ${innerImports} } from '${module}';`;\n        })\n        .join('\\n');\n}\n\nexport function getExternalDependencies(\n    importMap: ImportMap,\n    dependencyMap: Record<string, string>,\n    useGranularImports: boolean,\n): Set<string> {\n    const resolvedImports = resolveImportMapModules(importMap, dependencyMap, useGranularImports);\n    return new Set([...resolvedImports.keys()].filter(module => !module.startsWith('.')));\n}\n\nfunction resolveImportMapModules(\n    importMap: ImportMap,\n    dependencyMap: Record<string, string>,\n    useGranularImports: boolean,\n): ImportMap {\n    const dependencyMapWithDefaults = {\n        ...(useGranularImports ? DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP : DEFAULT_EXTERNAL_MODULE_MAP),\n        ...DEFAULT_INTERNAL_MODULE_MAP,\n        ...dependencyMap,\n    };\n\n    return mergeImportMaps(\n        [...importMap.entries()].map(([module, imports]) => {\n            const resolvedModule = dependencyMapWithDefaults[module] ?? module;\n            return new Map([[resolvedModule, imports]]);\n        }),\n    );\n}\n\nfunction importInfoToString({ importedIdentifier, isType, usedIdentifier }: ImportInfo): string {\n    const alias = importedIdentifier !== usedIdentifier ? ` as ${usedIdentifier}` : '';\n    return `${isType ? 'type ' : ''}${importedIdentifier}${alias}`;\n}\n","import { camelCase, capitalize, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\n\nexport type NameTransformerHelpers = {\n    camelCase: (name: string) => string;\n    capitalize: (name: string) => string;\n    kebabCase: (name: string) => string;\n    pascalCase: (name: string) => string;\n    snakeCase: (name: string) => string;\n    titleCase: (name: string) => string;\n};\n\nexport type NameTransformer = (name: string, helpers: NameTransformerHelpers) => string;\n\nexport type NameTransformerKey =\n    | 'accountDecodeFunction'\n    | 'accountFetchAllFunction'\n    | 'accountFetchAllMaybeFunction'\n    | 'accountFetchFromSeedsFunction'\n    | 'accountFetchFunction'\n    | 'accountFetchMaybeFromSeedsFunction'\n    | 'accountFetchMaybeFunction'\n    | 'accountGetSizeFunction'\n    | 'codecFunction'\n    | 'constant'\n    | 'constantFunction'\n    | 'dataArgsType'\n    | 'dataType'\n    | 'decoderFunction'\n    | 'discriminatedUnionDiscriminator'\n    | 'discriminatedUnionFunction'\n    | 'discriminatedUnionVariant'\n    | 'encoderFunction'\n    | 'enumVariant'\n    | 'instructionAsyncFunction'\n    | 'instructionAsyncInputType'\n    | 'instructionDataType'\n    | 'instructionExtraType'\n    | 'instructionParsedType'\n    | 'instructionParseFunction'\n    | 'instructionSyncFunction'\n    | 'instructionSyncInputType'\n    | 'instructionType'\n    | 'isDiscriminatedUnionFunction'\n    | 'pdaFindFunction'\n    | 'pdaSeedsType'\n    | 'programAccountsEnum'\n    | 'programAccountsEnumVariant'\n    | 'programAccountsIdentifierFunction'\n    | 'programAddressConstant'\n    | 'programErrorConstant'\n    | 'programErrorConstantPrefix'\n    | 'programErrorMessagesMap'\n    | 'programErrorUnion'\n    | 'programGetErrorMessageFunction'\n    | 'programInstructionsEnum'\n    | 'programInstructionsEnumVariant'\n    | 'programInstructionsIdentifierFunction'\n    | 'programInstructionsParsedUnionType'\n    | 'programIsErrorFunction'\n    | 'resolverFunction';\n\nexport type NameTransformers = Record<NameTransformerKey, NameTransformer>;\n\nexport type NameApi = Record<NameTransformerKey, (name: string) => string>;\n\nexport function getNameApi(transformers: NameTransformers): NameApi {\n    const helpers = {\n        camelCase,\n        capitalize,\n        kebabCase,\n        pascalCase,\n        snakeCase,\n        titleCase,\n    };\n    return Object.fromEntries(\n        Object.entries(transformers).map(([key, transformer]) => [key, (name: string) => transformer(name, helpers)]),\n    ) as NameApi;\n}\n\nexport const DEFAULT_NAME_TRANSFORMERS: NameTransformers = {\n    accountDecodeFunction: name => `decode${pascalCase(name)}`,\n    accountFetchAllFunction: name => `fetchAll${pascalCase(name)}`,\n    accountFetchAllMaybeFunction: name => `fetchAllMaybe${pascalCase(name)}`,\n    accountFetchFromSeedsFunction: name => `fetch${pascalCase(name)}FromSeeds`,\n    accountFetchFunction: name => `fetch${pascalCase(name)}`,\n    accountFetchMaybeFromSeedsFunction: name => `fetchMaybe${pascalCase(name)}FromSeeds`,\n    accountFetchMaybeFunction: name => `fetchMaybe${pascalCase(name)}`,\n    accountGetSizeFunction: name => `get${pascalCase(name)}Size`,\n    codecFunction: name => `get${pascalCase(name)}Codec`,\n    constant: name => snakeCase(name).toUpperCase(),\n    constantFunction: name => `get${pascalCase(name)}Bytes`,\n    dataArgsType: name => `${pascalCase(name)}Args`,\n    dataType: name => `${pascalCase(name)}`,\n    decoderFunction: name => `get${pascalCase(name)}Decoder`,\n    discriminatedUnionDiscriminator: () => '__kind',\n    discriminatedUnionFunction: name => `${camelCase(name)}`,\n    discriminatedUnionVariant: name => `${pascalCase(name)}`,\n    encoderFunction: name => `get${pascalCase(name)}Encoder`,\n    enumVariant: name => `${pascalCase(name)}`,\n    instructionAsyncFunction: name => `get${pascalCase(name)}InstructionAsync`,\n    instructionAsyncInputType: name => `${pascalCase(name)}AsyncInput`,\n    instructionDataType: name => `${pascalCase(name)}InstructionData`,\n    instructionExtraType: name => `${pascalCase(name)}InstructionExtra`,\n    instructionParseFunction: name => `parse${pascalCase(name)}Instruction`,\n    instructionParsedType: name => `Parsed${pascalCase(name)}Instruction`,\n    instructionSyncFunction: name => `get${pascalCase(name)}Instruction`,\n    instructionSyncInputType: name => `${pascalCase(name)}Input`,\n    instructionType: name => `${pascalCase(name)}Instruction`,\n    isDiscriminatedUnionFunction: name => `is${pascalCase(name)}`,\n    pdaFindFunction: name => `find${pascalCase(name)}Pda`,\n    pdaSeedsType: name => `${pascalCase(name)}Seeds`,\n    programAccountsEnum: name => `${pascalCase(name)}Account`,\n    programAccountsEnumVariant: name => `${pascalCase(name)}`,\n    programAccountsIdentifierFunction: name => `identify${pascalCase(name)}Account`,\n    programAddressConstant: name => `${snakeCase(name).toUpperCase()}_PROGRAM_ADDRESS`,\n    programErrorConstant: name => snakeCase(name).toUpperCase(),\n    programErrorConstantPrefix: name => `${snakeCase(name).toUpperCase()}_ERROR__`,\n    programErrorMessagesMap: name => `${camelCase(name)}ErrorMessages`,\n    programErrorUnion: name => `${pascalCase(name)}Error`,\n    programGetErrorMessageFunction: name => `get${pascalCase(name)}ErrorMessage`,\n    programInstructionsEnum: name => `${pascalCase(name)}Instruction`,\n    programInstructionsEnumVariant: name => `${pascalCase(name)}`,\n    programInstructionsIdentifierFunction: name => `identify${pascalCase(name)}Instruction`,\n    programInstructionsParsedUnionType: name => `Parsed${pascalCase(name)}Instruction`,\n    programIsErrorFunction: name => `is${pascalCase(name)}Error`,\n    resolverFunction: name => `${camelCase(name)}`,\n};\n","import { Docs } from '@codama/nodes';\nimport { BaseFragment, createFragmentTemplate } from '@codama/renderers-core';\n\nimport {\n    addToImportMap,\n    createImportMap,\n    ImportMap,\n    importMapToString,\n    mergeImportMaps,\n    parseImportInput,\n    removeFromImportMap,\n} from './importMap';\nimport { RenderScope } from './options';\n\nexport type FragmentFeature = 'instruction:resolverScopeVariable';\n\nexport type Fragment = BaseFragment &\n    Readonly<{\n        features: ReadonlySet<FragmentFeature>;\n        imports: ImportMap;\n    }>;\n\nfunction createFragment(content: string): Fragment {\n    return Object.freeze({ content, features: new Set<FragmentFeature>(), imports: createImportMap() });\n}\n\nfunction isFragment(value: unknown): value is Fragment {\n    return typeof value === 'object' && value !== null && 'content' in value;\n}\n\nexport function fragment(template: TemplateStringsArray, ...items: unknown[]): Fragment {\n    return createFragmentTemplate(template, items, isFragment, mergeFragments);\n}\n\nexport function mergeFragments(fragments: (Fragment | undefined)[], mergeContent: (contents: string[]) => string) {\n    const filteredFragments = fragments.filter((f): f is Fragment => f !== undefined);\n    return Object.freeze({\n        content: mergeContent(filteredFragments.map(fragment => fragment.content)),\n        features: new Set(filteredFragments.flatMap(f => [...f.features])),\n        imports: mergeImportMaps(filteredFragments.map(f => f.imports)),\n    });\n}\n\nexport function use(importInput: string, module: string): Fragment {\n    const importInfo = parseImportInput(importInput);\n    return addFragmentImports(createFragment(importInfo.usedIdentifier), module, [importInput]);\n}\n\nexport function mergeFragmentImports(fragment: Fragment, importMaps: ImportMap[]): Fragment {\n    return Object.freeze({ ...fragment, imports: mergeImportMaps([fragment.imports, ...importMaps]) });\n}\n\nexport function addFragmentImports(fragment: Fragment, module: string, importInputs: string[]): Fragment {\n    return Object.freeze({ ...fragment, imports: addToImportMap(fragment.imports, module, importInputs) });\n}\n\nexport function removeFragmentImports(fragment: Fragment, module: string, usedIdentifiers: string[]): Fragment {\n    return Object.freeze({ ...fragment, imports: removeFromImportMap(fragment.imports, module, usedIdentifiers) });\n}\n\nexport function addFragmentFeatures(fragment: Fragment, features: FragmentFeature[]): Fragment {\n    return Object.freeze({ ...fragment, features: new Set([...fragment.features, ...features]) });\n}\n\nexport function getExportAllFragment(module: string): Fragment {\n    return fragment`export * from '${module}';`;\n}\n\nexport function getDocblockFragment(lines: Docs, withLineJump = false): Fragment | undefined {\n    const lineJump = withLineJump ? '\\n' : '';\n    if (lines.length === 0) return;\n    if (lines.length === 1) return fragment`/** ${lines[0]} */${lineJump}`;\n    const prefixedLines = lines.map(line => (line ? ` * ${line}` : ' *'));\n    return fragment`/**\\n${prefixedLines.join('\\n')}\\n */${lineJump}`;\n}\n\nexport function getPageFragment(\n    page: Fragment,\n    scope: Pick<RenderScope, 'dependencyMap' | 'useGranularImports'>,\n): Fragment {\n    const header = getDocblockFragment([\n        'This code was AUTOGENERATED using the Codama library.',\n        'Please DO NOT EDIT THIS FILE, instead use visitors',\n        'to add features, then rerun Codama to update it.',\n        '',\n        '@see https://github.com/codama-idl/codama',\n    ]);\n    const imports =\n        page.imports.size === 0\n            ? undefined\n            : fragment`${importMapToString(page.imports, scope.dependencyMap, scope.useGranularImports)}`;\n    return mergeFragments([header, imports, page], cs => cs.join('\\n\\n'));\n}\n","import { Fragment, fragment, mergeFragments } from './fragment';\n\nexport type TypeManifest = Readonly<{\n    decoder: Fragment;\n    encoder: Fragment;\n    isEnum: boolean;\n    looseType: Fragment;\n    strictType: Fragment;\n    value: Fragment;\n}>;\n\nexport function typeManifest(input: Partial<TypeManifest> = {}): TypeManifest {\n    return Object.freeze({\n        decoder: fragment``,\n        encoder: fragment``,\n        isEnum: false,\n        looseType: fragment``,\n        strictType: fragment``,\n        value: fragment``,\n        ...input,\n    });\n}\n\nexport function mergeTypeManifests(\n    manifests: TypeManifest[],\n    options: {\n        mergeCodecs?: (renders: string[]) => string;\n        mergeTypes?: (renders: string[]) => string;\n        mergeValues?: (renders: string[]) => string;\n    } = {},\n): TypeManifest {\n    const { mergeTypes, mergeCodecs, mergeValues } = options;\n    const merge = (fragmentFn: (m: TypeManifest) => Fragment, mergeFn?: (r: string[]) => string) =>\n        mergeFn ? mergeFragments(manifests.map(fragmentFn), mergeFn) : fragment``;\n    return Object.freeze({\n        decoder: merge(m => m.decoder, mergeCodecs),\n        encoder: merge(m => m.encoder, mergeCodecs),\n        isEnum: false,\n        looseType: merge(m => m.looseType, mergeTypes),\n        strictType: merge(m => m.strictType, mergeTypes),\n        value: merge(m => m.value, mergeValues),\n    });\n}\n","import {\n    AccountValueNode,\n    accountValueNode,\n    ArgumentValueNode,\n    argumentValueNode,\n    CamelCaseString,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n} from '@codama/nodes';\nimport { deduplicateInstructionDependencies, ResolvedInstructionInput } from '@codama/visitors-core';\n\nexport function hasAsyncFunction(\n    instructionNode: InstructionNode,\n    resolvedInputs: ResolvedInstructionInput[],\n    asyncResolvers: string[],\n): boolean {\n    const hasByteDeltasAsync = (instructionNode.byteDeltas ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n    const hasRemainingAccountsAsync = (instructionNode.remainingAccounts ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n\n    return hasAsyncDefaultValues(resolvedInputs, asyncResolvers) || hasByteDeltasAsync || hasRemainingAccountsAsync;\n}\n\nexport function hasAsyncDefaultValues(resolvedInputs: ResolvedInstructionInput[], asyncResolvers: string[]): boolean {\n    return resolvedInputs.some(\n        input => !!input.defaultValue && isAsyncDefaultValue(input.defaultValue, asyncResolvers),\n    );\n}\n\nexport function isAsyncDefaultValue(defaultValue: InstructionInputValueNode, asyncResolvers: string[]): boolean {\n    switch (defaultValue.kind) {\n        case 'pdaValueNode':\n            return true;\n        case 'resolverValueNode':\n            return asyncResolvers.includes(defaultValue.name);\n        case 'conditionalValueNode':\n            return (\n                isAsyncDefaultValue(defaultValue.condition, asyncResolvers) ||\n                (defaultValue.ifFalse == null ? false : isAsyncDefaultValue(defaultValue.ifFalse, asyncResolvers)) ||\n                (defaultValue.ifTrue == null ? false : isAsyncDefaultValue(defaultValue.ifTrue, asyncResolvers))\n            );\n        default:\n            return false;\n    }\n}\n\nexport function getInstructionDependencies(\n    input: InstructionAccountNode | InstructionArgumentNode | InstructionNode,\n    asyncResolvers: string[],\n    useAsync: boolean,\n): (AccountValueNode | ArgumentValueNode)[] {\n    if (isNode(input, 'instructionNode')) {\n        return deduplicateInstructionDependencies([\n            ...input.accounts.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...input.arguments.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...(input.extraArguments ?? []).flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n        ]);\n    }\n\n    if (!input.defaultValue) return [];\n\n    const getNestedDependencies = (\n        defaultValue: InstructionInputValueNode | undefined,\n    ): (AccountValueNode | ArgumentValueNode)[] => {\n        if (!defaultValue) return [];\n        return getInstructionDependencies({ ...input, defaultValue }, asyncResolvers, useAsync);\n    };\n\n    if (isNode(input.defaultValue, ['accountValueNode', 'accountBumpValueNode'])) {\n        return [accountValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, ['argumentValueNode'])) {\n        return [argumentValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, 'pdaValueNode')) {\n        const dependencies = new Map<CamelCaseString, AccountValueNode | ArgumentValueNode>();\n        input.defaultValue.seeds.forEach(seed => {\n            if (isNode(seed.value, ['accountValueNode', 'argumentValueNode'])) {\n                dependencies.set(seed.value.name, { ...seed.value });\n            }\n        });\n        return [...dependencies.values()];\n    }\n\n    if (isNode(input.defaultValue, 'resolverValueNode')) {\n        const isSynchronousResolver = !asyncResolvers.includes(input.defaultValue.name);\n        if (useAsync || isSynchronousResolver) {\n            return input.defaultValue.dependsOn ?? [];\n        }\n    }\n\n    if (isNode(input.defaultValue, 'conditionalValueNode')) {\n        return deduplicateInstructionDependencies([\n            ...getNestedDependencies(input.defaultValue.condition),\n            ...getNestedDependencies(input.defaultValue.ifTrue),\n            ...getNestedDependencies(input.defaultValue.ifFalse),\n        ]);\n    }\n\n    return [];\n}\n","import { BytesValueNode } from '@codama/nodes';\nimport { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport function getBytesFromBytesValueNode(node: BytesValueNode): Uint8Array {\n    switch (node.encoding) {\n        case 'utf8':\n            return getUtf8Encoder().encode(node.data) as Uint8Array;\n        case 'base16':\n            return getBase16Encoder().encode(node.data) as Uint8Array;\n        case 'base58':\n            return getBase58Encoder().encode(node.data) as Uint8Array;\n        case 'base64':\n        default:\n            return getBase64Encoder().encode(node.data) as Uint8Array;\n    }\n}\n","import {\n    AccountNode,\n    camelCase,\n    CamelCaseString,\n    DefinedTypeLinkNode,\n    definedTypeLinkNode,\n    DefinedTypeNode,\n    definedTypeNode,\n    InstructionNode,\n    isNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\n\nexport type CustomDataOptions =\n    | string\n    | {\n          extract?: boolean;\n          extractAs?: string;\n          importAs?: string;\n          importFrom?: string;\n          name: string;\n      };\n\nexport type ParsedCustomDataOptions = Map<\n    CamelCaseString,\n    {\n        extract: boolean;\n        extractAs: CamelCaseString;\n        importAs: CamelCaseString;\n        importFrom: string;\n        linkNode: DefinedTypeLinkNode;\n    }\n>;\n\nexport const parseCustomDataOptions = (\n    customDataOptions: CustomDataOptions[],\n    defaultSuffix: string,\n): ParsedCustomDataOptions =>\n    new Map(\n        customDataOptions.map(o => {\n            const options = typeof o === 'string' ? { name: o } : o;\n            const importAs = camelCase(options.importAs ?? `${options.name}${defaultSuffix}`);\n            const importFrom = options.importFrom ?? 'hooked';\n            return [\n                camelCase(options.name),\n                {\n                    extract: options.extract ?? false,\n                    extractAs: options.extractAs ? camelCase(options.extractAs) : importAs,\n                    importAs,\n                    importFrom,\n                    linkNode: definedTypeLinkNode(importAs),\n                },\n            ];\n        }),\n    );\n\nexport const getDefinedTypeNodesToExtract = (\n    nodes: AccountNode[] | InstructionNode[],\n    parsedCustomDataOptions: ParsedCustomDataOptions,\n): DefinedTypeNode[] =>\n    nodes.flatMap(node => {\n        const options = parsedCustomDataOptions.get(node.name);\n        if (!options || !options.extract) return [];\n\n        if (isNode(node, 'accountNode')) {\n            return [definedTypeNode({ name: options.extractAs, type: { ...node.data } })];\n        }\n\n        return [\n            definedTypeNode({\n                name: options.extractAs,\n                type: structTypeNodeFromInstructionArgumentNodes(node.arguments),\n            }),\n        ];\n    });\n","import { joinPath, Path } from '@codama/renderers-core';\nimport { Plugin, resolveConfig } from 'prettier';\nimport * as babelPlugin from 'prettier/plugins/babel';\nimport * as estreePlugin from 'prettier/plugins/estree';\nimport * as typeScriptPlugin from 'prettier/plugins/typescript';\nimport { format } from 'prettier/standalone';\n\nimport { RenderOptions } from './options';\n\nexport type PrettierOptions = Parameters<typeof format>[1];\n\nconst DEFAULT_PRETTIER_OPTIONS: PrettierOptions = {\n    plugins: [estreePlugin as Plugin<unknown>, typeScriptPlugin, babelPlugin],\n};\n\nexport type CodeFormatter = (code: string, path: Path) => Promise<string>;\n\nexport async function getCodeFormatter(\n    options: Pick<RenderOptions, 'formatCode' | 'packageFolder' | 'prettierOptions'>,\n): Promise<CodeFormatter> {\n    const shouldFormatCode = options.formatCode ?? true;\n    if (!shouldFormatCode) return code => Promise.resolve(code);\n\n    const prettierOptions: PrettierOptions = {\n        ...DEFAULT_PRETTIER_OPTIONS,\n        ...(await resolvePrettierOptions(options.packageFolder)),\n        ...options.prettierOptions,\n    };\n\n    return (code, filepath) => format(code, { ...prettierOptions, filepath });\n}\n\nasync function resolvePrettierOptions(packageFolder: string | undefined): Promise<PrettierOptions | null> {\n    if (!__NODEJS__) {\n        // In a non-NodeJS environment, we cannot load config files.\n        return null;\n    }\n\n    if (!packageFolder) return null;\n\n    // Prettier expects a file path to resolve, not just its directory.\n    // Therefore we must append a filename (any will do) to ensure the\n    // provided directory is searched for config files.\n    const filePathToResolve = joinPath(packageFolder, 'package.json');\n    return await resolveConfig(filePathToResolve);\n}\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport {\n    AccountLinkNode,\n    DefinedTypeLinkNode,\n    InstructionLinkNode,\n    PdaLinkNode,\n    ProgramLinkNode,\n    ResolverValueNode,\n} from '@codama/nodes';\n\nimport { ParsedCustomDataOptions } from './customData';\n\nexport type LinkOverrides = {\n    accounts?: Record<string, string>;\n    definedTypes?: Record<string, string>;\n    instructions?: Record<string, string>;\n    pdas?: Record<string, string>;\n    programs?: Record<string, string>;\n    resolvers?: Record<string, string>;\n};\n\ntype OverridableNodes =\n    | AccountLinkNode\n    | DefinedTypeLinkNode\n    | InstructionLinkNode\n    | PdaLinkNode\n    | ProgramLinkNode\n    | ResolverValueNode;\n\nexport type GetImportFromFunction = (node: OverridableNodes, fallback?: string) => string;\n\nexport function getImportFromFactory(\n    overrides: LinkOverrides,\n    customAccountData: ParsedCustomDataOptions,\n    customInstructionData: ParsedCustomDataOptions,\n): GetImportFromFunction {\n    const customDataOverrides = Object.fromEntries(\n        [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [\n            importAs,\n            importFrom,\n        ]),\n    );\n    const linkOverrides = {\n        accounts: overrides.accounts ?? {},\n        definedTypes: { ...customDataOverrides, ...overrides.definedTypes },\n        instructions: overrides.instructions ?? {},\n        pdas: overrides.pdas ?? {},\n        programs: overrides.programs ?? {},\n        resolvers: overrides.resolvers ?? {},\n    };\n\n    return (node: OverridableNodes) => {\n        const kind = node.kind;\n        switch (kind) {\n            case 'accountLinkNode':\n                return linkOverrides.accounts[node.name] ?? 'generatedAccounts';\n            case 'definedTypeLinkNode':\n                return linkOverrides.definedTypes[node.name] ?? 'generatedTypes';\n            case 'instructionLinkNode':\n                return linkOverrides.instructions[node.name] ?? 'generatedInstructions';\n            case 'pdaLinkNode':\n                return linkOverrides.pdas[node.name] ?? 'generatedPdas';\n            case 'programLinkNode':\n                return linkOverrides.programs[node.name] ?? 'generatedPrograms';\n            case 'resolverValueNode':\n                return linkOverrides.resolvers[node.name] ?? 'hooked';\n            default:\n                throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n                    expectedKinds: [\n                        'AccountLinkNode',\n                        'DefinedTypeLinkNode',\n                        'InstructionLinkNode',\n                        'PdaLinkNode',\n                        'ProgramLinkNode',\n                        'resolverValueNode',\n                    ],\n                    kind: kind satisfies never,\n                    node,\n                });\n        }\n    };\n}\n","import { CODAMA_ERROR__RENDERERS__MISSING_DEPENDENCY_VERSIONS, CodamaError, logWarn } from '@codama/errors';\nimport { fileExists, joinPath, readJson, RenderMap, writeFile } from '@codama/renderers-core';\nimport { lt as ltVersion, minVersion, subset } from 'semver';\n\nimport type { CodeFormatter } from './formatCode';\nimport { Fragment, mergeFragments } from './fragment';\nimport { getExternalDependencies } from './importMap';\nimport { RenderOptions } from './options';\n\ntype DependencyVersions = Record<string, string>;\n\ntype PackageJson = {\n    author?: string;\n    dependencies?: DependencyVersions;\n    description?: string;\n    devDependencies?: DependencyVersions;\n    keywords?: string[];\n    main?: string;\n    name?: string;\n    peerDependencies?: DependencyVersions;\n    scripts?: Record<string, string>;\n    version?: string;\n};\n\nexport const DEFAULT_DEPENDENCY_VERSIONS: DependencyVersions = {\n    '@solana/accounts': '^5.0.0',\n    '@solana/addresses': '^5.0.0',\n    '@solana/codecs': '^5.0.0',\n    '@solana/errors': '^5.0.0',\n    '@solana/instructions': '^5.0.0',\n    '@solana/kit': '^5.0.0',\n    '@solana/programs': '^5.0.0',\n    '@solana/rpc-types': '^5.0.0',\n    '@solana/signers': '^5.0.0',\n};\n\nexport async function syncPackageJson(\n    renderMap: RenderMap<Fragment>,\n    formatCode: CodeFormatter,\n    options: Pick<\n        RenderOptions,\n        'dependencyMap' | 'dependencyVersions' | 'packageFolder' | 'syncPackageJson' | 'useGranularImports'\n    >,\n): Promise<void> {\n    const shouldSyncPackageJson = options.syncPackageJson ?? false;\n    const packageFolder = options.packageFolder;\n\n    // Without a `packageFolder`, we cannot sync the package.json.\n    if (!packageFolder) {\n        // If we should sync but have no folder, warn the user.\n        if (shouldSyncPackageJson) {\n            logWarn(\"Cannot sync package.json. Please provide the 'packageFolder' option.\");\n        }\n        return;\n    }\n\n    const packageJsonPath = joinPath(packageFolder, 'package.json');\n    const usedDependencies = getUsedDependencyVersions(\n        renderMap,\n        options.dependencyMap ?? {},\n        options.dependencyVersions ?? {},\n        options.useGranularImports ?? false,\n    );\n\n    // If we should not sync the package.json, exit early.\n    if (!shouldSyncPackageJson) {\n        // However, if the package.json exists, we can still check it and\n        // warn the user about out-of-date or missing dependencies.\n        if (fileExists(packageJsonPath)) {\n            checkExistingPackageJson(readJson(packageJsonPath), usedDependencies);\n        }\n        return;\n    }\n\n    if (fileExists(packageJsonPath)) {\n        const packageJson = updateExistingPackageJson(readJson(packageJsonPath), usedDependencies);\n        await writePackageJson(packageJson, packageJsonPath, formatCode);\n    } else {\n        const packageJson = createNewPackageJson(usedDependencies);\n        await writePackageJson(packageJson, packageJsonPath, formatCode);\n    }\n}\n\nexport function createNewPackageJson(dependencyVersions: DependencyVersions): PackageJson {\n    return updateExistingPackageJson(\n        {\n            name: 'js-client',\n            version: '1.0.0',\n            // eslint-disable-next-line sort-keys-fix/sort-keys-fix\n            description: '',\n            main: 'src/index.ts',\n            scripts: { test: 'echo \"Error: no test specified\" && exit 1' },\n            // eslint-disable-next-line sort-keys-fix/sort-keys-fix\n            keywords: [],\n            // eslint-disable-next-line sort-keys-fix/sort-keys-fix\n            author: '',\n        },\n        dependencyVersions,\n    );\n}\n\nexport function updateExistingPackageJson(\n    packageJson: PackageJson,\n    dependencyVersions: DependencyVersions,\n): PackageJson {\n    const updatedDependencies = { ...packageJson.dependencies };\n    const updatedPeerDependencies = { ...packageJson.peerDependencies };\n    const updatedDevDependencies = { ...packageJson.devDependencies };\n\n    for (const [dependency, requiredRange] of Object.entries(dependencyVersions)) {\n        let found: boolean = false;\n        if (updatedDependencies[dependency]) {\n            updateDependency(updatedDependencies, dependency, requiredRange);\n            found = true;\n        }\n        if (updatedPeerDependencies[dependency]) {\n            updateDependency(updatedPeerDependencies, dependency, requiredRange);\n            found = true;\n        }\n        if (updatedDevDependencies[dependency]) {\n            updateDependency(updatedDevDependencies, dependency, requiredRange);\n            found = true;\n        }\n        if (!found) {\n            const dependencyGroupToAdd = dependency === '@solana/kit' ? updatedPeerDependencies : updatedDependencies;\n            dependencyGroupToAdd[dependency] = requiredRange;\n        }\n    }\n\n    return {\n        ...packageJson,\n        ...(Object.entries(updatedPeerDependencies).length > 0 ? { peerDependencies: updatedPeerDependencies } : {}),\n        ...(Object.entries(updatedDependencies).length > 0 ? { dependencies: updatedDependencies } : {}),\n        ...(Object.entries(updatedDevDependencies).length > 0 ? { devDependencies: updatedDevDependencies } : {}),\n    };\n}\n\nexport function checkExistingPackageJson(packageJson: PackageJson, dependencyVersions: DependencyVersions): void {\n    const missingDependencies: string[] = [];\n    const dependenciesToUpdate: string[] = [];\n    const existingDependencies = {\n        ...packageJson.devDependencies,\n        ...packageJson.peerDependencies,\n        ...packageJson.dependencies,\n    };\n\n    for (const [dependency, requiredRange] of Object.entries(dependencyVersions)) {\n        if (!existingDependencies[dependency]) {\n            missingDependencies.push(dependency);\n        } else if (shouldUpdateRange(dependency, existingDependencies[dependency], requiredRange)) {\n            dependenciesToUpdate.push(dependency);\n        }\n    }\n\n    if (missingDependencies.length === 0 && dependenciesToUpdate.length === 0) return;\n    const missingList = missingDependencies.map(d => `- ${d} missing: ${dependencyVersions[d]}\\n`).join('');\n    const outdatedList = dependenciesToUpdate\n        .map(d => `- ${d} outdated: ${existingDependencies[d]} -> ${dependencyVersions[d]}\\n`)\n        .join('');\n    logWarn(\n        `The following dependencies in your \\`package.json\\` are out-of-date or missing:\\n` +\n            `${missingList}${outdatedList}`,\n    );\n}\n\nexport function getUsedDependencyVersions(\n    renderMap: RenderMap<Fragment>,\n    dependencyMap: Record<string, string>,\n    dependencyVersions: Record<string, string>,\n    useGranularImports: boolean,\n): DependencyVersions {\n    const dependencyVersionsWithDefaults = {\n        ...DEFAULT_DEPENDENCY_VERSIONS,\n        ...dependencyVersions,\n    };\n\n    const fragment = mergeFragments([...renderMap.values()], () => '');\n    const usedDependencies = getExternalDependencies(fragment.imports, dependencyMap, useGranularImports);\n\n    const [usedDependencyVersion, missingDependencies] = [...usedDependencies].reduce(\n        ([acc, missingDependencies], dependency) => {\n            const version = dependencyVersionsWithDefaults[dependency];\n            if (version) {\n                acc[dependency] = version;\n            } else {\n                missingDependencies.add(dependency);\n            }\n            return [acc, missingDependencies];\n        },\n        [{} as DependencyVersions, new Set<string>()],\n    );\n\n    if (missingDependencies.size > 0) {\n        throw new CodamaError(CODAMA_ERROR__RENDERERS__MISSING_DEPENDENCY_VERSIONS, {\n            dependencies: [...missingDependencies],\n            message: 'Please add these dependencies to the `dependencyVersions` option.',\n        });\n    }\n\n    return usedDependencyVersion;\n}\n\nexport function shouldUpdateRange(dependency: string, currentRange: string, requiredRange: string) {\n    try {\n        // Check if currentRange is a subset of requiredRange\n        // If yes, required is looser or equal, no update needed\n        if (subset(currentRange, requiredRange)) {\n            return false;\n        }\n\n        // Get the minimum versions from both ranges.\n        const minRequiredVersion = minVersion(requiredRange);\n        const minCurrentVersion = minVersion(currentRange);\n        if (!minCurrentVersion || !minRequiredVersion) {\n            throw new Error('Could not determine minimum versions.');\n        }\n\n        // Update if the minimum required version is greater than the current minimum version.\n        if (ltVersion(minCurrentVersion, minRequiredVersion)) {\n            return true;\n        }\n\n        // Otherwise, do not update.\n        return false;\n    } catch (error) {\n        console.warn(\n            `Could not parse the following ranges for dependency \"${dependency}\":` +\n                ` [${currentRange}] and/or [${requiredRange}].` +\n                ` Caused by: ${(error as Error).message}`,\n        );\n        return false;\n    }\n}\n\nfunction updateDependency(dependencyGroup: Record<string, string>, dependency: string, requiredRange: string) {\n    const currentRange = dependencyGroup[dependency];\n    if (!shouldUpdateRange(dependency, currentRange, requiredRange)) return;\n    dependencyGroup[dependency] = requiredRange;\n}\n\nasync function writePackageJson(\n    packageJson: PackageJson,\n    packageJsonPath: string,\n    formatCode: CodeFormatter,\n): Promise<void> {\n    const packageJsonContent = JSON.stringify(packageJson, null, 2) + '\\n';\n    const formattedContent = await formatCode(packageJsonContent, packageJsonPath);\n    writeFile(packageJsonPath, formattedContent);\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getAccountFetchHelpersFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const decodeFunction = nameApi.accountDecodeFunction(accountNode.name);\n    const fetchAllFunction = nameApi.accountFetchAllFunction(accountNode.name);\n    const fetchAllMaybeFunction = nameApi.accountFetchAllMaybeFunction(accountNode.name);\n    const fetchFunction = nameApi.accountFetchFunction(accountNode.name);\n    const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);\n\n    const hasCustomData = customAccountData.has(accountNode.name);\n    const accountType = hasCustomData ? typeManifest.strictType : nameApi.dataType(accountNode.name);\n    const decoderFunction = hasCustomData ? typeManifest.decoder : `${nameApi.decoderFunction(accountNode.name)}()`;\n\n    return pipe(\n        fragment`export function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<${accountType}, TAddress>;\nexport function ${decodeFunction}<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<${accountType}, TAddress>;\nexport function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<${accountType}, TAddress> | MaybeAccount<${accountType}, TAddress> {\n  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, ${decoderFunction});\n}\n\nexport async function ${fetchFunction}<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig,\n): Promise<Account<${accountType}, TAddress>> {\n  const maybeAccount = await ${fetchMaybeFunction}(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function ${fetchMaybeFunction}<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig,\n): Promise<MaybeAccount<${accountType}, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return ${decodeFunction}(maybeAccount);\n}\n\nexport async function ${fetchAllFunction}(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig,\n): Promise<Account<${accountType}>[]> {\n  const maybeAccounts = await ${fetchAllMaybeFunction}(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function ${fetchAllMaybeFunction}(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig,\n): Promise<MaybeAccount<${accountType}>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => ${decodeFunction}(maybeAccount));\n}`,\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n        f =>\n            addFragmentImports(f, 'solanaAccounts', [\n                'type Account',\n                'assertAccountExists',\n                'assertAccountsExist',\n                'decodeAccount',\n                'type EncodedAccount',\n                'fetchEncodedAccount',\n                'fetchEncodedAccounts',\n                'type FetchAccountConfig',\n                'type FetchAccountsConfig',\n                'type MaybeAccount',\n                'type MaybeEncodedAccount',\n            ]),\n    );\n}\n","import { AccountNode, isNodeFilter } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getAccountPdaHelpersFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'linkables' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment | undefined {\n    const { accountPath, nameApi, linkables, customAccountData, typeManifest } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const pdaNode = accountNode.pda ? linkables.get([...accountPath, accountNode.pda]) : undefined;\n    if (!pdaNode) return;\n\n    const accountType = customAccountData.has(accountNode.name)\n        ? typeManifest.strictType\n        : nameApi.dataType(accountNode.name);\n\n    // Here we cannot use the `getImportFrom` function because\n    // we need to know the seeds of the PDA in order to know\n    // if we need to render a `seeds` argument or not.\n    const importFrom = 'generatedPdas';\n    const pdaSeedsType = nameApi.pdaSeedsType(pdaNode.name);\n    const findPdaFunction = nameApi.pdaFindFunction(pdaNode.name);\n    const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n\n    const fetchFromSeedsFunction = nameApi.accountFetchFromSeedsFunction(accountNode.name);\n    const fetchMaybeFromSeedsFunction = nameApi.accountFetchMaybeFromSeedsFunction(accountNode.name);\n    const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);\n\n    return pipe(\n        fragment`export async function ${fetchFromSeedsFunction}(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ''}\n  config: FetchAccountConfig & { programAddress?: Address } = {},\n): Promise<Account<${accountType}>> {\n  const maybeAccount = await ${fetchMaybeFromSeedsFunction}(rpc, ${hasVariableSeeds ? 'seeds, ' : ''}config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function ${fetchMaybeFromSeedsFunction}(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ''}\n  config: FetchAccountConfig & { programAddress?: Address } = {},\n): Promise<MaybeAccount<${accountType}>> {\n  const { programAddress, ...fetchConfig } = config;\n  const [address] = await ${findPdaFunction}(${hasVariableSeeds ? 'seeds, ' : ''}{ programAddress });\n  return await ${fetchMaybeFunction}(rpc, address, fetchConfig);\n}`,\n        f => addFragmentImports(f, importFrom, hasVariableSeeds ? [pdaSeedsType, findPdaFunction] : [findPdaFunction]),\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n        f =>\n            addFragmentImports(f, 'solanaAccounts', [\n                'type Account',\n                'assertAccountExists',\n                'type FetchAccountConfig',\n                'type MaybeAccount',\n            ]),\n    );\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, fragment, RenderScope } from '../utils';\n\nexport function getAccountSizeHelpersFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { accountPath: NodePath<AccountNode> },\n): Fragment | undefined {\n    const { accountPath, nameApi } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    if (accountNode.size == null) return;\n\n    const getSizeFunction = nameApi.accountGetSizeFunction(accountNode.name);\n    return fragment`export function ${getSizeFunction}(): number {\n  return ${accountNode.size};\n}`;\n}\n","import { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getTypeFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: TypeManifest;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi, docs = [] } = scope;\n\n    const docblock = getDocblockFragment(docs, true);\n    const strictName = nameApi.dataType(name);\n    const looseName = nameApi.dataArgsType(name);\n    const aliasedLooseName = `export type ${looseName} = ${strictName};`;\n\n    if (manifest.isEnum) {\n        return fragment`${docblock}export enum ${strictName} ${manifest.strictType};\\n\\n${aliasedLooseName}`;\n    }\n\n    const looseExport =\n        manifest.strictType.content === manifest.looseType.content\n            ? aliasedLooseName\n            : fragment`export type ${looseName} = ${manifest.looseType};`;\n    return fragment`${docblock}export type ${strictName} = ${manifest.strictType};\\n\\n${looseExport}`;\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest, use } from '../utils';\n\nexport function getTypeDecoderFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'decoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { name, node, manifest, nameApi, docs = [] } = scope;\n    const decoderFunction = nameApi.decoderFunction(name);\n    const strictName = nameApi.dataType(name);\n\n    const docblock = getDocblockFragment(docs, true);\n    const decoderType = use(\n        typeof scope.size === 'number' ? 'type FixedSizeDecoder' : 'type Decoder',\n        'solanaCodecsCore',\n    );\n    const useTypeCast = isNode(node, 'enumTypeNode') && isDataEnum(node) && typeof scope.size === 'number';\n\n    const typeCast = useTypeCast ? fragment` as ${decoderType}<${strictName}>` : '';\n    return fragment`${docblock}export function ${decoderFunction}(): ${decoderType}<${strictName}> {\n    return ${manifest.decoder}${typeCast};\n}`;\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest, use } from '../utils';\n\nexport function getTypeEncoderFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'encoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { name, node, manifest, nameApi, docs = [] } = scope;\n    const encoderFunction = nameApi.encoderFunction(name);\n    const looseName = nameApi.dataArgsType(name);\n\n    const docblock = getDocblockFragment(docs, true);\n    const encoderType = use(\n        typeof scope.size === 'number' ? 'type FixedSizeEncoder' : 'type Encoder',\n        'solanaCodecsCore',\n    );\n    const useTypeCast = isNode(node, 'enumTypeNode') && isDataEnum(node) && typeof scope.size === 'number';\n\n    const typeCast = useTypeCast ? fragment` as ${encoderType}<${looseName}>` : '';\n    return fragment`${docblock}export function ${encoderFunction}(): ${encoderType}<${looseName}> {\n    return ${manifest.encoder}${typeCast};\n}`;\n}\n","import type { TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, TypeManifest, use } from '../utils';\nimport { getTypeDecoderFragment } from './typeDecoder';\nimport { getTypeEncoderFragment } from './typeEncoder';\n\nexport function getTypeCodecFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: Pick<TypeManifest, 'decoder' | 'encoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { codecDocs = [], name, nameApi } = scope;\n    const codecFunction = nameApi.codecFunction(name);\n    const decoderFunction = nameApi.decoderFunction(name);\n    const encoderFunction = nameApi.encoderFunction(name);\n    const looseName = nameApi.dataArgsType(name);\n    const strictName = nameApi.dataType(name);\n\n    const docblock = getDocblockFragment(codecDocs, true);\n    const codecType = use(typeof scope.size === 'number' ? 'type FixedSizeCodec' : 'type Codec', 'solanaCodecsCore');\n\n    return mergeFragments(\n        [\n            getTypeEncoderFragment({ ...scope, docs: scope.encoderDocs }),\n            getTypeDecoderFragment({ ...scope, docs: scope.decoderDocs }),\n            fragment`${docblock}export function ${codecFunction}(): ${codecType}<${looseName}, ${strictName}> {\n    return ${use('combineCodec', 'solanaCodecsCore')}(${encoderFunction}(), ${decoderFunction}());\n}`,\n        ],\n        renders => renders.join('\\n\\n'),\n    );\n}\n","import type { TypeNode } from '@codama/nodes';\n\nimport { Fragment, mergeFragments, RenderScope, TypeManifest } from '../utils';\nimport { getTypeFragment } from './type';\nimport { getTypeCodecFragment } from './typeCodec';\n\nexport function getTypeWithCodecFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: TypeManifest;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n        typeDocs?: string[];\n    },\n): Fragment {\n    return mergeFragments([getTypeFragment({ ...scope, docs: scope.typeDocs }), getTypeCodecFragment(scope)], renders =>\n        renders.join('\\n\\n'),\n    );\n}\n","import { AccountNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getAccountTypeFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        size: number | null;\n        typeManifest: TypeManifest;\n    },\n): Fragment | undefined {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    if (customAccountData.has(accountNode.name)) return;\n\n    return getTypeWithCodecFragment({\n        codecDocs: [`Gets the codec for {@link ${nameApi.dataType(accountNode.name)}} account data.`],\n        decoderDocs: [`Gets the decoder for {@link ${nameApi.dataType(accountNode.name)}} account data.`],\n        encoderDocs: [`Gets the encoder for {@link ${nameApi.dataArgsType(accountNode.name)}} account data.`],\n        manifest: typeManifest,\n        name: accountNode.name,\n        nameApi,\n        node: resolveNestedTypeNode(accountNode.data),\n        size: scope.size,\n        typeDocs: accountNode.docs,\n    });\n}\n","import {\n    camelCase,\n    ConstantDiscriminatorNode,\n    DiscriminatorNode,\n    FieldDiscriminatorNode,\n    InstructionArgumentNode,\n    isNode,\n    isNodeFilter,\n    StructFieldTypeNode,\n    VALUE_NODES,\n} from '@codama/nodes';\nimport { visit } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope } from '../utils';\n\nexport function getDiscriminatorConstantsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment {\n    const fragments = scope.discriminatorNodes\n        .map(node => getDiscriminatorConstantFragment(node, scope))\n        .filter(Boolean) as Fragment[];\n\n    return mergeFragments(fragments, c => c.join('\\n\\n'));\n}\n\nexport function getDiscriminatorConstantFragment(\n    discriminatorNode: DiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    switch (discriminatorNode.kind) {\n        case 'constantDiscriminatorNode':\n            return getConstantDiscriminatorConstantFragment(discriminatorNode, scope);\n        case 'fieldDiscriminatorNode':\n            return getFieldDiscriminatorConstantFragment(discriminatorNode, scope);\n        default:\n            return null;\n    }\n}\n\nexport function getConstantDiscriminatorConstantFragment(\n    discriminatorNode: ConstantDiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { discriminatorNodes, typeManifestVisitor, prefix } = scope;\n\n    const index = discriminatorNodes.filter(isNodeFilter('constantDiscriminatorNode')).indexOf(discriminatorNode);\n    const suffix = index <= 0 ? '' : `_${index + 1}`;\n\n    const name = camelCase(`${prefix}_discriminator${suffix}`);\n    const encoder = visit(discriminatorNode.constant.type, typeManifestVisitor).encoder;\n    const value = visit(discriminatorNode.constant.value, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nexport function getFieldDiscriminatorConstantFragment(\n    discriminatorNode: FieldDiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { fields, prefix, typeManifestVisitor } = scope;\n\n    const field = fields.find(f => f.name === discriminatorNode.name);\n    if (!field || !field.defaultValue || !isNode(field.defaultValue, VALUE_NODES)) {\n        return null;\n    }\n\n    const name = camelCase(`${prefix}_${discriminatorNode.name}`);\n    const encoder = visit(field.type, typeManifestVisitor).encoder;\n    const value = visit(field.defaultValue, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nfunction getConstantFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        encoder: Fragment;\n        name: string;\n        value: Fragment;\n    },\n): Fragment {\n    const { encoder, name, nameApi, value } = scope;\n    const constantName = nameApi.constant(name);\n    const constantFunction = nameApi.constantFunction(name);\n\n    return fragment`export const ${constantName} = ${value};\\n\\nexport function ${constantFunction}() { return ${encoder}.encode(${constantName}); }`;\n}\n","import { AccountNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, visit } from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getAccountFetchHelpersFragment } from './accountFetchHelpers';\nimport { getAccountPdaHelpersFragment } from './accountPdaHelpers';\nimport { getAccountSizeHelpersFragment } from './accountSizeHelpers';\nimport { getAccountTypeFragment } from './accountType';\nimport { getDiscriminatorConstantsFragment } from './discriminatorConstants';\n\nexport function getAccountPageFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'linkables' | 'nameApi' | 'typeManifestVisitor'> & {\n        accountPath: NodePath<AccountNode>;\n        size: number | null;\n    },\n): Fragment {\n    const node = getLastNodeFromPath(scope.accountPath);\n    if (!findProgramNodeFromPath(scope.accountPath)) {\n        throw new Error('Account must be visited inside a program.');\n    }\n\n    const typeManifest = visit(node, scope.typeManifestVisitor);\n    const fields = resolveNestedTypeNode(node.data).fields;\n    return mergeFragments(\n        [\n            getDiscriminatorConstantsFragment({\n                ...scope,\n                discriminatorNodes: node.discriminators ?? [],\n                fields,\n                prefix: node.name,\n            }),\n            getAccountTypeFragment({ ...scope, typeManifest }),\n            getAccountFetchHelpersFragment({ ...scope, typeManifest }),\n            getAccountSizeHelpersFragment(scope),\n            getAccountPdaHelpersFragment({ ...scope, typeManifest }),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n","import {\n    type ConstantDiscriminatorNode,\n    constantDiscriminatorNode,\n    constantValueNode,\n    constantValueNodeFromBytes,\n    type DiscriminatorNode,\n    type FieldDiscriminatorNode,\n    isNode,\n    isNodeFilter,\n    type ProgramNode,\n    type SizeDiscriminatorNode,\n    type StructTypeNode,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe, visit } from '@codama/visitors-core';\nimport { getBase64Decoder } from '@solana/codecs-strings';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\n/**\n * ```\n * if (data.length === 72) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, getU32Encoder().encode(42), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, new Uint8Array([1, 2, 3]), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n * ```\n */\nexport function getDiscriminatorConditionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        dataName: string;\n        discriminators: DiscriminatorNode[];\n        ifTrue: string;\n        programNode: ProgramNode;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    return pipe(\n        mergeFragments(\n            scope.discriminators.flatMap(discriminator => {\n                if (isNode(discriminator, 'sizeDiscriminatorNode')) {\n                    return [getSizeConditionFragment(discriminator, scope)];\n                }\n                if (isNode(discriminator, 'constantDiscriminatorNode')) {\n                    return [getByteConditionFragment(discriminator, scope)];\n                }\n                if (isNode(discriminator, 'fieldDiscriminatorNode')) {\n                    return [getFieldConditionFragment(discriminator, scope)];\n                }\n                return [];\n            }),\n            c => c.join(' && '),\n        ),\n        f => mapFragmentContent(f, c => `if (${c}) { ${scope.ifTrue} }`),\n    );\n}\n\nfunction getSizeConditionFragment(\n    discriminator: SizeDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName } = scope;\n    return fragment`${dataName}.length === ${discriminator.size}`;\n}\n\nfunction getByteConditionFragment(\n    discriminator: ConstantDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName, typeManifestVisitor } = scope;\n    const constant = visit(discriminator.constant, typeManifestVisitor).value;\n    return fragment`${use('containsBytes', 'solanaCodecsCore')}(${dataName}, ${constant}, ${discriminator.offset})`;\n}\n\nfunction getFieldConditionFragment(\n    discriminator: FieldDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    const field = scope.struct.fields.find(f => f.name === discriminator.name);\n    if (!field || !field.defaultValue) {\n        // TODO: Coded error.\n        throw new Error(\n            `Field discriminator \"${discriminator.name}\" does not have a matching argument with default value.`,\n        );\n    }\n\n    // This handles the case where a field uses an u8 array to represent its discriminator.\n    // In this case, we can simplify the generated code by delegating to a constantDiscriminatorNode.\n    if (\n        isNode(field.type, 'arrayTypeNode') &&\n        isNode(field.type.item, 'numberTypeNode') &&\n        field.type.item.format === 'u8' &&\n        isNode(field.type.count, 'fixedCountNode') &&\n        isNode(field.defaultValue, 'arrayValueNode') &&\n        field.defaultValue.items.every(isNodeFilter('numberValueNode'))\n    ) {\n        const base64Bytes = getBase64Decoder().decode(\n            new Uint8Array(field.defaultValue.items.map(node => node.number)),\n        );\n        return getByteConditionFragment(\n            constantDiscriminatorNode(constantValueNodeFromBytes('base64', base64Bytes), discriminator.offset),\n            scope,\n        );\n    }\n\n    return getByteConditionFragment(\n        constantDiscriminatorNode(constantValueNode(field.type, field.defaultValue), discriminator.offset),\n        scope,\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getErrorPageFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    return mergeFragments(\n        [\n            getConstantsFragment(scope),\n            getConstantUnionTypeFragment(scope),\n            getErrorMessagesFragment(scope),\n            getErrorMessageFunctionFragment(scope),\n            getIsErrorFunctionFragment(scope),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n\nfunction getConstantsFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    return mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.code - b.code)\n            .map(error => {\n                const docs = getDocblockFragment(error.docs ?? [], true);\n                const name = constantPrefix + scope.nameApi.programErrorConstant(error.name);\n                return fragment`${docs}export const ${name} = 0x${error.code.toString(16)}; // ${error.code}`;\n            }),\n        cs => cs.join('\\n'),\n    );\n}\n\nfunction getConstantUnionTypeFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    const typeName = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const errorTypes = mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.name.localeCompare(b.name))\n            .map(error => fragment`typeof ${constantPrefix + scope.nameApi.programErrorConstant(error.name)}`),\n        cs => cs.join(' | '),\n    );\n\n    return fragment`export type ${typeName} = ${errorTypes};`;\n}\n\nfunction getErrorMessagesFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const mapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);\n    const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    const messageEntries = mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.name.localeCompare(b.name))\n            .map(error => {\n                const constantName = constantPrefix + scope.nameApi.programErrorConstant(error.name);\n                const escapedMessage = error.message.replace(/`/g, '\\\\`');\n                return fragment`[${constantName}]: \\`${escapedMessage}\\``;\n            }),\n        cs => cs.join(', '),\n    );\n\n    return fragment`let ${mapName}: Record<${errorUnionType}, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  ${mapName} = { ${messageEntries} };\n}`;\n}\n\nfunction getErrorMessageFunctionFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const functionName = scope.nameApi.programGetErrorMessageFunction(scope.programNode.name);\n    const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const messageMapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);\n\n    return fragment`export function ${functionName}(code: ${errorUnionType}): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (${messageMapName} as Record<${errorUnionType}, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}`;\n}\n\nfunction getIsErrorFunctionFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n    const functionName = nameApi.programIsErrorFunction(programNode.name);\n    const programErrorUnion = nameApi.programErrorUnion(programNode.name);\n\n    return fragment`export function ${functionName}<TProgramErrorCode extends ${programErrorUnion}>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: ${use('type Address', 'solanaAddresses')} }> },\n    code?: TProgramErrorCode,\n): error is ${use('type SolanaError', 'solanaErrors')}<typeof ${use('type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM', 'solanaErrors')}> & Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return ${use('isProgramError', 'solanaPrograms')}<TProgramErrorCode>(error, transactionMessage, ${programAddressConstant}, code);\n}`;\n}\n","import { camelCase } from '@codama/nodes';\n\nimport { Fragment, getExportAllFragment, mergeFragments } from '../utils';\n\nexport function getIndexPageFragment(items: { name: string }[]): Fragment | undefined {\n    if (items.length === 0) return;\n\n    const names = items\n        .map(item => camelCase(item.name))\n        .sort((a, b) => a.localeCompare(b))\n        .map(name => getExportAllFragment(`./${name}`));\n\n    return mergeFragments(names, cs => cs.join('\\n'));\n}\n","import { InstructionAccountNode, pascalCase } from '@codama/nodes';\n\nimport { Fragment, fragment, use } from '../utils';\n\nexport function getInstructionAccountMetaFragment(instructionAccountNode: InstructionAccountNode): Fragment {\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n\n    // Writable, signer.\n    if (instructionAccountNode.isSigner === true && instructionAccountNode.isWritable) {\n        return fragment`${use('type WritableSignerAccount', 'solanaInstructions')}<${typeParam}> & ${use('type AccountSignerMeta', 'solanaSigners')}<${typeParam}>`;\n    }\n\n    // Readonly, signer.\n    if (instructionAccountNode.isSigner === true) {\n        return fragment`${use('type ReadonlySignerAccount', 'solanaInstructions')}<${typeParam}> & ${use('type AccountSignerMeta', 'solanaSigners')}<${typeParam}>`;\n    }\n\n    // Writable, non-signer or optional signer.\n    if (instructionAccountNode.isWritable) {\n        return fragment`${use('type WritableAccount', 'solanaInstructions')}<${typeParam}>`;\n    }\n\n    // Readonly, non-signer or optional signer.\n    return fragment`${use('type ReadonlyAccount', 'solanaInstructions')}<${typeParam}>`;\n}\n","import { InstructionAccountNode, InstructionInputValueNode, pascalCase } from '@codama/nodes';\nimport {\n    findInstructionNodeFromPath,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    LinkableDictionary,\n    NodePath,\n} from '@codama/visitors-core';\n\nimport { Fragment, fragment, RenderScope, use } from '../utils';\n\nexport function getInstructionAccountTypeParamFragment(\n    scope: Pick<RenderScope, 'linkables'> & {\n        allowAccountMeta: boolean;\n        instructionAccountPath: NodePath<InstructionAccountNode>;\n    },\n): Fragment {\n    const { instructionAccountPath, allowAccountMeta, linkables } = scope;\n    const instructionAccountNode = getLastNodeFromPath(instructionAccountPath);\n    const instructionNode = findInstructionNodeFromPath(instructionAccountPath)!;\n    const programNode = findProgramNodeFromPath(instructionAccountPath)!;\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n    const accountMeta = allowAccountMeta\n        ? fragment` | ${use('type AccountMeta', 'solanaInstructions')}<string>`\n        : undefined;\n\n    if (instructionNode.optionalAccountStrategy === 'omitted' && instructionAccountNode.isOptional) {\n        return fragment`${typeParam} extends string${accountMeta} | undefined = undefined`;\n    }\n\n    const defaultAddress = getDefaultAddress(instructionAccountNode.defaultValue, programNode.publicKey, linkables);\n    return fragment`${typeParam} extends string${accountMeta} = ${defaultAddress}`;\n}\n\nfunction getDefaultAddress(\n    defaultValue: InstructionInputValueNode | undefined,\n    programId: string,\n    linkables: LinkableDictionary,\n): string {\n    switch (defaultValue?.kind) {\n        case 'publicKeyValueNode':\n            return `\"${defaultValue.publicKey}\"`;\n        case 'programLinkNode':\n            // eslint-disable-next-line no-case-declarations\n            const programNode = linkables.get([defaultValue]);\n            return programNode ? `\"${programNode.publicKey}\"` : 'string';\n        case 'programIdValueNode':\n            return `\"${programId}\"`;\n        default:\n            return 'string';\n    }\n}\n","import { assertIsNode, camelCase, InstructionByteDeltaNode, InstructionNode, isNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentFeatures, Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getInstructionByteDeltaFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { byteDeltas } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (byteDeltas ?? []).flatMap(c => getByteDeltaFragment(c, scope));\n    if (fragments.length === 0) return;\n    return mergeFragments(\n        fragments,\n        c =>\n            `// Bytes created or reallocated by the instruction.\\n` +\n            `const byteDelta: number = [${c.join(',')}].reduce((a, b) => a + b, 0);`,\n    );\n}\n\nfunction getByteDeltaFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment[] {\n    let bytesFragment = ((): Fragment | null => {\n        if (isNode(byteDelta.value, 'numberValueNode')) {\n            return getNumberValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'accountLinkNode')) {\n            return getAccountLinkNodeFragment(byteDelta, scope);\n        }\n        if (isNode(byteDelta.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(byteDelta, scope);\n        }\n        return null;\n    })();\n\n    if (bytesFragment === null) return [];\n\n    if (byteDelta.withHeader) {\n        bytesFragment = fragment`${bytesFragment} + ${use('BASE_ACCOUNT_SIZE', 'solanaAccounts')}`;\n    }\n\n    if (byteDelta.subtract) {\n        bytesFragment = pipe(bytesFragment, f => mapFragmentContent(f, c => `- (${c})`));\n    }\n\n    return [bytesFragment];\n}\n\nfunction getNumberValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'numberValueNode');\n    return fragment`${byteDelta.value.number}`;\n}\n\nfunction getArgumentValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'argumentValueNode');\n    const argumentName = camelCase(byteDelta.value.name);\n    return fragment`Number(args.${argumentName})`;\n}\n\nfunction getAccountLinkNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'getImportFrom' | 'nameApi'>,\n): Fragment {\n    assertIsNode(byteDelta.value, 'accountLinkNode');\n    const functionName = use(\n        scope.nameApi.accountGetSizeFunction(byteDelta.value.name),\n        scope.getImportFrom(byteDelta.value),\n    );\n    return fragment`${functionName}()`;\n}\n\nfunction getResolverValueNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(byteDelta.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(byteDelta.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = use(\n        scope.nameApi.resolverFunction(byteDelta.value.name),\n        scope.getImportFrom(byteDelta.value),\n    );\n    return pipe(fragment`${awaitKeyword}${functionName}(resolverScope)`, f =>\n        addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n    );\n}\n","import { InstructionNode, structTypeNodeFromInstructionArgumentNodes } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getInstructionDataFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        size: number | null;\n    },\n): Fragment | undefined {\n    const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if (instructionNode.arguments.length === 0 || customInstructionData.has(instructionNode.name)) return;\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    return getTypeWithCodecFragment({\n        manifest: dataArgsManifest,\n        name: instructionDataName,\n        nameApi,\n        node: structTypeNodeFromInstructionArgumentNodes(instructionNode.arguments),\n        size: scope.size,\n    });\n}\n","import { InstructionNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getInstructionExtraArgsFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment | undefined {\n    const { instructionPath, extraArgsManifest, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if ((instructionNode.extraArguments ?? []).length === 0) return;\n\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    const looseName = nameApi.dataArgsType(instructionExtraName);\n    return mapFragmentContent(extraArgsManifest.looseType, c => `export type ${looseName} = ${c};`);\n}\n","/* eslint-disable no-case-declarations */\nimport { camelCase, InstructionInputValueNode, isNode, OptionalAccountStrategy } from '@codama/nodes';\nimport { mapFragmentContent, setFragmentContent } from '@codama/renderers-core';\nimport { pipe, ResolvedInstructionInput, visit } from '@codama/visitors-core';\n\nimport {\n    addFragmentFeatures,\n    addFragmentImports,\n    Fragment,\n    fragment,\n    isAsyncDefaultValue,\n    mergeFragments,\n    RenderScope,\n    use,\n} from '../utils';\n\nexport function getInstructionInputDefaultFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        input: ResolvedInstructionInput;\n        optionalAccountStrategy: OptionalAccountStrategy;\n        useAsync: boolean;\n    },\n): Fragment {\n    const { input, optionalAccountStrategy, asyncResolvers, useAsync, nameApi, typeManifestVisitor, getImportFrom } =\n        scope;\n    if (!input.defaultValue) {\n        return fragment``;\n    }\n\n    if (!useAsync && isAsyncDefaultValue(input.defaultValue, asyncResolvers)) {\n        return fragment``;\n    }\n\n    const { defaultValue } = input;\n    const defaultFragment = (renderedValue: Fragment, isWritable?: boolean): Fragment => {\n        const inputName = camelCase(input.name);\n        if (input.kind === 'instructionAccountNode' && isNode(defaultValue, 'resolverValueNode')) {\n            return fragment`accounts.${inputName} = { ...accounts.${inputName}, ...${renderedValue} };`;\n        }\n        if (input.kind === 'instructionAccountNode' && isWritable === undefined) {\n            return fragment`accounts.${inputName}.value = ${renderedValue};`;\n        }\n        if (input.kind === 'instructionAccountNode') {\n            return fragment`accounts.${inputName}.value = ${renderedValue};\\naccounts.${inputName}.isWritable = ${isWritable ? 'true' : 'false'}`;\n        }\n        return fragment`args.${inputName} = ${renderedValue};`;\n    };\n\n    const expectTransactionSigner = use('expectTransactionSigner', 'shared');\n    const expectSome = use('expectSome', 'shared');\n    const expectAddress = use('expectAddress', 'shared');\n    const expectProgramDerivedAddress = use('expectProgramDerivedAddress', 'shared');\n    const addressType = use('type Address', 'solanaAddresses');\n\n    switch (defaultValue.kind) {\n        case 'accountValueNode':\n            const name = camelCase(defaultValue.name);\n            if (input.kind === 'instructionAccountNode' && input.resolvedIsSigner && !input.isSigner) {\n                return defaultFragment(fragment`${expectTransactionSigner}(accounts.${name}.value).address`);\n            }\n            if (input.kind === 'instructionAccountNode') {\n                return defaultFragment(fragment`${expectSome}(accounts.${name}.value)`);\n            }\n            return defaultFragment(fragment`${expectAddress}(accounts.${name}.value)`);\n\n        case 'pdaValueNode':\n            let pdaProgramValue: Fragment | undefined;\n            if (isNode(defaultValue.programId, 'accountValueNode')) {\n                pdaProgramValue = fragment`${expectAddress}(accounts.${camelCase(defaultValue.programId.name)}.value)`;\n            }\n            if (isNode(defaultValue.programId, 'argumentValueNode')) {\n                pdaProgramValue = fragment`${expectAddress}(args.${camelCase(defaultValue.programId.name)})`;\n            }\n\n            // Inlined PDA value.\n            if (isNode(defaultValue.pda, 'pdaNode')) {\n                let pdaProgram = fragment`programAddress`;\n                if (pdaProgramValue) {\n                    pdaProgram = pdaProgramValue;\n                } else if (defaultValue.pda.programId) {\n                    pdaProgram = fragment`'${defaultValue.pda.programId}' as ${addressType}<'${defaultValue.pda.programId}'>`;\n                }\n                const pdaSeeds = defaultValue.pda.seeds.flatMap((seed): Fragment[] => {\n                    if (isNode(seed, 'constantPdaSeedNode') && isNode(seed.value, 'programIdValueNode')) {\n                        return [fragment`${use('getAddressEncoder', 'solanaAddresses')}().encode(${pdaProgram})`];\n                    }\n                    if (isNode(seed, 'constantPdaSeedNode') && !isNode(seed.value, 'programIdValueNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueManifest = visit(seed.value, typeManifestVisitor);\n                        return [fragment`${typeManifest.encoder}.encode(${valueManifest.value})`];\n                    }\n                    if (isNode(seed, 'variablePdaSeedNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueSeed = defaultValue.seeds.find(s => s.name === seed.name)?.value;\n                        if (!valueSeed) return [];\n                        if (isNode(valueSeed, 'accountValueNode')) {\n                            return [\n                                fragment`${typeManifest.encoder}.encode(${expectAddress}(accounts.${camelCase(valueSeed.name)}.value))`,\n                            ];\n                        }\n                        if (isNode(valueSeed, 'argumentValueNode')) {\n                            return [\n                                fragment`${typeManifest.encoder}.encode(${expectSome}(args.${camelCase(valueSeed.name)}))`,\n                            ];\n                        }\n                        const valueManifest = visit(valueSeed, typeManifestVisitor);\n                        return [fragment`${typeManifest.encoder}.encode(${valueManifest.value})`];\n                    }\n                    return [];\n                });\n                const getProgramDerivedAddress = use('getProgramDerivedAddress', 'solanaAddresses');\n                const programAddress =\n                    pdaProgram.content === 'programAddress' ? pdaProgram : fragment`programAddress: ${pdaProgram}`;\n                const seeds = mergeFragments(pdaSeeds, s => s.join(', '));\n                return defaultFragment(\n                    fragment`await ${getProgramDerivedAddress}({ ${programAddress}, seeds: [${seeds}] })`,\n                );\n            }\n\n            // Linked PDA value.\n            const pdaFunction = use(nameApi.pdaFindFunction(defaultValue.pda.name), getImportFrom(defaultValue.pda));\n            const pdaArgs: Fragment[] = [];\n            const pdaSeeds = defaultValue.seeds.map((seed): Fragment => {\n                if (isNode(seed.value, 'accountValueNode')) {\n                    return fragment`${seed.name}: ${expectAddress}(accounts.${camelCase(seed.value.name)}.value)`;\n                }\n                if (isNode(seed.value, 'argumentValueNode')) {\n                    return fragment`${seed.name}: ${expectSome}(args.${camelCase(seed.value.name)})`;\n                }\n                return pipe(visit(seed.value, typeManifestVisitor).value, f =>\n                    mapFragmentContent(f, c => `${seed.name}: ${c}`),\n                );\n            });\n            const pdaSeedsFragment = pipe(\n                mergeFragments(pdaSeeds, renders => renders.join(', ')),\n                f => mapFragmentContent(f, c => `{ ${c} }`),\n            );\n            if (pdaSeeds.length > 0) {\n                pdaArgs.push(pdaSeedsFragment);\n            }\n            if (pdaProgramValue) {\n                pdaArgs.push(fragment`{ programAddress: ${pdaProgramValue} }`);\n            }\n            return defaultFragment(fragment`await ${pdaFunction}(${mergeFragments(pdaArgs, c => c.join(', '))})`);\n\n        case 'publicKeyValueNode':\n            return defaultFragment(\n                fragment`'${defaultValue.publicKey}' as ${addressType}<'${defaultValue.publicKey}'>`,\n            );\n\n        case 'programLinkNode':\n            const programAddress = use(nameApi.programAddressConstant(defaultValue.name), getImportFrom(defaultValue));\n            return defaultFragment(programAddress, false);\n\n        case 'programIdValueNode':\n            if (\n                optionalAccountStrategy === 'programId' &&\n                input.kind === 'instructionAccountNode' &&\n                input.isOptional\n            ) {\n                return fragment``;\n            }\n            return defaultFragment(fragment`programAddress`, false);\n\n        case 'identityValueNode':\n        case 'payerValueNode':\n            return fragment``;\n\n        case 'accountBumpValueNode':\n            return defaultFragment(\n                fragment`${expectProgramDerivedAddress}(accounts.${camelCase(defaultValue.name)}.value)[1]`,\n            );\n\n        case 'argumentValueNode':\n            return defaultFragment(fragment`${expectSome}(args.${camelCase(defaultValue.name)})`);\n\n        case 'resolverValueNode':\n            const resolverFunction = use(nameApi.resolverFunction(defaultValue.name), getImportFrom(defaultValue));\n            const resolverAwait = useAsync && asyncResolvers.includes(defaultValue.name) ? 'await ' : '';\n            return pipe(defaultFragment(fragment`${resolverAwait}${resolverFunction}(resolverScope)`), f =>\n                addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n            );\n\n        case 'conditionalValueNode':\n            const ifTrueRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifTrue,\n            });\n            const ifFalseRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifFalse,\n            });\n            if (!ifTrueRenderer && !ifFalseRenderer) {\n                return fragment``;\n            }\n            let conditionalFragment = fragment``;\n            if (ifTrueRenderer) {\n                conditionalFragment = mergeFragments([conditionalFragment, ifTrueRenderer], c => c[0]);\n            }\n            if (ifFalseRenderer) {\n                conditionalFragment = mergeFragments([conditionalFragment, ifFalseRenderer], c => c[0]);\n            }\n            const negatedCondition = !ifTrueRenderer;\n            let condition = 'true';\n\n            if (isNode(defaultValue.condition, 'resolverValueNode')) {\n                const conditionalResolverFunction = nameApi.resolverFunction(defaultValue.condition.name);\n                const module = getImportFrom(defaultValue.condition);\n                conditionalFragment = pipe(\n                    conditionalFragment,\n                    f => addFragmentImports(f, module, [conditionalResolverFunction]),\n                    f => addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n                );\n                const conditionalResolverAwait =\n                    useAsync && asyncResolvers.includes(defaultValue.condition.name) ? 'await ' : '';\n                condition = `${conditionalResolverAwait}${conditionalResolverFunction}(resolverScope)`;\n                condition = negatedCondition ? `!${condition}` : condition;\n            } else {\n                const comparedInputName = isNode(defaultValue.condition, 'accountValueNode')\n                    ? `accounts.${camelCase(defaultValue.condition.name)}.value`\n                    : `args.${camelCase(defaultValue.condition.name)}`;\n                if (defaultValue.value) {\n                    const comparedValue = visit(defaultValue.value, typeManifestVisitor).value;\n                    conditionalFragment = mergeFragments([conditionalFragment, comparedValue], c => c[0]);\n                    const operator = negatedCondition ? '!==' : '===';\n                    condition = `${comparedInputName} ${operator} ${comparedValue.content}`;\n                } else {\n                    condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;\n                }\n            }\n\n            if (ifTrueRenderer && ifFalseRenderer) {\n                return setFragmentContent(\n                    conditionalFragment,\n                    `if (${condition}) {\\n${ifTrueRenderer.content}\\n} else {\\n${ifFalseRenderer.content}\\n}`,\n                );\n            }\n\n            return setFragmentContent(\n                conditionalFragment,\n                `if (${condition}) {\\n${ifTrueRenderer ? ifTrueRenderer.content : ifFalseRenderer?.content}\\n}`,\n            );\n\n        default:\n            const valueManifest = visit(defaultValue, typeManifestVisitor).value;\n            return defaultFragment(valueManifest);\n    }\n}\n\nfunction renderNestedInstructionDefault(\n    scope: Parameters<typeof getInstructionInputDefaultFragment>[0] & {\n        defaultValue: InstructionInputValueNode | undefined;\n    },\n): Fragment | undefined {\n    const { input, defaultValue } = scope;\n    if (!defaultValue) return undefined;\n    return getInstructionInputDefaultFragment({\n        ...scope,\n        input: { ...input, defaultValue },\n    });\n}\n","import { camelCase, InstructionNode, isNode, parseOptionalAccountStrategy } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath, ResolvedInstructionInput } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope } from '../utils';\nimport { getInstructionInputDefaultFragment } from './instructionInputDefault';\n\nexport function getInstructionInputResolvedFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    const resolvedInputFragments = scope.resolvedInputs.flatMap((input: ResolvedInstructionInput): Fragment[] => {\n        const inputFragment = getInstructionInputDefaultFragment({\n            ...scope,\n            input,\n            optionalAccountStrategy: parseOptionalAccountStrategy(instructionNode.optionalAccountStrategy),\n        });\n        if (!inputFragment.content) return [];\n        const camelName = camelCase(input.name);\n        return [\n            mapFragmentContent(inputFragment, c =>\n                isNode(input, 'instructionArgumentNode')\n                    ? `if (!args.${camelName}) {\\n${c}\\n}`\n                    : `if (!accounts.${camelName}.value) {\\n${c}\\n}`,\n            ),\n        ];\n    });\n\n    if (resolvedInputFragments.length === 0) {\n        return fragment``;\n    }\n\n    return mergeFragments([fragment`// Resolve default values.`, ...resolvedInputFragments], c => c.join('\\n'));\n}\n","import {\n    camelCase,\n    getAllInstructionArguments,\n    InstructionArgumentNode,\n    InstructionNode,\n    isNode,\n    pascalCase,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport {\n    getLastNodeFromPath,\n    NodePath,\n    pipe,\n    ResolvedInstructionAccount,\n    ResolvedInstructionArgument,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport {\n    Fragment,\n    fragment,\n    getDocblockFragment,\n    isAsyncDefaultValue,\n    mergeFragmentImports,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\n\nexport function getInstructionInputTypeFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionInputType = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    const [dataArgumentsFragment, customDataArgumentsFragment] = getDataArgumentsFragments(scope);\n\n    let accountTypeParams = '';\n    if (instructionNode.accounts.length > 0) {\n        accountTypeParams = instructionNode.accounts\n            .map(account => `TAccount${pascalCase(account.name)} extends string = string`)\n            .join(', ');\n        accountTypeParams = `<${accountTypeParams}>`;\n    }\n\n    const typeBodyFragment = mergeFragments(\n        [\n            getAccountsFragment(scope),\n            dataArgumentsFragment,\n            getExtraArgumentsFragment(scope),\n            getRemainingAccountsFragment(instructionNode),\n        ],\n        c => c.join('\\n'),\n    );\n\n    return fragment`export type ${instructionInputType}${accountTypeParams} = ${customDataArgumentsFragment} {\n  ${typeBodyFragment}\n}`;\n}\n\nfunction getAccountsFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, resolvedInputs, useAsync, asyncResolvers } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const fragments = instructionNode.accounts.map(account => {\n        const resolvedAccount = resolvedInputs.find(\n            input => input.kind === 'instructionAccountNode' && input.name === account.name,\n        ) as ResolvedInstructionAccount;\n        const hasDefaultValue =\n            !!resolvedAccount.defaultValue &&\n            !isNode(resolvedAccount.defaultValue, ['identityValueNode', 'payerValueNode']) &&\n            (useAsync || !isAsyncDefaultValue(resolvedAccount.defaultValue, asyncResolvers));\n        const docs = getDocblockFragment(account.docs ?? [], true);\n        const optionalSign = hasDefaultValue || resolvedAccount.isOptional ? '?' : '';\n        return fragment`${docs}${camelCase(account.name)}${optionalSign}: ${getAccountTypeFragment(resolvedAccount)};`;\n    });\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n\nfunction getAccountTypeFragment(account: Pick<ResolvedInstructionAccount, 'isPda' | 'isSigner' | 'name'>): Fragment {\n    const typeParam = `TAccount${pascalCase(account.name)}`;\n    const address = use('type Address', 'solanaAddresses');\n    const signer = use('type TransactionSigner', 'solanaSigners');\n    const pda = use('type ProgramDerivedAddress', 'solanaAddresses');\n\n    if (account.isPda && account.isSigner === false) return fragment`${pda}<${typeParam}>`;\n    if (account.isPda && account.isSigner === 'either') return fragment`${pda}<${typeParam}> | ${signer}<${typeParam}>`;\n    if (account.isSigner === 'either') return fragment`${address}<${typeParam}> | ${signer}<${typeParam}>`;\n    if (account.isSigner) return fragment`${signer}<${typeParam}>`;\n    return fragment`${address}<${typeParam}>`;\n}\n\nfunction getDataArgumentsFragments(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): [Fragment | undefined, Fragment] {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const customData = scope.customInstructionData.get(instructionNode.name);\n    if (customData) {\n        return [\n            undefined,\n            pipe(\n                fragment`${nameApi.dataArgsType(customData.importAs)}`,\n                f => mergeFragmentImports(f, [scope.dataArgsManifest.looseType.imports]),\n                f => mapFragmentContent(f, c => `${c} & `),\n            ),\n        ];\n    }\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const dataArgsType = nameApi.dataArgsType(instructionDataName);\n\n    const fragments = instructionNode.arguments.flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, dataArgsType, scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n\n    return [fragments.length === 0 ? undefined : mergeFragments(fragments, c => c.join('\\n')), fragment``];\n}\n\nfunction getExtraArgumentsFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): Fragment | undefined {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    const extraArgsType = nameApi.dataArgsType(instructionExtraName);\n\n    const fragments = (instructionNode.extraArguments ?? []).flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, extraArgsType, scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n    if (fragments.length === 0) return;\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n\nfunction getArgumentFragment(\n    arg: InstructionArgumentNode,\n    argsType: string,\n    resolvedInputs: ResolvedInstructionInput[],\n    renamedArgs: Map<string, string>,\n): Fragment | null {\n    const resolvedArg = resolvedInputs.find(\n        input => isNode(input, 'instructionArgumentNode') && input.name === arg.name,\n    ) as ResolvedInstructionArgument | undefined;\n    if (arg.defaultValue && arg.defaultValueStrategy === 'omitted') return null;\n    const renamedName = renamedArgs.get(arg.name) ?? arg.name;\n    const optionalSign = arg.defaultValue || resolvedArg?.defaultValue ? '?' : '';\n    return fragment`${camelCase(renamedName)}${optionalSign}: ${argsType}[\"${camelCase(arg.name)}\"];`;\n}\n\nfunction getRemainingAccountsFragment(instructionNode: InstructionNode): Fragment | undefined {\n    const fragments = (instructionNode.remainingAccounts ?? []).flatMap(remainingAccountsNode => {\n        if (isNode(remainingAccountsNode.value, 'resolverValueNode')) return [];\n\n        const { name } = remainingAccountsNode.value;\n        const allArguments = getAllInstructionArguments(instructionNode);\n        const argumentExists = allArguments.some(arg => arg.name === name);\n        if (argumentExists) return [];\n\n        const isSigner = remainingAccountsNode.isSigner ?? false;\n        const optionalSign = (remainingAccountsNode.isOptional ?? false) ? '?' : '';\n        const signerFragment = use('type TransactionSigner', 'solanaSigners');\n        const addressFragment = use('type Address', 'solanaAddresses');\n        const typeFragment = (() => {\n            if (isSigner === 'either') return fragment`${signerFragment} | ${addressFragment}`;\n            return isSigner ? signerFragment : addressFragment;\n        })();\n\n        return fragment`${camelCase(name)}${optionalSign}: Array<${typeFragment}>;`;\n    });\n    if (fragments.length === 0) return;\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n","import {\n    assertIsNode,\n    camelCase,\n    getAllInstructionArguments,\n    InstructionNode,\n    InstructionRemainingAccountsNode,\n    isNode,\n} from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport {\n    addFragmentFeatures,\n    addFragmentImports,\n    Fragment,\n    fragment,\n    mergeFragments,\n    RenderScope,\n    use,\n} from '../utils';\n\nexport function getInstructionRemainingAccountsFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { remainingAccounts } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (remainingAccounts ?? []).flatMap(a => getRemainingAccountsFragment(a, scope));\n    if (fragments.length === 0) return;\n    return pipe(\n        mergeFragments(\n            fragments,\n            c =>\n                `// Remaining accounts.\\n` +\n                `const remainingAccounts: AccountMeta[] = ${c.length === 1 ? c[0] : `[...${c.join(', ...')}]`}`,\n        ),\n        f => addFragmentImports(f, 'solanaInstructions', ['type AccountMeta']),\n    );\n}\n\nfunction getRemainingAccountsFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment[] {\n    const remainingAccountsFragment = ((): Fragment | null => {\n        if (isNode(remainingAccounts.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(remainingAccounts, scope);\n        }\n        if (isNode(remainingAccounts.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(remainingAccounts, scope);\n        }\n        return null;\n    })();\n\n    if (remainingAccountsFragment === null) return [];\n    return [remainingAccountsFragment];\n}\n\nfunction getArgumentValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: { instructionPath: NodePath<InstructionNode> },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    assertIsNode(remainingAccounts.value, 'argumentValueNode');\n    const argumentName = camelCase(remainingAccounts.value.name);\n    const isOptional = remainingAccounts.isOptional ?? false;\n    const isSigner = remainingAccounts.isSigner ?? false;\n    const isWritable = remainingAccounts.isWritable ?? false;\n    const accountRole = use('AccountRole', 'solanaInstructions');\n    const nonSignerRole = isWritable ? fragment`${accountRole}.WRITABLE` : fragment`${accountRole}.READONLY`;\n    const signerRole = isWritable ? fragment`${accountRole}.WRITABLE_SIGNER` : fragment`${accountRole}.READONLY_SIGNER`;\n    const role = isSigner === true ? signerRole : nonSignerRole;\n    const argumentArray = isOptional ? `(args.${argumentName} ?? [])` : `args.${argumentName}`;\n\n    // The argument already exists or was added as `Array<Address>`.\n    const allArguments = getAllInstructionArguments(instructionNode);\n    const argumentExists = allArguments.some(arg => arg.name === remainingAccounts.value.name);\n    if (argumentExists || isSigner === false) {\n        return fragment`${argumentArray}.map((address) => ({ address, role: ${role} }))`;\n    }\n\n    // The argument was added as `Array<TransactionSigner | Address>`.\n    if (isSigner === 'either') {\n        return fragment`${argumentArray}.map((addressOrSigner) => (${use('isTransactionSigner', 'shared')}(addressOrSigner) ? { address: addressOrSigner.address, role: ${role}, signer: addressOrSigner } : { address: addressOrSigner, role: ${role} }))`;\n    }\n\n    // The argument was added as `Array<TransactionSigner>`.\n    return fragment`${argumentArray}.map((signer) => ({ address: signer.address, role: ${signerRole}, signer }))`;\n}\n\nfunction getResolverValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(remainingAccounts.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(remainingAccounts.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = use(\n        scope.nameApi.resolverFunction(remainingAccounts.value.name),\n        scope.getImportFrom(remainingAccounts.value),\n    );\n    return pipe(fragment`${awaitKeyword}${functionName}(resolverScope)`, f =>\n        addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n    );\n}\n","import { camelCase, InstructionArgumentNode, InstructionNode, isNode, isNodeFilter, pascalCase } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport {\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    NodePath,\n    pipe,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getInstructionDependencies,\n    hasAsyncFunction,\n    isAsyncDefaultValue,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\nimport { NameApi } from '../utils/nameTransformers';\nimport { getInstructionByteDeltaFragment } from './instructionByteDelta';\nimport { getInstructionInputResolvedFragment } from './instructionInputResolved';\nimport { getInstructionInputTypeFragment } from './instructionInputType';\nimport { getInstructionRemainingAccountsFragment } from './instructionRemainingAccounts';\n\nexport function getInstructionFunctionFragment(\n    scope: Pick<\n        RenderScope,\n        'asyncResolvers' | 'customInstructionData' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'\n    > & {\n        dataArgsManifest: TypeManifest;\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { useAsync, instructionPath, resolvedInputs, renamedArgs, asyncResolvers, nameApi, customInstructionData } =\n        scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    if (useAsync && !hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers)) return;\n\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const instructionDependencies = getInstructionDependencies(instructionNode, asyncResolvers, useAsync);\n    const argDependencies = instructionDependencies.filter(isNodeFilter('argumentValueNode')).map(node => node.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n    const argIsNotOmitted = (arg: InstructionArgumentNode) =>\n        !(arg.defaultValue && arg.defaultValueStrategy === 'omitted');\n    const argIsDependent = (arg: InstructionArgumentNode) => argDependencies.includes(arg.name);\n    const argHasDefaultValue = (arg: InstructionArgumentNode) => {\n        if (!arg.defaultValue) return false;\n        if (useAsync) return true;\n        return !isAsyncDefaultValue(arg.defaultValue, asyncResolvers);\n    };\n    const hasDataArgs = !!customData || instructionNode.arguments.filter(argIsNotOmitted).length > 0;\n    const hasExtraArgs =\n        (instructionNode.extraArguments ?? []).filter(\n            field => argIsNotOmitted(field) && (argIsDependent(field) || argHasDefaultValue(field)),\n        ).length > 0;\n    const hasRemainingAccountArgs =\n        (instructionNode.remainingAccounts ?? []).filter(({ value }) => isNode(value, 'argumentValueNode')).length > 0;\n    const hasAnyArgs = hasDataArgs || hasExtraArgs || hasRemainingAccountArgs;\n    const hasInput = hasAccounts || hasAnyArgs;\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n\n    const functionName = useAsync\n        ? nameApi.instructionAsyncFunction(instructionNode.name)\n        : nameApi.instructionSyncFunction(instructionNode.name);\n\n    // Input.\n    const resolvedInputsFragment = getInstructionInputResolvedFragment(scope);\n    const remainingAccountsFragment = getInstructionRemainingAccountsFragment(scope);\n    const byteDeltaFragment = getInstructionByteDeltaFragment(scope);\n    const resolvedInputFragment = mergeFragments(\n        [resolvedInputsFragment, remainingAccountsFragment, byteDeltaFragment],\n        content => content.join('\\n\\n'),\n    );\n    const hasRemainingAccounts = !!remainingAccountsFragment;\n    const hasByteDeltas = !!byteDeltaFragment;\n    const hasResolver = resolvedInputFragment.features.has('instruction:resolverScopeVariable');\n    const instructionTypeFragment = getInstructionTypeFragment(scope);\n\n    const typeParams = getTypeParamsFragment(instructionNode, programAddressConstant);\n    const returnType = getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, useAsync);\n    const inputType = getInstructionInputTypeFragment(scope);\n    const inputArg = mapFragmentContent(getInputTypeCallFragment(scope), c => (hasInput ? `input: ${c}, ` : ''));\n    const functionBody = mergeFragments(\n        [\n            getProgramAddressInitializationFragment(programAddressConstant),\n            getAccountsInitializationFragment(instructionNode),\n            getArgumentsInitializationFragment(hasAnyArgs, renamedArgs),\n            getResolverScopeInitializationFragment(hasResolver, hasAccounts, hasAnyArgs),\n            resolvedInputFragment,\n            getReturnStatementFragment({\n                ...scope,\n                hasByteDeltas,\n                hasData,\n                hasDataArgs,\n                hasRemainingAccounts,\n                instructionNode,\n                syncReturnTypeFragment: getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, false),\n            }),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n\n    return fragment`${inputType}\\n\\nexport ${useAsync ? 'async ' : ''}function ${functionName}${typeParams}(${inputArg}config?: { programAddress?: TProgramAddress } ): ${returnType} {\n  ${functionBody}\n}`;\n}\n\nfunction getProgramAddressInitializationFragment(programAddressConstant: Fragment): Fragment {\n    return fragment`// Program address.\nconst programAddress = config?.programAddress ?? ${programAddressConstant};`;\n}\n\nfunction getAccountsInitializationFragment(instructionNode: InstructionNode): Fragment | undefined {\n    if (instructionNode.accounts.length === 0) return;\n\n    const accounts = mergeFragments(\n        instructionNode.accounts.map(account => {\n            const name = camelCase(account.name);\n            const isWritable = account.isWritable ? 'true' : 'false';\n            return fragment`${name}: { value: input.${name} ?? null, isWritable: ${isWritable} }`;\n        }),\n        cs => cs.join(', '),\n    );\n\n    return fragment` // Original accounts.\nconst originalAccounts = { ${accounts} }\nconst accounts = originalAccounts as Record<keyof typeof originalAccounts, ${use('type ResolvedAccount', 'shared')}>;\n`;\n}\n\nfunction getArgumentsInitializationFragment(\n    hasAnyArgs: boolean,\n    renamedArgs: Map<string, string>,\n): Fragment | undefined {\n    if (!hasAnyArgs) return;\n    const renamedArgsText = [...renamedArgs.entries()].map(([k, v]) => `${k}: input.${v}`).join(', ');\n\n    return fragment`// Original args.\nconst args = { ...input, ${renamedArgsText} };\n`;\n}\n\nfunction getResolverScopeInitializationFragment(\n    hasResolver: boolean,\n    hasAccounts: boolean,\n    hasAnyArgs: boolean,\n): Fragment | undefined {\n    if (!hasResolver) return;\n\n    const resolverAttributes = [\n        'programAddress',\n        ...(hasAccounts ? ['accounts'] : []),\n        ...(hasAnyArgs ? ['args'] : []),\n    ].join(', ');\n\n    return fragment`// Resolver scope.\nconst resolverScope = { ${resolverAttributes} };`;\n}\n\nfunction getReturnStatementFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        hasByteDeltas: boolean;\n        hasData: boolean;\n        hasDataArgs: boolean;\n        hasRemainingAccounts: boolean;\n        instructionNode: InstructionNode;\n        syncReturnTypeFragment: Fragment;\n    },\n): Fragment {\n    const { instructionNode, hasByteDeltas, hasData, hasDataArgs, hasRemainingAccounts, nameApi } = scope;\n    const optionalAccountStrategy = instructionNode.optionalAccountStrategy ?? 'programId';\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const hasLegacyOptionalAccounts =\n        instructionNode.optionalAccountStrategy === 'omitted' &&\n        instructionNode.accounts.some(account => account.isOptional);\n\n    // Account meta helper.\n    const getAccountMeta = hasAccounts\n        ? fragment`const getAccountMeta = ${use('getAccountMetaFactory', 'shared')}(programAddress, '${optionalAccountStrategy}');`\n        : '';\n\n    // Accounts.\n    const accountItems = [\n        ...instructionNode.accounts.map(account => `getAccountMeta(accounts.${camelCase(account.name)})`),\n        ...(hasRemainingAccounts ? ['...remainingAccounts'] : []),\n    ].join(', ');\n    let accounts: Fragment | undefined;\n    if (hasAccounts && hasLegacyOptionalAccounts) {\n        accounts = fragment`accounts: [${accountItems}].filter(<T>(x: T | undefined): x is T => x !== undefined)`;\n    } else if (hasAccounts) {\n        accounts = fragment`accounts: [${accountItems}]`;\n    } else if (hasRemainingAccounts) {\n        accounts = fragment`accounts: remainingAccounts`;\n    }\n\n    // Data.\n    const customData = scope.customInstructionData.get(instructionNode.name);\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const encoderFunctionFragment = customData\n        ? scope.dataArgsManifest.encoder\n        : `${nameApi.encoderFunction(instructionDataName)}()`;\n    const argsTypeFragment = customData ? scope.dataArgsManifest.looseType : nameApi.dataArgsType(instructionDataName);\n    let data: Fragment | undefined;\n    if (hasDataArgs) {\n        data = fragment`data: ${encoderFunctionFragment}.encode(args as ${argsTypeFragment})`;\n    } else if (hasData) {\n        data = fragment`data: ${encoderFunctionFragment}.encode({})`;\n    }\n\n    // Instruction.\n    const instructionAttributes = pipe(\n        [accounts, hasByteDeltas ? fragment`byteDelta` : undefined, data, fragment`programAddress`],\n        fs => mergeFragments(fs, cs => cs.join(', ')),\n    );\n\n    return fragment`${getAccountMeta}\\nreturn Object.freeze({ ${instructionAttributes} } as ${scope.syncReturnTypeFragment});`;\n}\n\nfunction getReturnTypeFragment(instructionTypeFragment: Fragment, hasByteDeltas: boolean, useAsync: boolean): Fragment {\n    return pipe(\n        instructionTypeFragment,\n        f => (hasByteDeltas ? fragment`${f} & ${use('type InstructionWithByteDelta', 'shared')}` : f),\n        f => (useAsync ? fragment`Promise<${f}>` : f),\n    );\n}\n\nfunction getTypeParamsFragment(instructionNode: InstructionNode, programAddressConstant: Fragment): Fragment {\n    return mergeFragments(\n        [\n            ...instructionNode.accounts.map(account => fragment`TAccount${pascalCase(account.name)} extends string`),\n            fragment`TProgramAddress extends ${use('type Address', 'solanaAddresses')} = typeof ${programAddressConstant}`,\n        ],\n        cs => `<${cs.join(', ')}>`,\n    );\n}\n\nfunction getInstructionTypeFragment(scope: { instructionPath: NodePath<InstructionNode>; nameApi: NameApi }): Fragment {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionTypeName = nameApi.instructionType(instructionNode.name);\n    const accountTypeParamsFragments = instructionNode.accounts.map(account => {\n        const typeParam = fragment`TAccount${pascalCase(account.name)}`;\n        const camelName = camelCase(account.name);\n\n        if (account.isSigner === 'either') {\n            const signerRole = use(\n                account.isWritable ? 'type WritableSignerAccount' : 'type ReadonlySignerAccount',\n                'solanaInstructions',\n            );\n            return pipe(\n                fragment`typeof input[\"${camelName}\"] extends TransactionSigner<${typeParam}> ? ${signerRole}<${typeParam}> & AccountSignerMeta<${typeParam}> : ${typeParam}`,\n                f => addFragmentImports(f, 'solanaSigners', ['type AccountSignerMeta', 'type TransactionSigner']),\n            );\n        }\n\n        return typeParam;\n    });\n\n    return pipe(\n        mergeFragments([fragment`TProgramAddress`, ...accountTypeParamsFragments], c => c.join(', ')),\n        f => mapFragmentContent(f, c => `${instructionTypeName}<${c}>`),\n    );\n}\n\nfunction getInputTypeCallFragment(scope: {\n    instructionPath: NodePath<InstructionNode>;\n    nameApi: NameApi;\n    useAsync: boolean;\n}): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const inputTypeName = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    if (instructionNode.accounts.length === 0) return fragment`${inputTypeName}`;\n    const accountTypeParams = instructionNode.accounts.map(account => `TAccount${pascalCase(account.name)}`).join(', ');\n\n    return fragment`${inputTypeName}<${accountTypeParams}>`;\n}\n","import { camelCase, InstructionNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getDocblockFragment,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\n\nexport function getInstructionParseFunctionFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    const programNode = findProgramNodeFromPath(scope.instructionPath)!;\n    const programAddressConstant = use(scope.nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n    const childScope = { ...scope, instructionNode, programAddressConstant };\n\n    return mergeFragments([getTypeFragment(childScope), getFunctionFragment(childScope)], cs => cs.join('\\n\\n'));\n}\n\nfunction getTypeFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionNode: InstructionNode;\n        programAddressConstant: Fragment;\n    },\n): Fragment {\n    const customData = scope.customInstructionData.get(scope.instructionNode.name);\n    const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);\n    const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);\n\n    const hasData = !!customData || scope.instructionNode.arguments.length > 0;\n    const hasAccounts = scope.instructionNode.accounts.length > 0;\n\n    const typeParamDeclarations = mergeFragments(\n        [\n            fragment`TProgram extends string = typeof ${scope.programAddressConstant}`,\n            hasAccounts\n                ? fragment`TAccountMetas extends readonly ${use('type AccountMeta', 'solanaInstructions')}[] = readonly AccountMeta[]`\n                : undefined,\n        ],\n        cs => cs.join(', '),\n    );\n\n    const accounts = mergeFragments(\n        scope.instructionNode.accounts.map((account, i) => {\n            const docs = getDocblockFragment(account.docs ?? [], true);\n            const name = camelCase(account.name);\n            return fragment`${docs}${name}${account.isOptional ? '?' : ''}: TAccountMetas[${i}]${account.isOptional ? ' | undefined' : ''};`;\n        }),\n        cs => (hasAccounts ? `\\naccounts: {\\n${cs.join('\\n')}\\n};` : ''),\n    );\n\n    const dataTypeFragment = customData\n        ? scope.dataArgsManifest.strictType\n        : fragment`${scope.nameApi.dataType(instructionDataName)}`;\n    const data = hasData ? fragment`\\ndata: ${dataTypeFragment};` : fragment``;\n\n    return fragment`export type ${instructionParsedType}<${typeParamDeclarations}> = { programAddress: ${use('type Address', 'solanaAddresses')}<TProgram>;${accounts}${data} };`;\n}\n\nfunction getFunctionFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionNode: InstructionNode;\n        programAddressConstant: Fragment;\n    },\n): Fragment {\n    const customData = scope.customInstructionData.get(scope.instructionNode.name);\n    const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);\n    const instructionParseFunction = scope.nameApi.instructionParseFunction(scope.instructionNode.name);\n    const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);\n    const decoderFunction = customData\n        ? scope.dataArgsManifest.decoder\n        : fragment`${scope.nameApi.decoderFunction(instructionDataName)}()`;\n\n    const hasData = !!customData || scope.instructionNode.arguments.length > 0;\n    const hasAccounts = scope.instructionNode.accounts.length > 0;\n    const hasOptionalAccounts = scope.instructionNode.accounts.some(account => account.isOptional);\n    const minimumNumberOfAccounts =\n        scope.instructionNode.optionalAccountStrategy === 'omitted'\n            ? scope.instructionNode.accounts.filter(account => !account.isOptional).length\n            : scope.instructionNode.accounts.length;\n\n    const typeParams = ['TProgram', hasAccounts ? 'TAccountMetas' : undefined].filter(Boolean).join(', ');\n    const typeParamDeclarations = mergeFragments(\n        [\n            fragment`TProgram extends string`,\n            hasAccounts\n                ? fragment`TAccountMetas extends readonly ${use('type AccountMeta', 'solanaInstructions')}[]`\n                : undefined,\n        ],\n        cs => cs.join(', '),\n    );\n\n    const instructionType = mergeFragments(\n        [\n            fragment`${use('type Instruction', 'solanaInstructions')}<TProgram>`,\n            hasAccounts\n                ? fragment`${use('type InstructionWithAccounts', 'solanaInstructions')}<TAccountMetas>`\n                : undefined,\n            hasData\n                ? pipe(\n                      fragment`InstructionWithData<ReadonlyUint8Array>`,\n                      f => addFragmentImports(f, 'solanaInstructions', ['type InstructionWithData']),\n                      f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n                  )\n                : undefined,\n        ],\n        cs => cs.join(' & '),\n    );\n\n    let accountHelpers: Fragment | undefined;\n    if (hasAccounts) {\n        accountHelpers = fragment`if (instruction.accounts.length < ${minimumNumberOfAccounts}) {\n  // TODO: Coded error.\n  throw new Error('Not enough accounts');\n}\nlet accountIndex = 0;\nconst getNextAccount = () => {\n  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n  accountIndex += 1;\n  return accountMeta;\n}`;\n    }\n    if (hasOptionalAccounts && scope.instructionNode.optionalAccountStrategy === 'omitted') {\n        accountHelpers = fragment`${accountHelpers}\nlet optionalAccountsRemaining = instruction.accounts.length - ${minimumNumberOfAccounts};\nconst getNextOptionalAccount = () => {\n  if (optionalAccountsRemaining === 0) return undefined;\n  optionalAccountsRemaining -= 1;\n  return getNextAccount();\n};`;\n    } else if (hasOptionalAccounts) {\n        accountHelpers = fragment`${accountHelpers}\nconst getNextOptionalAccount = () => {\n  const accountMeta = getNextAccount();\n  return accountMeta.address === ${scope.programAddressConstant} ? undefined : accountMeta;\n};`;\n    }\n\n    const accounts = mergeFragments(\n        scope.instructionNode.accounts.map(account =>\n            account.isOptional\n                ? fragment`${camelCase(account.name)}: getNextOptionalAccount()`\n                : fragment`${camelCase(account.name)}: getNextAccount()`,\n        ),\n        cs => (hasAccounts ? `, accounts: { ${cs.join(', ')} }` : ''),\n    );\n\n    const data = hasData ? fragment`, data: ${decoderFunction}.decode(instruction.data)` : fragment``;\n\n    return fragment`export function ${instructionParseFunction}<${typeParamDeclarations}>(instruction: ${instructionType}): ${instructionParsedType}<${typeParams}> {\n  ${accountHelpers}\n  return { programAddress: instruction.programAddress${accounts}${data} };\n}`;\n}\n","import { InstructionNode, pascalCase } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\nimport { getInstructionAccountMetaFragment } from './instructionAccountMeta';\nimport { getInstructionAccountTypeParamFragment } from './instructionAccountTypeParam';\n\nexport function getInstructionTypeFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'linkables' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n\n    const instructionType = nameApi.instructionType(instructionNode.name);\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n\n    const accountTypeParams = mergeFragments(\n        instructionNode.accounts.map(account =>\n            getInstructionAccountTypeParamFragment({\n                ...scope,\n                allowAccountMeta: true,\n                instructionAccountPath: [...instructionPath, account],\n            }),\n        ),\n        cs => (cs.length > 0 ? `${cs.join(', ')}, ` : ''),\n    );\n\n    const data = hasData\n        ? fragment` & ${use('type InstructionWithData', 'solanaInstructions')}<${use('type ReadonlyUint8Array', 'solanaCodecsCore')}>`\n        : undefined;\n\n    const usesLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === 'omitted';\n    const accountMetasFragment = mergeFragments(\n        instructionNode.accounts.map(account =>\n            mapFragmentContent(getInstructionAccountMetaFragment(account), c => {\n                const typeParam = `TAccount${pascalCase(account.name)}`;\n                const isLegacyOptional = account.isOptional && usesLegacyOptionalAccounts;\n                const type = `${typeParam} extends string ? ${c} : ${typeParam}`;\n                if (!isLegacyOptional) return type;\n                return `...(${typeParam} extends undefined ? [] : [${type}])`;\n            }),\n        ),\n        c => c.join(', '),\n    );\n\n    const instructionWithAccounts = use('type InstructionWithAccounts', 'solanaInstructions');\n    const accounts = hasAccounts\n        ? fragment` & ${instructionWithAccounts}<[${accountMetasFragment}, ...TRemainingAccounts]>`\n        : fragment` & ${instructionWithAccounts}<TRemainingAccounts>`;\n\n    return fragment`export type ${instructionType}<TProgram extends string = typeof ${programAddressConstant}, ${accountTypeParams}TRemainingAccounts extends readonly ${use('type AccountMeta', 'solanaInstructions')}<string>[] = []> =\n${use('type Instruction', 'solanaInstructions')}<TProgram>${data}${accounts};`;\n}\n","import { logWarn } from '@codama/errors';\nimport { camelCase, definedTypeNode, InstructionNode, structTypeNodeFromInstructionArgumentNodes } from '@codama/nodes';\nimport {\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    NodePath,\n    ResolvedInstructionInput,\n    visit,\n} from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getDiscriminatorConstantsFragment } from './discriminatorConstants';\nimport { getInstructionDataFragment } from './instructionData';\nimport { getInstructionExtraArgsFragment } from './instructionExtraArgs';\nimport { getInstructionFunctionFragment } from './instructionFunction';\nimport { getInstructionParseFunctionFragment } from './instructionParseFunction';\nimport { getInstructionTypeFragment } from './instructionType';\n\nexport function getInstructionPageFragment(\n    scope: Pick<\n        RenderScope,\n        'asyncResolvers' | 'customInstructionData' | 'getImportFrom' | 'linkables' | 'nameApi' | 'typeManifestVisitor'\n    > & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        size: number | null;\n    },\n): Fragment {\n    const node = getLastNodeFromPath(scope.instructionPath);\n    if (!findProgramNodeFromPath(scope.instructionPath)) {\n        throw new Error('Instruction must be visited inside a program.');\n    }\n\n    const childScope = {\n        ...scope,\n        dataArgsManifest: visit(node, scope.typeManifestVisitor),\n        extraArgsManifest: visit(\n            definedTypeNode({\n                name: scope.nameApi.instructionExtraType(node.name),\n                type: structTypeNodeFromInstructionArgumentNodes(node.extraArguments ?? []),\n            }),\n            scope.typeManifestVisitor,\n        ),\n        renamedArgs: getRenamedArgsMap(node),\n    };\n\n    return mergeFragments(\n        [\n            getDiscriminatorConstantsFragment({\n                ...childScope,\n                discriminatorNodes: node.discriminators ?? [],\n                fields: node.arguments,\n                prefix: node.name,\n            }),\n            getInstructionTypeFragment(childScope),\n            getInstructionDataFragment(childScope),\n            getInstructionExtraArgsFragment(childScope),\n            getInstructionFunctionFragment({ ...childScope, useAsync: true }),\n            getInstructionFunctionFragment({ ...childScope, useAsync: false }),\n            getInstructionParseFunctionFragment(childScope),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n\nfunction getRenamedArgsMap(instruction: InstructionNode): Map<string, string> {\n    const argNames = [\n        ...instruction.arguments.map(a => a.name),\n        ...(instruction.extraArguments ?? []).map(a => a.name),\n    ];\n    const duplicateArgs = argNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicateArgs.length > 0) {\n        throw new Error(`Duplicate args found: [${duplicateArgs.join(', ')}] in instruction [${instruction.name}].`);\n    }\n\n    const allNames = [...instruction.accounts.map(account => account.name), ...argNames];\n    const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicates.length === 0) return new Map();\n\n    logWarn(\n        `[JavaScript] Accounts and args of instruction [${instruction.name}] have the following ` +\n            `conflicting attributes [${duplicates.join(', ')}]. ` +\n            `Thus, the arguments have been renamed to avoid conflicts in the input type.`,\n    );\n\n    return new Map(duplicates.map(name => [camelCase(name), camelCase(`${name}Arg`)]));\n}\n","import { camelCase, isNode, isNodeFilter, PdaNode, PdaSeedNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, visit } from '@codama/visitors-core';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getPdaFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const seeds = parsePdaSeedNodes(pdaNode.seeds, scope);\n\n    return mergeFragments([getSeedInputTypeFragment(seeds, scope), getFunctionFragment(seeds, scope)], cs =>\n        cs.join('\\n\\n'),\n    );\n}\n\nfunction getSeedInputTypeFragment(\n    seeds: ParsedPdaSeedNode[],\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment | undefined {\n    const variableSeeds = seeds.filter(isNodeFilter('variablePdaSeedNode'));\n    if (variableSeeds.length === 0) return;\n\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);\n    const seedAttributes = mergeFragments(\n        variableSeeds.map(seed => seed.inputAttribute),\n        cs => cs.join('\\n'),\n    );\n\n    return fragment`export type ${seedTypeName} = {\\n${seedAttributes}\\n};`;\n}\n\nfunction getFunctionFragment(\n    seeds: ParsedPdaSeedNode[],\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const programNode = findProgramNodeFromPath(scope.pdaPath)!;\n\n    const addressType = use('type Address', 'solanaAddresses');\n    const pdaType = use('type ProgramDerivedAddress', 'solanaAddresses');\n    const getPdaFunction = use('getProgramDerivedAddress', 'solanaAddresses');\n\n    const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);\n    const findPdaFunction = scope.nameApi.pdaFindFunction(pdaNode.name);\n\n    const docs = getDocblockFragment(pdaNode.docs ?? [], true);\n    const hasVariableSeeds = seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n    const seedArgument = hasVariableSeeds ? `seeds: ${seedTypeName}, ` : '';\n    const programAddress = pdaNode.programId ?? programNode.publicKey;\n    const encodedSeeds = mergeFragments(\n        seeds.map(s => s.encodedValue),\n        cs => cs.join(', '),\n    );\n\n    return fragment`${docs}export async function ${findPdaFunction}(${seedArgument}config: { programAddress?: ${addressType} | undefined } = {}): Promise<${pdaType}> {\n  const { programAddress = '${programAddress}' as ${addressType}<'${programAddress}'> } = config;\n  return await ${getPdaFunction}({ programAddress, seeds: [${encodedSeeds}]});\n}`;\n}\n\ntype ParsedPdaSeedNode = PdaSeedNode & {\n    encodedValue: Fragment;\n    inputAttribute?: Fragment;\n};\n\nfunction parsePdaSeedNodes(seeds: PdaSeedNode[], scope: Pick<RenderScope, 'typeManifestVisitor'>): ParsedPdaSeedNode[] {\n    return seeds.map(seed => {\n        if (isNode(seed, 'variablePdaSeedNode')) {\n            const name = camelCase(seed.name);\n            const docs = getDocblockFragment(seed.docs ?? [], true);\n            const { encoder, looseType } = visit(seed.type, scope.typeManifestVisitor);\n            return {\n                ...seed,\n                encodedValue: fragment`${encoder}.encode(seeds.${name})`,\n                inputAttribute: fragment`${docs}${name}: ${looseType};`,\n            };\n        }\n\n        if (isNode(seed.value, 'programIdValueNode')) {\n            const addressEncoder = use('getAddressEncoder', 'solanaAddresses');\n            return { ...seed, encodedValue: fragment`${addressEncoder}().encode(programAddress)` };\n        }\n\n        const { encoder } = visit(seed.type, scope.typeManifestVisitor);\n        const { value } = visit(seed.value, scope.typeManifestVisitor);\n        return { ...seed, encodedValue: fragment`${encoder}.encode(${value})` };\n    });\n}\n","import { PdaNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope } from '../utils';\nimport { getPdaFunctionFragment } from './pdaFunction';\n\nexport function getPdaPageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    if (!findProgramNodeFromPath(scope.pdaPath)) {\n        throw new Error('PDA must be visited inside a program.');\n    }\n\n    return getPdaFunctionFragment(scope);\n}\n","import { ProgramNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, mergeFragments, RenderScope } from '../utils';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramAccountsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    if (scope.programNode.accounts.length === 0) return;\n    return mergeFragments(\n        [getProgramAccountsEnumFragment(scope), getProgramAccountsIdentifierFunctionFragment(scope)],\n        c => c.join('\\n\\n'),\n    );\n}\n\nfunction getProgramAccountsEnumFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsEnumVariants = programNode.accounts.map(account =>\n        nameApi.programAccountsEnumVariant(account.name),\n    );\n    return fragment`export enum ${programAccountsEnum} { ${programAccountsEnumVariants.join(', ')} }`;\n}\n\nfunction getProgramAccountsIdentifierFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    const { programNode, nameApi } = scope;\n    const accountsWithDiscriminators = programNode.accounts.filter(\n        account => (account.discriminators ?? []).length > 0,\n    );\n    const hasAccountDiscriminators = accountsWithDiscriminators.length > 0;\n    if (!hasAccountDiscriminators) return;\n\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsIdentifierFunction = nameApi.programAccountsIdentifierFunction(programNode.name);\n\n    return pipe(\n        mergeFragments(\n            accountsWithDiscriminators.map((account): Fragment => {\n                const variant = nameApi.programAccountsEnumVariant(account.name);\n                return getDiscriminatorConditionFragment({\n                    ...scope,\n                    dataName: 'data',\n                    discriminators: account.discriminators ?? [],\n                    ifTrue: `return ${programAccountsEnum}.${variant};`,\n                    struct: resolveNestedTypeNode(account.data),\n                });\n            }),\n            c => c.join('\\n'),\n        ),\n        f =>\n            mapFragmentContent(\n                f,\n                discriminators =>\n                    `export function ${programAccountsIdentifierFunction}(` +\n                    `account: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                    `): ${programAccountsEnum} {\\n` +\n                    `const data = 'data' in account ? account.data : account;\\n` +\n                    `${discriminators}\\n` +\n                    `throw new Error(\"The provided account could not be identified as a ${programNode.name} account.\")\\n` +\n                    `}`,\n            ),\n        f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope } from '../utils';\n\nexport function getProgramConstantFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n\n    return pipe(\n        fragment`export const ${programAddressConstant} = '${programNode.publicKey}' as Address<'${programNode.publicKey}'>;`,\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n    );\n}\n","import {\n    getAllInstructionsWithSubs,\n    InstructionNode,\n    ProgramNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramInstructionsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'renderParentInstructions' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    if (scope.programNode.instructions.length === 0) return;\n\n    const allInstructions = getAllInstructionsWithSubs(scope.programNode, {\n        leavesOnly: !scope.renderParentInstructions,\n        subInstructionsFirst: true,\n    });\n    const scopeWithInstructions = { ...scope, allInstructions };\n    return mergeFragments(\n        [\n            getProgramInstructionsEnumFragment(scopeWithInstructions),\n            getProgramInstructionsIdentifierFunctionFragment(scopeWithInstructions),\n            getProgramInstructionsParsedUnionTypeFragment(scopeWithInstructions),\n        ],\n        c => c.join('\\n\\n'),\n    );\n}\n\nfunction getProgramInstructionsEnumFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsEnumVariants = allInstructions.map(instruction =>\n        nameApi.programInstructionsEnumVariant(instruction.name),\n    );\n    return fragment`export enum ${programInstructionsEnum} { ${programInstructionsEnumVariants.join(', ')} }`;\n}\n\nfunction getProgramInstructionsIdentifierFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    const { programNode, nameApi, allInstructions } = scope;\n    const instructionsWithDiscriminators = allInstructions.filter(\n        instruction => (instruction.discriminators ?? []).length > 0,\n    );\n    const hasInstructionDiscriminators = instructionsWithDiscriminators.length > 0;\n    if (!hasInstructionDiscriminators) return;\n\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsIdentifierFunction = nameApi.programInstructionsIdentifierFunction(programNode.name);\n    const discriminatorsFragment = mergeFragments(\n        instructionsWithDiscriminators.map((instruction): Fragment => {\n            const variant = nameApi.programInstructionsEnumVariant(instruction.name);\n            return getDiscriminatorConditionFragment({\n                ...scope,\n                dataName: 'data',\n                discriminators: instruction.discriminators ?? [],\n                ifTrue: `return ${programInstructionsEnum}.${variant};`,\n                struct: structTypeNodeFromInstructionArgumentNodes(instruction.arguments),\n            });\n        }),\n        c => c.join('\\n'),\n    );\n\n    return pipe(\n        discriminatorsFragment,\n        f =>\n            mapFragmentContent(\n                f,\n                discriminators =>\n                    `export function ${programInstructionsIdentifierFunction}(` +\n                    `instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                    `): ${programInstructionsEnum} {\\n` +\n                    `const data = 'data' in instruction ? instruction.data : instruction;\\n` +\n                    `${discriminators}\\n` +\n                    `throw new Error(\"The provided instruction could not be identified as a ${programNode.name} instruction.\")\\n` +\n                    `}`,\n            ),\n        f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n    );\n}\n\nfunction getProgramInstructionsParsedUnionTypeFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n\n    const programAddress = programNode.publicKey;\n    const programInstructionsType = nameApi.programInstructionsParsedUnionType(programNode.name);\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n\n    const typeVariants = allInstructions.map((instruction): Fragment => {\n        const instructionEnumVariant = nameApi.programInstructionsEnumVariant(instruction.name);\n        const parsedInstructionType = use(\n            `type ${nameApi.instructionParsedType(instruction.name)}`,\n            'generatedInstructions',\n        );\n\n        return fragment`| { instructionType: ${programInstructionsEnum}.${instructionEnumVariant} } & ${parsedInstructionType}<TProgram>`;\n    });\n\n    return mergeFragments(\n        [\n            fragment`export type ${programInstructionsType}<TProgram extends string = '${programAddress}'> =`,\n            ...typeVariants,\n        ],\n        c => c.join('\\n'),\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getProgramAccountsFragment } from './programAccounts';\nimport { getProgramConstantFragment } from './programConstant';\nimport { getProgramInstructionsFragment } from './programInstructions';\n\nexport function getProgramPageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'renderParentInstructions' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    return mergeFragments(\n        [getProgramConstantFragment(scope), getProgramAccountsFragment(scope), getProgramInstructionsFragment(scope)],\n        cs => cs.join('\\n\\n'),\n    );\n}\n","import { AccountNode, DefinedTypeNode, InstructionNode, PdaNode, ProgramNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getExportAllFragment, mergeFragments } from '../utils';\n\nexport function getRootIndexPageFragment(scope: {\n    accountsToExport: AccountNode[];\n    definedTypesToExport: DefinedTypeNode[];\n    instructionsToExport: InstructionNode[];\n    pdasToExport: PdaNode[];\n    programsToExport: ProgramNode[];\n}): Fragment {\n    const hasAnythingToExport =\n        scope.programsToExport.length > 0 ||\n        scope.accountsToExport.length > 0 ||\n        scope.instructionsToExport.length > 0 ||\n        scope.definedTypesToExport.length > 0;\n\n    if (!hasAnythingToExport) {\n        return fragment`export default {};`;\n    }\n\n    const programsWithErrorsToExport = scope.programsToExport.filter(p => p.errors.length > 0);\n\n    return mergeFragments(\n        [\n            scope.accountsToExport.length > 0 ? getExportAllFragment('./accounts') : undefined,\n            programsWithErrorsToExport.length > 0 ? getExportAllFragment('./errors') : undefined,\n            scope.instructionsToExport.length > 0 ? getExportAllFragment('./instructions') : undefined,\n            scope.pdasToExport.length > 0 ? getExportAllFragment('./pdas') : undefined,\n            scope.programsToExport.length > 0 ? getExportAllFragment('./programs') : undefined,\n            scope.definedTypesToExport.length > 0 ? getExportAllFragment('./types') : undefined,\n        ],\n        cs => cs.join('\\n'),\n    );\n}\n","import { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment } from '../utils';\n\nexport function getSharedPageFragment(): Fragment {\n    const sharedPage = fragment`/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<T extends string = string, U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null = Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null> = {\n  isWritable: boolean;\n  value: U;\n};\n\n /**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n* Get account metas and signers from resolved accounts.\n* @internal\n*/\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId',\n) {\n  return (account: ResolvedAccount): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({ address: programAddress, role: AccountRole.READONLY });\n    }\n\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {})\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>): value is TransactionSigner<TAddress> {\n  return !!value && typeof value === 'object' && 'address' in value && kitIsTransactionSigner(value);\n}`;\n\n    return pipe(\n        sharedPage,\n        f =>\n            addFragmentImports(f, 'solanaAddresses', [\n                'type Address',\n                'isProgramDerivedAddress',\n                'type ProgramDerivedAddress',\n            ]),\n        f => addFragmentImports(f, 'solanaInstructions', ['AccountRole', 'type AccountMeta', 'upgradeRoleToSigner']),\n        f =>\n            addFragmentImports(f, 'solanaSigners', [\n                'type AccountSignerMeta',\n                'isTransactionSigner as kitIsTransactionSigner',\n                'type TransactionSigner',\n            ]),\n    );\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getTypeDiscriminatedUnionHelpersFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { name: string; typeNode: TypeNode },\n): Fragment | undefined {\n    const { name, typeNode, nameApi } = scope;\n    const isDiscriminatedUnion = isNode(typeNode, 'enumTypeNode') && isDataEnum(typeNode);\n    if (!isDiscriminatedUnion) return;\n\n    const functionName = nameApi.discriminatedUnionFunction(name);\n    const isDiscriminatedUnionFunctionName = nameApi.isDiscriminatedUnionFunction(name);\n    const discriminatorName = nameApi.discriminatedUnionDiscriminator(name);\n    const strictName = nameApi.dataType(name);\n    const looseName = nameApi.dataArgsType(name);\n\n    const getVariantContentType = use('type GetDiscriminatedUnionVariantContent', 'solanaCodecsDataStructures');\n    const getVariantType = use('type GetDiscriminatedUnionVariant', 'solanaCodecsDataStructures');\n    const variantSignatures = mergeFragments(\n        typeNode.variants.map(variant => {\n            const variantName = nameApi.discriminatedUnionVariant(variant.name);\n            if (isNode(variant, 'enumStructVariantTypeNode')) {\n                return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n            }\n            if (isNode(variant, 'enumTupleVariantTypeNode')) {\n                return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>['fields']): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n            }\n            return fragment`export function ${functionName}(kind: '${variantName}'): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n        }),\n        cs => (cs.length > 0 ? `${cs.join('\\n')}\\n` : ''),\n    );\n\n    return fragment`// Data Enum Helpers.\n${variantSignatures}export function ${functionName}<K extends ${looseName}['${discriminatorName}'], Data>(kind: K, data?: Data) {\n  return Array.isArray(data) ? { ${discriminatorName}: kind, fields: data } : { ${discriminatorName}: kind, ...(data ?? {}) };\n}\n\nexport function ${isDiscriminatedUnionFunctionName}<K extends ${strictName}['${discriminatorName}']>(kind: K, value: ${strictName}): value is ${strictName} & { ${discriminatorName}: K } {\n  return value.${discriminatorName} === kind;\n};\n`;\n}\n","import { DefinedTypeNode } from '@codama/nodes';\nimport { pipe, visit } from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, removeFragmentImports, RenderScope } from '../utils';\nimport { getTypeDiscriminatedUnionHelpersFragment } from './typeDiscriminatedUnionHelpers';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getTypePageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & { node: DefinedTypeNode; size: number | null },\n): Fragment {\n    const node = scope.node;\n    const manifest = visit(node, scope.typeManifestVisitor);\n    return pipe(\n        mergeFragments(\n            [\n                getTypeWithCodecFragment({ ...scope, manifest, name: node.name, node: node.type, typeDocs: node.docs }),\n                getTypeDiscriminatedUnionHelpersFragment({ ...scope, name: node.name, typeNode: node.type }),\n            ],\n            cs => cs.join('\\n\\n'),\n        ),\n        f =>\n            removeFragmentImports(f, 'generatedTypes', [\n                scope.nameApi.dataType(node.name),\n                scope.nameApi.dataArgsType(node.name),\n                scope.nameApi.encoderFunction(node.name),\n                scope.nameApi.decoderFunction(node.name),\n                scope.nameApi.codecFunction(node.name),\n            ]),\n    );\n}\n","import {\n    camelCase,\n    CamelCaseString,\n    CountNode,\n    isNode,\n    isNodeFilter,\n    isScalarEnum,\n    REGISTERED_TYPE_NODE_KINDS,\n    REGISTERED_VALUE_NODE_KINDS,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    structTypeNodeFromInstructionArgumentNodes,\n    TypeNode,\n} from '@codama/nodes';\nimport { mapFragmentContent, setFragmentContent } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    findLastNodeFromPath,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getBytesFromBytesValueNode,\n    getDocblockFragment,\n    GetImportFromFunction,\n    mergeFragments,\n    mergeTypeManifests,\n    NameApi,\n    ParsedCustomDataOptions,\n    TypeManifest,\n    typeManifest,\n    use,\n} from '../utils';\n\nexport type TypeManifestVisitor = ReturnType<typeof getTypeManifestVisitor>;\n\nexport function getTypeManifestVisitor(input: {\n    customAccountData: ParsedCustomDataOptions;\n    customInstructionData: ParsedCustomDataOptions;\n    getImportFrom: GetImportFromFunction;\n    linkables: LinkableDictionary;\n    nameApi: NameApi;\n    nonScalarEnums: CamelCaseString[];\n    stack?: NodeStack;\n}) {\n    const { nameApi, linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;\n    const stack = input.stack ?? new NodeStack();\n    let parentName: { loose: string; strict: string } | null = null;\n\n    return pipe(\n        staticVisitor(() => typeManifest(), {\n            keys: [\n                ...REGISTERED_TYPE_NODE_KINDS,\n                ...REGISTERED_VALUE_NODE_KINDS,\n                'definedTypeLinkNode',\n                'definedTypeNode',\n                'accountNode',\n                'instructionNode',\n            ],\n        }),\n        visitor =>\n            extendVisitor(visitor, {\n                visitAccount(account, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(account.name),\n                        strict: nameApi.dataType(account.name),\n                    };\n                    const link = customAccountData.get(account.name)?.linkNode;\n                    const manifest = link ? visit(link, self) : visit(account.data, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitAmountType(amountType, { self }) {\n                    return visit(amountType.number, self);\n                },\n\n                visitArrayType(arrayType, { self }) {\n                    const childManifest = visit(arrayType.item, self);\n                    const sizeManifest = getArrayLikeSizeOption(arrayType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getArrayDecoder', 'solanaCodecsDataStructures')}(${childManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getArrayEncoder', 'solanaCodecsDataStructures')}(${childManifest.encoder}${encoderOptions})`,\n                        looseType: fragment`Array<${childManifest.looseType}>`,\n                        strictType: fragment`Array<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitArrayValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitBooleanType(booleanType, { self }) {\n                    let sizeEncoder = fragment``;\n                    let sizeDecoder = fragment``;\n                    const resolvedSize = resolveNestedTypeNode(booleanType.size);\n                    if (resolvedSize.format !== 'u8' || resolvedSize.endian !== 'le') {\n                        const size = visit(booleanType.size, self);\n                        sizeEncoder = fragment`{ size: ${size.encoder} }`;\n                        sizeDecoder = fragment`{ size: ${size.decoder} }`;\n                    }\n\n                    return typeManifest({\n                        decoder: fragment`${use('getBooleanDecoder', 'solanaCodecsDataStructures')}(${sizeDecoder})`,\n                        encoder: fragment`${use('getBooleanEncoder', 'solanaCodecsDataStructures')}(${sizeEncoder})`,\n                        looseType: fragment`boolean`,\n                        strictType: fragment`boolean`,\n                    });\n                },\n\n                visitBooleanValue(node) {\n                    return typeManifest({ value: fragment`${JSON.stringify(node.boolean)}` });\n                },\n\n                visitBytesType() {\n                    const readonlyUint8Array = use('type ReadonlyUint8Array', 'solanaCodecsCore');\n                    return typeManifest({\n                        decoder: fragment`${use('getBytesDecoder', 'solanaCodecsDataStructures')}()`,\n                        encoder: fragment`${use('getBytesEncoder', 'solanaCodecsDataStructures')}()`,\n                        looseType: readonlyUint8Array,\n                        strictType: readonlyUint8Array,\n                    });\n                },\n\n                visitBytesValue(node) {\n                    const bytes = getBytesFromBytesValueNode(node);\n                    return typeManifest({ value: fragment`new Uint8Array([${Array.from(bytes).join(', ')}])` });\n                },\n\n                visitConstantValue(node, { self }) {\n                    if (isNode(node.type, 'bytesTypeNode') && isNode(node.value, 'bytesValueNode')) {\n                        return visit(node.value, self);\n                    }\n                    return typeManifest({\n                        value: fragment`${visit(node.type, self).encoder}.encode(${visit(node.value, self).value})`,\n                    });\n                },\n\n                visitDateTimeType(dateTimeType, { self }) {\n                    return visit(dateTimeType.number, self);\n                },\n\n                visitDefinedType(definedType, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(definedType.name),\n                        strict: nameApi.dataType(definedType.name),\n                    };\n                    const manifest = visit(definedType.type, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const strictName = nameApi.dataType(node.name);\n                    const looseName = nameApi.dataArgsType(node.name);\n                    const encoderFunction = nameApi.encoderFunction(node.name);\n                    const decoderFunction = nameApi.decoderFunction(node.name);\n                    const importFrom = getImportFrom(node);\n\n                    return typeManifest({\n                        decoder: fragment`${use(decoderFunction, importFrom)}()`,\n                        encoder: fragment`${use(encoderFunction, importFrom)}()`,\n                        looseType: use(`type ${looseName}`, importFrom),\n                        strictType: use(`type ${strictName}`, importFrom),\n                    });\n                },\n\n                visitEnumEmptyVariantType(enumEmptyVariantType) {\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(camelCase(parentName?.strict ?? ''));\n                    const name = nameApi.discriminatedUnionVariant(enumEmptyVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    return typeManifest({\n                        decoder: fragment`['${name}', ${use('getUnitDecoder', 'solanaCodecsDataStructures')}()]`,\n                        encoder: fragment`['${name}', ${use('getUnitEncoder', 'solanaCodecsDataStructures')}()]`,\n                        looseType: fragment`{ ${kindAttribute} }`,\n                        strictType: fragment`{ ${kindAttribute} }`,\n                    });\n                },\n\n                visitEnumStructVariantType(enumStructVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumStructVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n\n                    parentName = null;\n                    const structManifest = visit(enumStructVariantType.struct, self);\n                    parentName = currentParentName;\n\n                    return typeManifest({\n                        ...structManifest,\n                        decoder: fragment`['${name}', ${structManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${structManifest.encoder}]`,\n                        looseType: pipe(structManifest.looseType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                        strictType: pipe(structManifest.strictType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                    });\n                },\n\n                visitEnumTupleVariantType(enumTupleVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumTupleVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    const struct = structTypeNode([\n                        structFieldTypeNode({\n                            name: 'fields',\n                            type: enumTupleVariantType.tuple,\n                        }),\n                    ]);\n\n                    parentName = null;\n                    const structManifest = visit(struct, self);\n                    parentName = currentParentName;\n\n                    return typeManifest({\n                        ...structManifest,\n                        decoder: fragment`['${name}', ${structManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${structManifest.encoder}]`,\n                        looseType: pipe(structManifest.looseType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                        strictType: pipe(structManifest.strictType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                    });\n                },\n\n                visitEnumType(enumType, { self }) {\n                    const currentParentName = parentName;\n                    const encoderOptions: Fragment[] = [];\n                    const decoderOptions: Fragment[] = [];\n\n                    const enumSize = resolveNestedTypeNode(enumType.size);\n                    if (enumSize.format !== 'u8' || enumSize.endian !== 'le') {\n                        const sizeManifest = visit(enumType.size, self);\n                        encoderOptions.push(fragment`size: ${sizeManifest.encoder}`);\n                        decoderOptions.push(fragment`size: ${sizeManifest.decoder}`);\n                    }\n\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    if (!isScalarEnum(enumType) && discriminator !== '__kind') {\n                        encoderOptions.push(fragment`discriminator: '${discriminator}'`);\n                        decoderOptions.push(fragment`discriminator: '${discriminator}'`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    if (isScalarEnum(enumType)) {\n                        if (currentParentName === null) {\n                            throw new Error(\n                                'Scalar enums cannot be inlined and must be introduced ' +\n                                    'via a defined type. Ensure you are not inlining a ' +\n                                    'defined type that is a scalar enum through a visitor.',\n                            );\n                        }\n                        const variantNames = enumType.variants.map(({ name }) => nameApi.enumVariant(name));\n                        return typeManifest({\n                            decoder: fragment`${use('getEnumDecoder', 'solanaCodecsDataStructures')}(${currentParentName.strict}${decoderOptionsFragment})`,\n                            encoder: fragment`${use('getEnumEncoder', 'solanaCodecsDataStructures')}(${currentParentName.strict}${encoderOptionsFragment})`,\n                            isEnum: true,\n                            looseType: fragment`{ ${variantNames.join(', ')} }`,\n                            strictType: fragment`{ ${variantNames.join(', ')} }`,\n                        });\n                    }\n\n                    const mergedManifest = mergeTypeManifests(\n                        enumType.variants.map(variant => visit(variant, self)),\n                        {\n                            mergeCodecs: renders => renders.join(', '),\n                            mergeTypes: renders => renders.join(' | '),\n                        },\n                    );\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getDiscriminatedUnionDecoder', 'solanaCodecsDataStructures')}([${mergedManifest.decoder}]${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getDiscriminatedUnionEncoder', 'solanaCodecsDataStructures')}([${mergedManifest.encoder}]${encoderOptionsFragment})`,\n                    });\n                },\n\n                visitEnumValue(node, { self }) {\n                    const manifest = typeManifest();\n                    const enumName = nameApi.dataType(node.enum.name);\n                    const enumFunction = nameApi.discriminatedUnionFunction(node.enum.name);\n                    const importFrom = getImportFrom(node.enum);\n\n                    const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;\n                    const isScalar =\n                        enumNode && isNode(enumNode, 'enumTypeNode')\n                            ? isScalarEnum(enumNode)\n                            : !nonScalarEnums.includes(node.enum.name);\n\n                    if (!node.value && isScalar) {\n                        const variantName = nameApi.enumVariant(node.variant);\n                        return typeManifest({\n                            ...manifest,\n                            value: pipe(\n                                manifest.value,\n                                f => setFragmentContent(f, `${enumName}.${variantName}`),\n                                f => addFragmentImports(f, importFrom, [enumName]),\n                            ),\n                        });\n                    }\n\n                    const variantName = nameApi.discriminatedUnionVariant(node.variant);\n                    if (!node.value) {\n                        return typeManifest({\n                            ...manifest,\n                            value: pipe(\n                                manifest.value,\n                                f => setFragmentContent(f, `${enumFunction}('${variantName}')`),\n                                f => addFragmentImports(f, importFrom, [enumFunction]),\n                            ),\n                        });\n                    }\n\n                    return typeManifest({\n                        ...manifest,\n                        value: pipe(\n                            visit(node.value, self).value,\n                            f => mapFragmentContent(f, c => `${enumFunction}('${variantName}', ${c})`),\n                            f => addFragmentImports(f, importFrom, [enumFunction]),\n                        ),\n                    });\n                },\n\n                visitFixedSizeType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('fixDecoderSize', 'solanaCodecsCore')}(${manifest.decoder}, ${node.size})`,\n                        encoder: fragment`${use('fixEncoderSize', 'solanaCodecsCore')}(${manifest.encoder}, ${node.size})`,\n                    });\n                },\n\n                visitHiddenPrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefixes = node.prefix.map(c => visit(c, self).value);\n                    const prefixEncoders = pipe(\n                        mergeFragments(prefixes, cs => cs.map(c => `getConstantEncoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantEncoder']),\n                    );\n                    const prefixDecoders = pipe(\n                        mergeFragments(prefixes, cs => cs.map(c => `getConstantDecoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantDecoder']),\n                    );\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('getHiddenPrefixDecoder', 'solanaCodecsDataStructures')}(${manifest.decoder}, [${prefixDecoders}])`,\n                        encoder: fragment`${use('getHiddenPrefixEncoder', 'solanaCodecsDataStructures')}(${manifest.encoder}, [${prefixEncoders}])`,\n                    });\n                },\n\n                visitHiddenSuffixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const suffixes = node.suffix.map(c => visit(c, self).value);\n                    const suffixEncoders = pipe(\n                        mergeFragments(suffixes, cs => cs.map(c => `getConstantEncoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantEncoder']),\n                    );\n                    const suffixDecoders = pipe(\n                        mergeFragments(suffixes, cs => cs.map(c => `getConstantDecoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantDecoder']),\n                    );\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('getHiddenSuffixDecoder', 'solanaCodecsDataStructures')}(${manifest.decoder}, [${suffixDecoders}])`,\n                        encoder: fragment`${use('getHiddenSuffixEncoder', 'solanaCodecsDataStructures')}(${manifest.encoder}, [${suffixEncoders}])`,\n                    });\n                },\n\n                visitInstruction(instruction, { self }) {\n                    const instructionDataName = nameApi.instructionDataType(instruction.name);\n                    parentName = {\n                        loose: nameApi.dataArgsType(instructionDataName),\n                        strict: nameApi.dataType(instructionDataName),\n                    };\n                    const link = customInstructionData.get(instruction.name)?.linkNode;\n                    const struct = structTypeNodeFromInstructionArgumentNodes(instruction.arguments);\n                    const manifest = link ? visit(link, self) : visit(struct, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitMapEntryValue(node, { self }) {\n                    return mergeTypeManifests([visit(node.key, self), visit(node.value, self)], {\n                        mergeValues: renders => `[${renders.join(', ')}]`,\n                    });\n                },\n\n                visitMapType(mapType, { self }) {\n                    const key = visit(mapType.key, self);\n                    const value = visit(mapType.value, self);\n                    const mergedManifest = mergeTypeManifests([key, value], {\n                        mergeCodecs: ([k, v]) => `${k}, ${v}`,\n                        mergeTypes: ([k, v]) => `Map<${k}, ${v}>`,\n                    });\n                    const sizeManifest = getArrayLikeSizeOption(mapType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getMapDecoder', 'solanaCodecsDataStructures')}(${mergedManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getMapEncoder', 'solanaCodecsDataStructures')}(${mergedManifest.encoder}${encoderOptions})`,\n                    });\n                },\n\n                visitMapValue(node, { self }) {\n                    const entryFragments = node.entries.map(entry => visit(entry, self));\n                    return mergeTypeManifests(entryFragments, {\n                        mergeValues: renders => `new Map([${renders.join(', ')}])`,\n                    });\n                },\n\n                visitNoneValue() {\n                    return typeManifest({\n                        value: fragment`${use('none', 'solanaOptions')}()`,\n                    });\n                },\n\n                visitNumberType(numberType) {\n                    const encoderFunction = use(nameApi.encoderFunction(numberType.format), 'solanaCodecsNumbers');\n                    const decoderFunction = use(nameApi.decoderFunction(numberType.format), 'solanaCodecsNumbers');\n                    const isBigNumber = ['u64', 'u128', 'i64', 'i128'].includes(numberType.format);\n                    const endianness =\n                        numberType.endian === 'be'\n                            ? fragment`{ endian: ${use('Endian', 'solanaCodecsNumbers')}.Big }`\n                            : '';\n                    return typeManifest({\n                        decoder: fragment`${decoderFunction}(${endianness})`,\n                        encoder: fragment`${encoderFunction}(${endianness})`,\n                        looseType: fragment`${isBigNumber ? 'number | bigint' : 'number'}`,\n                        strictType: fragment`${isBigNumber ? 'bigint' : 'number'}`,\n                    });\n                },\n\n                visitNumberValue(node) {\n                    return typeManifest({ value: fragment`${JSON.stringify(node.number)}` });\n                },\n\n                visitOptionType(optionType, { self }) {\n                    const childManifest = visit(optionType.item, self);\n                    const encoderOptions: Fragment[] = [];\n                    const decoderOptions: Fragment[] = [];\n\n                    // Prefix option.\n                    const optionPrefix = resolveNestedTypeNode(optionType.prefix);\n                    if (optionPrefix.format !== 'u8' || optionPrefix.endian !== 'le') {\n                        const prefixManifest = visit(optionType.prefix, self);\n                        encoderOptions.push(fragment`prefix: ${prefixManifest.encoder}`);\n                        decoderOptions.push(fragment`prefix: ${prefixManifest.decoder}`);\n                    }\n\n                    // Fixed option.\n                    if (optionType.fixed) {\n                        encoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                        decoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsFragment})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitPostOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        return typeManifest({\n                            ...manifest,\n                            decoder: fragment`${use('padRightDecoder', 'solanaCodecsCore')}(${manifest.decoder}, ${node.offset})`,\n                            encoder: fragment`${use('padRightEncoder', 'solanaCodecsCore')}(${manifest.encoder}, ${node.offset})`,\n                        });\n                    }\n\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'preOffset':\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ postOffset }) => postOffset ${node.offset}`\n                                    : `({ postOffset }) => postOffset + ${node.offset}`;\n                        }\n                    })();\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('offsetDecoder', 'solanaCodecsCore')}(${manifest.decoder}, { postOffset: ${fn} })`,\n                        encoder: fragment`${use('offsetEncoder', 'solanaCodecsCore')}(${manifest.encoder}, { postOffset: ${fn} })`,\n                    });\n                },\n\n                visitPreOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        return typeManifest({\n                            ...manifest,\n                            decoder: fragment`${use('padLeftDecoder', 'solanaCodecsCore')}(${manifest.decoder}, ${node.offset})`,\n                            encoder: fragment`${use('padLeftEncoder', 'solanaCodecsCore')}(${manifest.encoder}, ${node.offset})`,\n                        });\n                    }\n\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                        }\n                    })();\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('offsetDecoder', 'solanaCodecsCore')}(${manifest.decoder}, { preOffset: ${fn} })`,\n                        encoder: fragment`${use('offsetEncoder', 'solanaCodecsCore')}(${manifest.encoder}, { preOffset: ${fn} })`,\n                    });\n                },\n\n                visitPublicKeyType() {\n                    return typeManifest({\n                        decoder: fragment`${use('getAddressDecoder', 'solanaAddresses')}()`,\n                        encoder: fragment`${use('getAddressEncoder', 'solanaAddresses')}()`,\n                        looseType: use('type Address', 'solanaAddresses'),\n                        strictType: use('type Address', 'solanaAddresses'),\n                    });\n                },\n\n                visitPublicKeyValue(node) {\n                    return typeManifest({\n                        value: fragment`${use('address', 'solanaAddresses')}(\"${node.publicKey}\")`,\n                    });\n                },\n\n                visitRemainderOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    const encoderOptions: string[] = ['prefix: null'];\n                    const decoderOptions: string[] = ['prefix: null'];\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsAsString})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsAsString})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitSentinelType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const sentinel = visit(node.sentinel, self).value;\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('addDecoderSentinel', 'solanaCodecsCore')}(${manifest.decoder}, ${sentinel})`,\n                        encoder: fragment`${use('addEncoderSentinel', 'solanaCodecsCore')}(${manifest.encoder}, ${sentinel})`,\n                    });\n                },\n\n                visitSetType(setType, { self }) {\n                    const childManifest = visit(setType.item, self);\n                    const sizeManifest = getArrayLikeSizeOption(setType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getSetDecoder', 'solanaCodecsDataStructures')}(${childManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getSetEncoder', 'solanaCodecsDataStructures')}(${childManifest.encoder}${encoderOptions})`,\n                        looseType: fragment`Set<${childManifest.looseType}>`,\n                        strictType: fragment`Set<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitSetValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `new Set([${renders.join(', ')}])` },\n                    );\n                },\n\n                visitSizePrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefix = visit(node.prefix, self);\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('addDecoderSizePrefix', 'solanaCodecsCore')}(${manifest.decoder}, ${prefix.decoder})`,\n                        encoder: fragment`${use('addEncoderSizePrefix', 'solanaCodecsCore')}(${manifest.encoder}, ${prefix.encoder})`,\n                    });\n                },\n\n                visitSolAmountType({ number }, { self }) {\n                    const numberManifest = visit(number, self);\n\n                    return typeManifest({\n                        ...numberManifest,\n                        decoder: fragment`${use('getLamportsDecoder', 'solanaRpcTypes')}(${numberManifest.decoder})`,\n                        encoder: fragment`${use('getLamportsEncoder', 'solanaRpcTypes')}(${numberManifest.encoder})`,\n                        looseType: use('type Lamports', 'solanaRpcTypes'),\n                        strictType: use('type Lamports', 'solanaRpcTypes'),\n                    });\n                },\n\n                visitSomeValue(node, { self }) {\n                    const innerValue = visit(node.value, self).value;\n                    return typeManifest({\n                        value: fragment`${use('some', 'solanaOptions')}(${innerValue})`,\n                    });\n                },\n\n                visitStringType(stringType) {\n                    const [encoder, decoder] = (() => {\n                        switch (stringType.encoding) {\n                            case 'base16':\n                                return ['getBase16Encoder', 'getBase16Decoder'];\n                            case 'base58':\n                                return ['getBase58Encoder', 'getBase58Decoder'];\n                            case 'base64':\n                                return ['getBase64Encoder', 'getBase64Decoder'];\n                            case 'utf8':\n                                return ['getUtf8Encoder', 'getUtf8Decoder'];\n                            default:\n                                throw new Error(`Unsupported string encoding: ${stringType.encoding as string}`);\n                        }\n                    })();\n\n                    return typeManifest({\n                        decoder: fragment`${use(decoder, 'solanaCodecsStrings')}()`,\n                        encoder: fragment`${use(encoder, 'solanaCodecsStrings')}()`,\n                        looseType: fragment`string`,\n                        strictType: fragment`string`,\n                    });\n                },\n\n                visitStringValue(node) {\n                    return typeManifest({\n                        value: fragment`${JSON.stringify(node.string)}`,\n                    });\n                },\n\n                visitStructFieldType(structFieldType, { self }) {\n                    const name = camelCase(structFieldType.name);\n                    const originalChildManifest = visit(structFieldType.type, self);\n                    let docs = getDocblockFragment(structFieldType.docs ?? [], true);\n                    docs = docs ? fragment`\\n${docs}` : docs;\n                    const childManifest = typeManifest({\n                        ...originalChildManifest,\n                        decoder: fragment`['${name}', ${originalChildManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${originalChildManifest.encoder}]`,\n                        looseType: fragment`${docs}${name}: ${originalChildManifest.looseType}; `,\n                        strictType: fragment`${docs}${name}: ${originalChildManifest.strictType}; `,\n                    });\n\n                    // No default value.\n                    if (!structFieldType.defaultValue) {\n                        return childManifest;\n                    }\n\n                    // Optional default value.\n                    if (structFieldType.defaultValueStrategy !== 'omitted') {\n                        return typeManifest({\n                            ...childManifest,\n                            looseType: fragment`${docs}${name}?: ${originalChildManifest.looseType}; `,\n                        });\n                    }\n\n                    // Omitted default value.\n                    return typeManifest({ ...childManifest, looseType: fragment`` });\n                },\n\n                visitStructFieldValue(node, { self }) {\n                    const innerValue = visit(node.value, self).value;\n                    return typeManifest({\n                        value: fragment`${node.name}: ${innerValue}`,\n                    });\n                },\n\n                visitStructType(structType, { self }) {\n                    const optionalFields = structType.fields.filter(f => !!f.defaultValue);\n\n                    const mergedManifest = pipe(\n                        mergeTypeManifests(\n                            structType.fields.map(field => visit(field, self)),\n                            {\n                                mergeCodecs: renders => `([${renders.join(', ')}])`,\n                                mergeTypes: renders => `{ ${renders.join('')} }`,\n                            },\n                        ),\n                        manifest =>\n                            typeManifest({\n                                ...manifest,\n                                decoder: fragment`${use('getStructDecoder', 'solanaCodecsDataStructures')}${manifest.decoder}`,\n                                encoder: fragment`${use('getStructEncoder', 'solanaCodecsDataStructures')}${manifest.encoder}`,\n                            }),\n                    );\n\n                    if (optionalFields.length === 0) {\n                        return mergedManifest;\n                    }\n\n                    // Check if we are inside an instruction or account to use discriminator constants when available.\n                    const parentPath = stack.getPath();\n                    const instructionNode = findLastNodeFromPath(parentPath, 'instructionNode');\n                    const accountNode = findLastNodeFromPath(parentPath, 'accountNode');\n                    const discriminatorPrefix = instructionNode ? instructionNode.name : accountNode?.name;\n                    const discriminators =\n                        (instructionNode ? instructionNode.discriminators : accountNode?.discriminators) ?? [];\n                    const fieldDiscriminators = discriminators.filter(isNodeFilter('fieldDiscriminatorNode'));\n\n                    const defaultValues = mergeFragments(\n                        optionalFields.map((f): Fragment => {\n                            const key = camelCase(f.name);\n\n                            // If the field has an associated discriminator node, use the constant value instead.\n                            if (fieldDiscriminators.some(d => d.name === f.name)) {\n                                const constantName = nameApi.constant(camelCase(`${discriminatorPrefix}_${f.name}`));\n                                return f.defaultValueStrategy === 'omitted'\n                                    ? fragment`${key}: ${constantName}`\n                                    : fragment`${key}: value.${key} ?? ${constantName}`;\n                            }\n\n                            const defaultValue = f.defaultValue as NonNullable<typeof f.defaultValue>;\n                            const value = visit(defaultValue, self).value;\n                            return f.defaultValueStrategy === 'omitted'\n                                ? fragment`${key}: ${value}`\n                                : fragment`${key}: value.${key} ?? ${value}`;\n                        }),\n                        cs => cs.join(', '),\n                    );\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        encoder: fragment`${use('transformEncoder', 'solanaCodecsCore')}(${mergedManifest.encoder}, (value) => ({ ...value, ${defaultValues} }))`,\n                    });\n                },\n\n                visitStructValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.fields.map(field => visit(field, self)),\n                        { mergeValues: renders => `{ ${renders.join(', ')} }` },\n                    );\n                },\n\n                visitTupleType(tupleType, { self }) {\n                    const items = tupleType.items.map(item => visit(item, self));\n                    const mergedManifest = mergeTypeManifests(items, {\n                        mergeCodecs: codecs => `[${codecs.join(', ')}]`,\n                        mergeTypes: types => `readonly [${types.join(', ')}]`,\n                    });\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getTupleDecoder', 'solanaCodecsDataStructures')}(${mergedManifest.decoder})`,\n                        encoder: fragment`${use('getTupleEncoder', 'solanaCodecsDataStructures')}(${mergedManifest.encoder})`,\n                    });\n                },\n\n                visitTupleValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitZeroableOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    const encoderOptions: Fragment[] = [fragment`prefix: null`];\n                    const decoderOptions: Fragment[] = [fragment`prefix: null`];\n\n                    // Zero-value option.\n                    if (node.zeroValue) {\n                        const zeroValueManifest = visit(node.zeroValue, self);\n                        encoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);\n                        decoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);\n                    } else {\n                        encoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                        decoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsFragment})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n            }),\n        visitor => recordNodeStackVisitor(visitor, stack),\n    );\n}\n\nfunction getArrayLikeSizeOption(\n    count: CountNode,\n    visitor: Visitor<TypeManifest, TypeNode['kind']>,\n): {\n    decoder: Fragment | undefined;\n    encoder: Fragment | undefined;\n} {\n    if (isNode(count, 'fixedCountNode')) {\n        return {\n            decoder: fragment`size: ${count.value}`,\n            encoder: fragment`size: ${count.value}`,\n        };\n    }\n    if (isNode(count, 'remainderCountNode')) {\n        return {\n            decoder: fragment`size: 'remainder'`,\n            encoder: fragment`size: 'remainder'`,\n        };\n    }\n    const prefix = resolveNestedTypeNode(count.prefix);\n    if (prefix.format === 'u32' && prefix.endian === 'le') {\n        return { decoder: undefined, encoder: undefined };\n    }\n    const prefixManifest = visit(count.prefix, visitor);\n    return {\n        decoder: pipe(prefixManifest.decoder, f => mapFragmentContent(f, c => `size: ${c}`)),\n        encoder: pipe(prefixManifest.encoder, f => mapFragmentContent(f, c => `size: ${c}`)),\n    };\n}\n","import {\n    camelCase,\n    CamelCaseString,\n    getAllAccounts,\n    getAllDefinedTypes,\n    getAllInstructionsWithSubs,\n    getAllPdas,\n    getAllPrograms,\n} from '@codama/nodes';\nimport { createRenderMap, mergeRenderMaps } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    getByteSizeVisitor,\n    getResolvedInstructionInputsVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport {\n    getAccountPageFragment,\n    getErrorPageFragment,\n    getIndexPageFragment,\n    getInstructionPageFragment,\n    getPdaPageFragment,\n    getProgramPageFragment,\n    getRootIndexPageFragment,\n    getSharedPageFragment,\n    getTypePageFragment,\n} from '../fragments';\nimport {\n    DEFAULT_NAME_TRANSFORMERS,\n    Fragment,\n    getDefinedTypeNodesToExtract,\n    getImportFromFactory,\n    getNameApi,\n    getPageFragment,\n    GetRenderMapOptions,\n    parseCustomDataOptions,\n    RenderScope,\n} from '../utils';\nimport { getTypeManifestVisitor } from './getTypeManifestVisitor';\n\nexport function getRenderMapVisitor(options: GetRenderMapOptions = {}) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], 'AccountData');\n    const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], 'InstructionData');\n    const renderScopeWithTypeManifestVisitor: Omit<RenderScope, 'typeManifestVisitor'> = {\n        asyncResolvers: (options.asyncResolvers ?? []).map(camelCase),\n        customAccountData,\n        customInstructionData,\n        dependencyMap: options.dependencyMap ?? {},\n        dependencyVersions: options.dependencyVersions ?? {},\n        getImportFrom: getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData),\n        linkables,\n        nameApi: getNameApi({ ...DEFAULT_NAME_TRANSFORMERS, ...options.nameTransformers }),\n        nonScalarEnums: (options.nonScalarEnums ?? []).map(camelCase),\n        renderParentInstructions: options.renderParentInstructions ?? false,\n        useGranularImports: options.useGranularImports ?? false,\n    };\n\n    const typeManifestVisitor = getTypeManifestVisitor({ ...renderScopeWithTypeManifestVisitor, stack });\n    const renderScope: RenderScope = { ...renderScopeWithTypeManifestVisitor, typeManifestVisitor };\n\n    const internalNodes = (options.internalNodes ?? []).map(camelCase);\n    const resolvedInstructionInputVisitor = getResolvedInstructionInputsVisitor();\n    const byteSizeVisitor = getByteSizeVisitor(linkables, { stack });\n    const asPage = <TFragment extends Fragment | undefined>(\n        fragment: TFragment,\n        dependencyMap: Record<string, string> = {},\n    ): TFragment => {\n        if (!fragment) return undefined as TFragment;\n        return getPageFragment(fragment, {\n            ...renderScope,\n            dependencyMap: { ...renderScope.dependencyMap, ...dependencyMap },\n        }) as TFragment;\n    };\n\n    return pipe(\n        staticVisitor(() => createRenderMap<Fragment>(), {\n            keys: ['rootNode', 'programNode', 'pdaNode', 'accountNode', 'definedTypeNode', 'instructionNode'],\n        }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node) {\n                    return createRenderMap(\n                        `accounts/${camelCase(node.name)}.ts`,\n                        asPage(\n                            getAccountPageFragment({\n                                ...renderScope,\n                                accountPath: stack.getPath('accountNode'),\n                                size: visit(node, byteSizeVisitor),\n                            }),\n                        ),\n                    );\n                },\n\n                visitDefinedType(node) {\n                    return createRenderMap(\n                        `types/${camelCase(node.name)}.ts`,\n                        asPage(getTypePageFragment({ ...renderScope, node, size: visit(node, byteSizeVisitor) }), {\n                            generatedTypes: '.',\n                        }),\n                    );\n                },\n\n                visitInstruction(node) {\n                    return createRenderMap(\n                        `instructions/${camelCase(node.name)}.ts`,\n                        asPage(\n                            getInstructionPageFragment({\n                                ...renderScope,\n                                instructionPath: stack.getPath('instructionNode'),\n                                resolvedInputs: visit(node, resolvedInstructionInputVisitor),\n                                size: visit(node, byteSizeVisitor),\n                            }),\n                        ),\n                    );\n                },\n\n                visitPda(node) {\n                    return createRenderMap(\n                        `pdas/${camelCase(node.name)}.ts`,\n                        asPage(getPdaPageFragment({ ...renderScope, pdaPath: stack.getPath('pdaNode') })),\n                    );\n                },\n\n                visitProgram(node, { self }) {\n                    const customDataDefinedType = [\n                        ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),\n                        ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData),\n                    ];\n                    const scope = { ...renderScope, programNode: node };\n\n                    return mergeRenderMaps([\n                        createRenderMap({\n                            [`programs/${camelCase(node.name)}.ts`]: asPage(getProgramPageFragment(scope)),\n                            [`errors/${camelCase(node.name)}.ts`]:\n                                node.errors.length > 0 ? asPage(getErrorPageFragment(scope)) : undefined,\n                        }),\n                        ...node.pdas.map(p => visit(p, self)),\n                        ...node.accounts.map(a => visit(a, self)),\n                        ...node.definedTypes.map(t => visit(t, self)),\n                        ...customDataDefinedType.map(t => visit(t, self)),\n                        ...getAllInstructionsWithSubs(node, { leavesOnly: !renderScope.renderParentInstructions }).map(\n                            i => visit(i, self),\n                        ),\n                    ]);\n                },\n\n                visitRoot(node, { self }) {\n                    const isNotInternal = (n: { name: CamelCaseString }) => !internalNodes.includes(n.name);\n                    const programsToExport = getAllPrograms(node).filter(isNotInternal);\n                    const programsWithErrorsToExport = programsToExport.filter(p => p.errors.length > 0);\n                    const pdasToExport = getAllPdas(node);\n                    const accountsToExport = getAllAccounts(node).filter(isNotInternal);\n                    const instructionsToExport = getAllInstructionsWithSubs(node, {\n                        leavesOnly: !renderScope.renderParentInstructions,\n                    }).filter(isNotInternal);\n                    const definedTypesToExport = getAllDefinedTypes(node).filter(isNotInternal);\n                    const hasAnythingToExport =\n                        programsToExport.length > 0 ||\n                        accountsToExport.length > 0 ||\n                        instructionsToExport.length > 0 ||\n                        definedTypesToExport.length > 0;\n\n                    const scope = {\n                        ...renderScope,\n                        accountsToExport,\n                        definedTypesToExport,\n                        instructionsToExport,\n                        pdasToExport,\n                        programsToExport,\n                    };\n\n                    return mergeRenderMaps([\n                        createRenderMap({\n                            ['accounts/index.ts']: asPage(getIndexPageFragment(accountsToExport)),\n                            ['errors/index.ts']: asPage(getIndexPageFragment(programsWithErrorsToExport)),\n                            ['index.ts']: asPage(getRootIndexPageFragment(scope)),\n                            ['instructions/index.ts']: asPage(getIndexPageFragment(instructionsToExport)),\n                            ['pdas/index.ts']: asPage(getIndexPageFragment(pdasToExport)),\n                            ['programs/index.ts']: asPage(getIndexPageFragment(programsToExport)),\n                            ['shared/index.ts']: hasAnythingToExport ? asPage(getSharedPageFragment()) : undefined,\n                            ['types/index.ts']: asPage(getIndexPageFragment(definedTypesToExport)),\n                        }),\n                        ...getAllPrograms(node).map(p => visit(p, self)),\n                    ]);\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import { deleteDirectory, mapRenderMapContentAsync, writeRenderMap } from '@codama/renderers-core';\nimport { rootNodeVisitor, visit } from '@codama/visitors-core';\n\nimport { getCodeFormatter, RenderOptions, syncPackageJson } from '../utils';\nimport { getRenderMapVisitor } from './getRenderMapVisitor';\n\nexport function renderVisitor(path: string, options: RenderOptions = {}) {\n    return rootNodeVisitor(async root => {\n        // Delete existing generated folder.\n        if (options.deleteFolderBeforeRendering ?? true) {\n            deleteDirectory(path);\n        }\n\n        // Render the new files.\n        let renderMap = visit(root, getRenderMapVisitor(options));\n\n        // Format the code, if requested.\n        const formatCode = await getCodeFormatter(options);\n        renderMap = await mapRenderMapContentAsync(renderMap, formatCode);\n\n        // Create or update package.json dependencies, if requested.\n        await syncPackageJson(renderMap, formatCode, options);\n\n        // Write the rendered files to the output directory.\n        writeRenderMap(renderMap, path);\n    });\n}\n"]}