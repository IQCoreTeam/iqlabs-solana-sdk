{"version":3,"sources":["../src/defaultVisitor.ts","../src/utils.ts","../src/discriminators.ts","../src/v00/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v00/typeNodes/StructFieldTypeNode.ts","../src/v00/typeNodes/StructTypeNode.ts","../src/v00/typeNodes/EnumStructVariantTypeNode.ts","../src/v00/typeNodes/TupleTypeNode.ts","../src/v00/typeNodes/EnumTupleVariantTypeNode.ts","../src/v00/typeNodes/EnumTypeNode.ts","../src/v00/typeNodes/MapTypeNode.ts","../src/v00/typeNodes/OptionTypeNode.ts","../src/v00/typeNodes/SetTypeNode.ts","../src/v00/typeNodes/TypeNode.ts","../src/v00/typeNodes/ArrayTypeNode.ts","../src/v00/AccountNode.ts","../src/v00/DefinedTypeNode.ts","../src/v00/ErrorNode.ts","../src/v00/InstructionAccountNode.ts","../src/v00/InstructionArgumentNode.ts","../src/v00/InstructionNode.ts","../src/v00/PdaNode.ts","../src/v00/ProgramNode.ts","../src/v00/RootNode.ts","../src/v01/unwrapGenerics.ts","../src/v01/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v01/typeNodes/StructFieldTypeNode.ts","../src/v01/typeNodes/StructTypeNode.ts","../src/v01/typeNodes/EnumStructVariantTypeNode.ts","../src/v01/typeNodes/TupleTypeNode.ts","../src/v01/typeNodes/EnumTupleVariantTypeNode.ts","../src/v01/typeNodes/EnumTypeNode.ts","../src/v01/typeNodes/OptionTypeNode.ts","../src/v01/typeNodes/TypeNode.ts","../src/v01/typeNodes/ArrayTypeNode.ts","../src/v01/AccountNode.ts","../src/v01/DefinedTypeNode.ts","../src/v01/ErrorNode.ts","../src/v01/PdaSeedNode.ts","../src/v01/InstructionAccountNode.ts","../src/v01/InstructionArgumentNode.ts","../src/v01/InstructionNode.ts","../src/v01/ProgramNode.ts","../src/v01/RootNode.ts","../src/index.ts"],"names":["numberTypeNode","remainderCountNode","fixedCountNode","prefixedCountNode","item","assertIsNode","structFieldTypeNode","bytesTypeNode","structTypeNode","camelCase","instructionArgumentNode","fieldDiscriminatorNode","fixedSizeTypeNode","bytesValueNode","stringTypeNode","numberValueNode","programNode","CodamaError","enumEmptyVariantTypeNode","CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE","enumStructVariantTypeNode","tupleTypeNode","enumTupleVariantTypeNode","isStructVariant","enumTypeNode","optionTypeNode","booleanTypeNode","publicKeyTypeNode","sizePrefixTypeNode","isArrayOfSize","definedTypeLinkNode","isStructField","arrayTypeNode","name","accountNode","definedTypeNode","errorNode","variablePdaSeedNode","hasDuplicateAccountNames","isNode","pdaNode","instructionAccountNode","instructionNode","rootNode","visit"],"mappings":"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","file":"index.react-native.mjs","sourcesContent":["import { assertIsNode, Node, RootNode } from '@codama/nodes';\nimport {\n    deduplicateIdenticalDefinedTypesVisitor,\n    flattenInstructionDataArgumentsVisitor,\n    getCommonInstructionAccountDefaultRules,\n    rootNodeVisitor,\n    setFixedAccountSizesVisitor,\n    setInstructionAccountDefaultValuesVisitor,\n    transformU8ArraysToBytesVisitor,\n    unwrapInstructionArgsDefinedTypesVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors';\n\nexport function defaultVisitor() {\n    return rootNodeVisitor(currentRoot => {\n        let root: RootNode = currentRoot;\n        const updateRoot = (visitor: Visitor<Node | null, 'rootNode'>) => {\n            const newRoot = visit(root, visitor);\n            assertIsNode(newRoot, 'rootNode');\n            root = newRoot;\n        };\n\n        // Defined types.\n        updateRoot(deduplicateIdenticalDefinedTypesVisitor());\n\n        // Accounts.\n        updateRoot(setFixedAccountSizesVisitor());\n\n        // Instructions.\n        updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));\n        updateRoot(unwrapInstructionArgsDefinedTypesVisitor());\n        updateRoot(flattenInstructionDataArgumentsVisitor());\n\n        // Extras.\n        updateRoot(transformU8ArraysToBytesVisitor());\n\n        return root;\n    });\n}\n","export function hex(bytes: number[] | Uint8Array): string {\n    return (bytes as number[]).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import { BytesValueNode, bytesValueNode, pascalCase, snakeCase } from '@codama/nodes';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { getUtf8Codec } from '@solana/codecs';\n\nimport { hex } from './utils';\n\nexport const getAnchorDiscriminatorV01 = (discriminator: number[]): BytesValueNode => {\n    return bytesValueNode('base16', hex(new Uint8Array(discriminator)));\n};\n\nexport const getAnchorInstructionDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const bytes = getUtf8Codec().encode(`global:${snakeCase(idlName)}`);\n    const hash = sha256(bytes as Uint8Array).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n\nexport const getAnchorAccountDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const bytes = getUtf8Codec().encode(`account:${pascalCase(idlName)}`);\n    const hash = sha256(bytes as Uint8Array).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV00(idl: IdlV00EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV00Field } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV00(idl: IdlV00Field): StructFieldTypeNode {\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV00 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV00(idl: IdlV00TypeDefTyStruct): StructTypeNode {\n    return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV00({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeTuple } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV00(idl: IdlV00TypeTuple): TupleTypeNode {\n    return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsTuple, IdlV00EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode, numberTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumFieldsTuple, IdlV00EnumVariant, IdlV00TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV00 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV00 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV00 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV00(\n    idl: IdlV00TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV00(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV00(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV00(variant as IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple });\n    });\n    return enumTypeNode(variants, {\n        size: idl.size ? numberTypeNode(idl.size) : undefined,\n    });\n}\n\nfunction isStructVariant(variant: IdlV00EnumVariant): variant is IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import {\n    CountNode,\n    fixedCountNode,\n    MapTypeNode,\n    mapTypeNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeMap } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function mapTypeNodeFromAnchorV00(idl: IdlV00TypeMap): MapTypeNode {\n    const [key, value] = 'hashMap' in idl ? idl.hashMap : idl.bTreeMap;\n    let size: CountNode | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeOption } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV00(idl: IdlV00TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const defaultPrefix = numberTypeNode('option' in idl ? 'u8' : 'u32');\n    const defaultFixed = !('option' in idl);\n    return optionTypeNode(typeNodeFromAnchorV00(item), {\n        fixed: idl.fixed !== undefined ? idl.fixed : defaultFixed,\n        prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix,\n    });\n}\n","import {\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n    SetTypeNode,\n    setTypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeSet } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function setTypeNodeFromAnchorV00(idl: IdlV00TypeSet): SetTypeNode {\n    const child = 'hashSet' in idl ? idl.hashSet : idl.bTreeSet;\n    let size: SetTypeNode['count'] | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return setTypeNode(typeNodeFromAnchorV00(child), size);\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00Type, IdlV00TypeDefTy, IdlV00TypeMap, IdlV00TypeSet } from '../idl';\nimport { arrayTypeNodeFromAnchorV00 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV00 } from './EnumTypeNode';\nimport { mapTypeNodeFromAnchorV00 } from './MapTypeNode';\nimport { optionTypeNodeFromAnchorV00 } from './OptionTypeNode';\nimport { setTypeNodeFromAnchorV00 } from './SetTypeNode';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nconst IDL_V00_TYPE_LEAVES = [\n    'string',\n    'publicKey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV00 = (idlType: IdlV00Type | IdlV00TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V00_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'publicKey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'string') {\n        return definedTypeLinkNode(idlType.defined);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV00(idlType.value);\n    }\n\n    // Map.\n    if (\n        ('hashMap' in idlType && isArrayOfSize(idlType.hashMap, 2)) ||\n        ('bTreeMap' in idlType && isArrayOfSize(idlType.bTreeMap, 2))\n    ) {\n        return mapTypeNodeFromAnchorV00(idlType as IdlV00TypeMap);\n    }\n\n    // Option.\n    if ('option' in idlType || 'coption' in idlType) {\n        return optionTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Set.\n    if ('hashSet' in idlType || 'bTreeSet' in idlType) {\n        return setTypeNodeFromAnchorV00(idlType as IdlV00TypeSet);\n    }\n\n    // Struct.\n    if ('kind' in idlType && 'fields' in idlType && idlType.kind === 'struct') {\n        return structTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Tuple.\n    if ('tuple' in idlType && Array.isArray(idlType.tuple)) {\n        return tupleTypeNodeFromAnchorV00(idlType);\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeArray, IdlV00TypeVec } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV00(idl: IdlV00TypeArray | IdlV00TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV00(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1]));\n    }\n    const item = typeNodeFromAnchorV00(idl.vec);\n    if (idl.size === 'remainder') return arrayTypeNode(item, remainderCountNode());\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? 'u32')));\n}\n","import {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    pdaLinkNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorAccountDiscriminatorV00 } from '../discriminators';\nimport { IdlV00AccountDef } from './idl';\nimport { structTypeNodeFromAnchorV00 } from './typeNodes';\n\nexport function accountNodeFromAnchorV00(\n    idl: IdlV00AccountDef,\n    origin?: 'anchor' | 'shank',\n): AccountNode<StructTypeNode> {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    const idlStruct = idl.type ?? { fields: [], kind: 'struct' };\n    let data = structTypeNodeFromAnchorV00(idlStruct);\n    assertIsNode(data, 'structTypeNode');\n    const hasSeeds = (idl.seeds ?? []).length > 0;\n\n    // Account discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (origin === 'anchor') {\n        const discriminator = structFieldTypeNode({\n            defaultValue: getAnchorAccountDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        data = structTypeNode([discriminator, ...data.fields]);\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return accountNode({\n        data,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        pda: hasSeeds ? pdaLinkNode(name) : undefined,\n        size: idl.size,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV00(idl: Partial<IdlV00TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV00(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV00ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV00(idl: Partial<IdlV00ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],\n        message: msg,\n        name,\n    });\n}\n","import { camelCase, InstructionAccountNode, instructionAccountNode } from '@codama/nodes';\n\nimport { IdlV00Account, IdlV00AccountItem } from './idl';\n\nfunction hasDuplicateAccountNames(idl: IdlV00AccountItem[]): boolean {\n    const seenNames = new Set<string>();\n\n    function checkDuplicates(items: IdlV00AccountItem[]): boolean {\n        for (const item of items) {\n            if ('accounts' in item) {\n                if (checkDuplicates(item.accounts)) {\n                    return true;\n                }\n            } else {\n                const name = camelCase(item.name ?? '');\n                if (seenNames.has(name)) {\n                    return true;\n                }\n                seenNames.add(name);\n            }\n        }\n        return false;\n    }\n\n    return checkDuplicates(idl);\n}\n\nexport function instructionAccountNodesFromAnchorV00(\n    idl: IdlV00AccountItem[],\n    prefix?: string,\n): InstructionAccountNode[] {\n    const shouldPrefix = prefix !== undefined || hasDuplicateAccountNames(idl);\n\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV00(\n                  account.accounts,\n                  shouldPrefix ? (prefix ? `${prefix}_${account.name}` : account.name) : undefined,\n              )\n            : [instructionAccountNodeFromAnchorV00(account, shouldPrefix ? prefix : undefined)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV00(idl: IdlV00Account, prefix?: string): InstructionAccountNode {\n    const isOptional = idl.optional ?? idl.isOptional ?? false;\n    const desc = idl.desc ? [idl.desc] : undefined;\n    return instructionAccountNode({\n        docs: idl.docs ?? desc ?? [],\n        isOptional,\n        isSigner: idl.isOptionalSigner ? 'either' : (idl.isSigner ?? false),\n        isWritable: idl.isMut ?? false,\n        name: prefix ? `${prefix}_${idl.name ?? ''}` : (idl.name ?? ''),\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV00Field } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV00(idl: IdlV00Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import {\n    bytesTypeNode,\n    bytesValueNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    numberValueNode,\n} from '@codama/nodes';\n\nimport { getAnchorInstructionDiscriminatorV00 } from '../discriminators';\nimport { IdlV00Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV00 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV00 } from './InstructionArgumentNode';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionNodeFromAnchorV00(\n    idl: IdlV00Instruction,\n    ixIndex: number,\n    origin?: 'anchor' | 'shank',\n): InstructionNode {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);\n\n    // Instruction discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (idl.discriminant) {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: numberValueNode(idl.discriminant.value),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: typeNodeFromAnchorV00(idl.discriminant.type),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'anchor') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: getAnchorInstructionDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'shank') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: bytesValueNode('base16', ixIndex.toString(16)),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 1),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? 'omitted' : 'programId',\n    });\n}\n","import {\n    booleanValueNode,\n    bytesTypeNode,\n    camelCase,\n    constantPdaSeedNode,\n    constantPdaSeedNodeFromProgramId,\n    numberValueNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    stringTypeNode,\n    stringValueNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\n\nimport { IdlV00PdaDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function pdaNodeFromAnchorV00(idl: IdlV00PdaDef): PdaNode {\n    const name = camelCase(idl.name ?? '');\n    const seeds = (idl.seeds ?? []).map((seed): PdaSeedNode => {\n        if (seed.kind === 'constant') {\n            const type = (() => {\n                if (seed.type === 'string') return stringTypeNode('utf8');\n                if (seed.type === 'bytes') return bytesTypeNode();\n                return typeNodeFromAnchorV00(seed.type);\n            })();\n            const value = (() => {\n                if (typeof seed.value === 'string') return stringValueNode(seed.value);\n                if (typeof seed.value === 'number') return numberValueNode(seed.value);\n                return booleanValueNode(seed.value);\n            })();\n            return constantPdaSeedNode(type, value);\n        }\n        if (seed.kind === 'variable') {\n            return variablePdaSeedNode(\n                seed.name,\n                typeNodeFromAnchorV00(seed.type),\n                seed.description ? [seed.description] : [],\n            );\n        }\n        return constantPdaSeedNodeFromProgramId();\n    });\n    return pdaNode({ name, seeds });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV00 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV00 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV00 } from './ErrorNode';\nimport { IdlV00 } from './idl';\nimport { instructionNodeFromAnchorV00 } from './InstructionNode';\nimport { pdaNodeFromAnchorV00 } from './PdaNode';\n\nexport function programNodeFromAnchorV00(idl: IdlV00): ProgramNode {\n    const origin = (idl?.metadata as { origin?: 'anchor' | 'shank' })?.origin ?? 'anchor';\n    const pdas = (idl.accounts ?? []).filter(account => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);\n    const accounts = (idl.accounts ?? []).map(a => accountNodeFromAnchorV00(a, origin));\n    const instructions = (idl.instructions ?? []).map((instruction, index) =>\n        instructionNodeFromAnchorV00(instruction, index, origin),\n    );\n    return programNode({\n        accounts,\n        definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),\n        errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),\n        instructions,\n        name: idl?.name ?? '',\n        origin,\n        pdas,\n        publicKey: (idl?.metadata as { address?: string })?.address ?? '',\n        version: idl.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV00 } from './idl';\nimport { programNodeFromAnchorV00 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV00(program: IdlV00, additionalPrograms: IdlV00[] = []): RootNode {\n    const programNode = programNodeFromAnchorV00(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport { TypeNode } from '@codama/nodes';\n\nimport {\n    IdlV01GenericArgConst,\n    IdlV01GenericArgType,\n    IdlV01TypeDef,\n    IdlV01TypeDefGenericConst,\n    IdlV01TypeDefGenericType,\n    IdlV01TypeDefined,\n} from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport type GenericsV01 = {\n    constArgs: Record<string, IdlV01GenericArgConst & IdlV01TypeDefGenericConst>;\n    typeArgs: Record<string, IdlV01GenericArgType & IdlV01TypeDefGenericType>;\n    types: Record<string, IdlV01TypeDef & Required<Pick<IdlV01TypeDef, 'generics'>>>;\n};\n\nexport function extractGenerics(types: IdlV01TypeDef[]): [IdlV01TypeDef[], GenericsV01] {\n    const [nonGenericTypes, genericTypes] = types.reduce(\n        (acc, type) => {\n            acc['generics' in type ? 1 : 0].push(type);\n            return acc;\n        },\n        [[], []] as [IdlV01TypeDef[], IdlV01TypeDef[]],\n    );\n\n    const generics = {\n        constArgs: {},\n        typeArgs: {},\n        types: Object.fromEntries(genericTypes.map(type => [type.name, type])),\n    } as GenericsV01;\n\n    return [nonGenericTypes, generics];\n}\n\nexport function unwrapGenericTypeFromAnchorV01(type: IdlV01TypeDefined, generics: GenericsV01): TypeNode {\n    const genericType = generics.types[type.defined.name];\n    if (!genericType) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, { name: type.defined.name });\n    }\n\n    const constArgs: GenericsV01['constArgs'] = {};\n    const typeArgs: GenericsV01['typeArgs'] = {};\n\n    const genericDefinitions = genericType.generics ?? [];\n    const genericArgs = type.defined.generics ?? [];\n    genericDefinitions.forEach((genericDefinition, index) => {\n        const genericArg = genericArgs[index];\n        if (genericDefinition.kind === 'const') {\n            constArgs[genericDefinition.name] = genericArg as IdlV01GenericArgConst & IdlV01TypeDefGenericConst;\n        } else {\n            typeArgs[genericDefinition.name] = genericArg as IdlV01GenericArgType & IdlV01TypeDefGenericType;\n        }\n    });\n\n    return typeNodeFromAnchorV01(genericType.type, {\n        ...generics,\n        constArgs: { ...generics.constArgs, ...constArgs },\n        typeArgs: { ...generics.typeArgs, ...typeArgs },\n    });\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV01EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV01(idl: IdlV01EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport type { IdlV01Field, IdlV01Type } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV01(\n    idl: IdlV01Field | IdlV01Type,\n    generics: GenericsV01,\n): StructFieldTypeNode {\n    if (!isStructField(idl)) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idl),\n        });\n    }\n\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type, generics),\n    });\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFields, IdlV01TypeDefTyStruct } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { structFieldTypeNodeFromAnchorV01 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV01(idl: IdlV01TypeDefTyStruct, generics: GenericsV01): StructTypeNode {\n    const fields: IdlV01DefinedFields = idl.fields ?? [];\n\n    return structTypeNode(fields.map(field => structFieldTypeNodeFromAnchorV01(field, generics)));\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsNamed, IdlV01EnumVariant } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed },\n    generics: GenericsV01,\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV01({ fields: idl.fields, kind: 'struct' }, generics),\n    );\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsTuple } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV01(idl: IdlV01DefinedFieldsTuple, generics: GenericsV01): TupleTypeNode {\n    return tupleTypeNode(idl.map(type => typeNodeFromAnchorV01(type, generics)));\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport type { IdlV01DefinedFieldsTuple, IdlV01EnumVariant } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n    generics: GenericsV01,\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV01(idl.fields, generics));\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode } from '@codama/nodes';\n\nimport type {\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01EnumVariant,\n    IdlV01TypeDefTyEnum,\n} from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { enumEmptyVariantTypeNodeFromAnchorV01 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV01 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV01 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV01(\n    idl: IdlV01TypeDefTyEnum,\n    generics: GenericsV01,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV01(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV01(variant, generics);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV01(\n            variant as IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n            generics,\n        );\n    });\n    return enumTypeNode(variants);\n}\n\nfunction isStructVariant(\n    variant: IdlV01EnumVariant,\n): variant is IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport type { IdlV01TypeCOption, IdlV01TypeOption } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV01(\n    idl: IdlV01TypeCOption | IdlV01TypeOption,\n    generics: GenericsV01,\n): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const hasOptionField = 'option' in idl;\n\n    const prefix = numberTypeNode(hasOptionField ? 'u8' : 'u32');\n    const fixed = !hasOptionField;\n\n    return optionTypeNode(typeNodeFromAnchorV01(item, generics), {\n        fixed,\n        prefix,\n    });\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport type {\n    IdlV01DefinedFields,\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01Field,\n    IdlV01Type,\n    IdlV01TypeDefTy,\n} from '../idl';\nimport { type GenericsV01, unwrapGenericTypeFromAnchorV01 } from '../unwrapGenerics';\nimport { arrayTypeNodeFromAnchorV01 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV01 } from './EnumTypeNode';\nimport { optionTypeNodeFromAnchorV01 } from './OptionTypeNode';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nconst IDL_V01_TYPE_LEAVES = [\n    'string',\n    'pubkey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV01 = (idlType: IdlV01Type | IdlV01TypeDefTy, generics: GenericsV01): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V01_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'pubkey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'object') {\n        return 'generics' in idlType.defined\n            ? unwrapGenericTypeFromAnchorV01(idlType, generics)\n            : definedTypeLinkNode(idlType.defined.name);\n    }\n\n    // Generic reference.\n    if ('generic' in idlType) {\n        return typeNodeFromAnchorV01(generics.typeArgs[idlType.generic].type, generics);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV01(idlType.value, generics);\n    }\n\n    // Option.\n    if ('option' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    if ('coption' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType, generics);\n    }\n\n    // Struct and Tuple.\n    if ('kind' in idlType && idlType.kind === 'struct') {\n        const fields = idlType.fields ?? [];\n        if (isStructFieldArray(fields)) {\n            return structTypeNodeFromAnchorV01(idlType, generics);\n        }\n        if (isTupleFieldArray(fields)) {\n            return tupleTypeNodeFromAnchorV01(fields, generics);\n        }\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n\nfunction isStructFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsNamed {\n    return field.every(isStructField);\n}\n\nfunction isTupleFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsTuple {\n    return field.every(f => !isStructField(f));\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { ArrayTypeNode, arrayTypeNode, fixedCountNode, numberTypeNode, prefixedCountNode } from '@codama/nodes';\n\nimport type { IdlV01TypeArray, IdlV01TypeVec } from '../idl';\nimport type { GenericsV01 } from '../unwrapGenerics';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV01(idl: IdlV01TypeArray | IdlV01TypeVec, generics: GenericsV01): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV01(idl.array[0], generics);\n        const size =\n            typeof idl.array[1] === 'number' ? idl.array[1] : parseInt(generics.constArgs[idl.array[1].generic].value);\n        return arrayTypeNode(item, fixedCountNode(size));\n    }\n\n    const item = typeNodeFromAnchorV01(idl.vec, generics);\n\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode('u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from './../discriminators';\nimport type { IdlV01Account, IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function accountNodeFromAnchorV01(\n    idl: IdlV01Account,\n    types: IdlV01TypeDef[],\n    generics: GenericsV01,\n): AccountNode {\n    const name = camelCase(idl.name);\n    const type = types.find(({ name }) => name === idl.name);\n\n    if (!type) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });\n    }\n\n    const data = typeNodeFromAnchorV01(type.type, generics);\n    assertIsNode(data, 'structTypeNode');\n\n    const discriminator = structFieldTypeNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n\n    return accountNode({\n        data: structTypeNode([discriminator, ...data.fields]),\n        discriminators: [fieldDiscriminatorNode('discriminator')],\n        name,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport type { IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function definedTypeNodeFromAnchorV01(idl: Partial<IdlV01TypeDef>, generics: GenericsV01): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV01(idlType, generics);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV01ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV01(idl: Partial<IdlV01ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: `${name}: ${msg}`,\n        message: msg,\n        name,\n    });\n}\n","import {\n    CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    accountValueNode,\n    argumentValueNode,\n    camelCase,\n    constantPdaSeedNodeFromBytes,\n    InstructionArgumentNode,\n    isNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    publicKeyTypeNode,\n    stringTypeNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\nimport { getBase58Codec } from '@solana/codecs';\n\nimport { IdlV01Seed } from './idl';\n\nexport function pdaSeedNodeFromAnchorV01(\n    seed: IdlV01Seed,\n    instructionArguments: InstructionArgumentNode[],\n    prefix?: string,\n): Readonly<{ definition: PdaSeedNode; value?: PdaSeedValueNode }> {\n    const kind = seed.kind;\n\n    switch (kind) {\n        case 'const':\n            return {\n                definition: constantPdaSeedNodeFromBytes('base58', getBase58Codec().decode(new Uint8Array(seed.value))),\n            };\n        case 'account': {\n            // Ignore nested paths.\n            const [accountName] = seed.path.split('.');\n            const prefixedAccountName = prefix ? `${prefix}_${accountName}` : accountName;\n            return {\n                definition: variablePdaSeedNode(prefixedAccountName, publicKeyTypeNode()),\n                value: pdaSeedValueNode(prefixedAccountName, accountValueNode(prefixedAccountName)),\n            };\n        }\n        case 'arg': {\n            // Ignore nested paths.\n            const [originalArgumentName] = seed.path.split('.');\n            const argumentName = camelCase(originalArgumentName);\n            const argumentNode = instructionArguments.find(({ name }) => name === argumentName);\n            if (!argumentNode) {\n                throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: originalArgumentName });\n            }\n\n            // Anchor uses unprefixed strings for PDA seeds even though the\n            // argument itself uses a Borsh size-prefixed string. Thus, we\n            // must recognize this case and convert the type accordingly.\n            const isBorshString =\n                isNode(argumentNode.type, 'sizePrefixTypeNode') &&\n                isNode(argumentNode.type.type, 'stringTypeNode') &&\n                argumentNode.type.type.encoding === 'utf8' &&\n                isNode(argumentNode.type.prefix, 'numberTypeNode') &&\n                argumentNode.type.prefix.format === 'u32';\n            const argumentType = isBorshString ? stringTypeNode('utf8') : argumentNode.type;\n\n            return {\n                definition: variablePdaSeedNode(argumentNode.name, argumentType),\n                value: pdaSeedValueNode(argumentNode.name, argumentValueNode(argumentNode.name)),\n            };\n        }\n        default:\n            throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });\n    }\n}\n","import {\n    AccountValueNode,\n    ArgumentValueNode,\n    camelCase,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionArgumentNode,\n    isNode,\n    pdaNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    PdaValueNode,\n    pdaValueNode,\n    PublicKeyValueNode,\n    publicKeyValueNode,\n} from '@codama/nodes';\n\nimport { IdlV01InstructionAccount, IdlV01InstructionAccountItem, IdlV01Seed } from './idl';\nimport { pdaSeedNodeFromAnchorV01 } from './PdaSeedNode';\n\nfunction hasDuplicateAccountNames(idl: IdlV01InstructionAccountItem[]): boolean {\n    const seenNames = new Set<string>();\n\n    function checkDuplicates(items: IdlV01InstructionAccountItem[]): boolean {\n        for (const item of items) {\n            if ('accounts' in item) {\n                if (checkDuplicates(item.accounts)) {\n                    return true;\n                }\n            } else {\n                const name = camelCase(item.name ?? '');\n                if (seenNames.has(name)) {\n                    return true;\n                }\n                seenNames.add(name);\n            }\n        }\n        return false;\n    }\n\n    return checkDuplicates(idl);\n}\n\nexport function instructionAccountNodesFromAnchorV01(\n    idl: IdlV01InstructionAccountItem[],\n    instructionArguments: InstructionArgumentNode[],\n    prefix?: string,\n): InstructionAccountNode[] {\n    const shouldPrefix = prefix !== undefined || hasDuplicateAccountNames(idl);\n\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV01(\n                  account.accounts,\n                  instructionArguments,\n                  shouldPrefix ? (prefix ? `${prefix}_${account.name}` : account.name) : undefined,\n              )\n            : [instructionAccountNodeFromAnchorV01(account, instructionArguments, shouldPrefix ? prefix : undefined)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV01(\n    idl: IdlV01InstructionAccount,\n    instructionArguments: InstructionArgumentNode[],\n    prefix?: string,\n): InstructionAccountNode {\n    const isOptional = idl.optional ?? false;\n    const docs = idl.docs ?? [];\n    const isSigner = idl.signer ?? false;\n    const isWritable = idl.writable ?? false;\n    const name = prefix ? `${prefix}_${idl.name ?? ''}` : (idl.name ?? '');\n    let defaultValue: PdaValueNode | PublicKeyValueNode | undefined;\n\n    if (idl.address) {\n        defaultValue = publicKeyValueNode(idl.address, name);\n    } else if (idl.pda) {\n        // TODO: Handle seeds with nested paths.\n        // Currently, we gracefully ignore PDA default values if we encounter seeds with nested paths.\n        const seedsWithNestedPaths = idl.pda.seeds.some(seed => 'path' in seed && seed.path.includes('.'));\n        if (!seedsWithNestedPaths) {\n            const [seedDefinitions, seedValues] = idl.pda.seeds.reduce(\n                ([seeds, lookups], seed: IdlV01Seed) => {\n                    const { definition, value } = pdaSeedNodeFromAnchorV01(seed, instructionArguments, prefix);\n                    return [[...seeds, definition], value ? [...lookups, value] : lookups];\n                },\n                <[PdaSeedNode[], PdaSeedValueNode[]]>[[], []],\n            );\n\n            let programId: string | undefined;\n            let programIdValue: AccountValueNode | ArgumentValueNode | undefined;\n            if (idl.pda.program !== undefined) {\n                const { definition, value } = pdaSeedNodeFromAnchorV01(idl.pda.program, instructionArguments, prefix);\n                if (\n                    isNode(definition, 'constantPdaSeedNode') &&\n                    isNode(definition.value, 'bytesValueNode') &&\n                    definition.value.encoding === 'base58'\n                ) {\n                    programId = definition.value.data;\n                } else if (value && isNode(value.value, ['accountValueNode', 'argumentValueNode'])) {\n                    programIdValue = value.value;\n                }\n            }\n\n            defaultValue = pdaValueNode(\n                pdaNode({ name, programId, seeds: seedDefinitions }),\n                seedValues,\n                programIdValue,\n            );\n        }\n    }\n\n    return instructionAccountNode({\n        defaultValue,\n        docs,\n        isOptional,\n        isSigner,\n        isWritable,\n        name,\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport type { IdlV01Field } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function instructionArgumentNodeFromAnchorV01(idl: IdlV01Field, generics: GenericsV01): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type, generics),\n    });\n}\n","import {\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from '../discriminators';\nimport type { IdlV01Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV01 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV01 } from './InstructionArgumentNode';\nimport type { GenericsV01 } from './unwrapGenerics';\n\nexport function instructionNodeFromAnchorV01(idl: IdlV01Instruction, generics: GenericsV01): InstructionNode {\n    const name = idl.name;\n    let dataArguments = idl.args.map(arg => instructionArgumentNodeFromAnchorV01(arg, generics));\n\n    const discriminatorField = instructionArgumentNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n    dataArguments = [discriminatorField, ...dataArguments];\n    const discriminators = [fieldDiscriminatorNode('discriminator')];\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV01(idl.accounts ?? [], dataArguments),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name: camelCase(name),\n        optionalAccountStrategy: 'programId',\n    });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV01 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV01 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV01 } from './ErrorNode';\nimport { IdlV01 } from './idl';\nimport { instructionNodeFromAnchorV01 } from './InstructionNode';\nimport { extractGenerics } from './unwrapGenerics';\n\nexport function programNodeFromAnchorV01(idl: IdlV01): ProgramNode {\n    const [types, generics] = extractGenerics(idl.types ?? []);\n    const accounts = idl.accounts ?? [];\n    const instructions = idl.instructions ?? [];\n    const errors = idl.errors ?? [];\n\n    const filteredTypes = types.filter(type => !accounts.some(account => account.name === type.name));\n    const definedTypes = filteredTypes.map(type => definedTypeNodeFromAnchorV01(type, generics));\n    const accountNodes = accounts.map(account => accountNodeFromAnchorV01(account, types, generics));\n\n    return programNode({\n        accounts: accountNodes,\n        definedTypes,\n        errors: errors.map(errorNodeFromAnchorV01),\n        instructions: instructions.map(instruction => instructionNodeFromAnchorV01(instruction, generics)),\n        name: idl.metadata.name,\n        origin: 'anchor',\n        publicKey: idl.address,\n        version: idl.metadata.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV01 } from './idl';\nimport { programNodeFromAnchorV01 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV01(program: IdlV01, additionalPrograms: IdlV01[] = []): RootNode {\n    const programNode = programNodeFromAnchorV01(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { RootNode } from '@codama/nodes';\nimport { visit } from '@codama/visitors';\n\nimport { defaultVisitor } from './defaultVisitor';\nimport { IdlV00, rootNodeFromAnchorV00 } from './v00';\nimport { IdlV01, rootNodeFromAnchorV01 } from './v01';\n\nexport * from './defaultVisitor';\nexport * from './discriminators';\nexport * from './v00';\nexport * from './v01';\n\nexport type AnchorIdl = IdlV00 | IdlV01;\n\nexport function rootNodeFromAnchor(idl: AnchorIdl): RootNode {\n    return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());\n}\n\nexport function rootNodeFromAnchorWithoutDefaultVisitor(idl: AnchorIdl): RootNode {\n    if ((idl.metadata as { spec?: string })?.spec === '0.1.0') {\n        return rootNodeFromAnchorV01(idl as IdlV01);\n    }\n\n    return rootNodeFromAnchorV00(idl as IdlV00);\n}\n"]}