'use strict';

var visitors = require('@codama/visitors');
var nodes = require('@codama/nodes');
var sha2_js = require('@noble/hashes/sha2.js');
var codecs = require('@solana/codecs');
var errors = require('@codama/errors');

// src/index.ts
function defaultVisitor() {
  return visitors.rootNodeVisitor((currentRoot) => {
    let root = currentRoot;
    const updateRoot = (visitor) => {
      const newRoot = visitors.visit(root, visitor);
      nodes.assertIsNode(newRoot, "rootNode");
      root = newRoot;
    };
    updateRoot(visitors.deduplicateIdenticalDefinedTypesVisitor());
    updateRoot(visitors.setFixedAccountSizesVisitor());
    updateRoot(visitors.setInstructionAccountDefaultValuesVisitor(visitors.getCommonInstructionAccountDefaultRules()));
    updateRoot(visitors.unwrapInstructionArgsDefinedTypesVisitor());
    updateRoot(visitors.flattenInstructionDataArgumentsVisitor());
    updateRoot(visitors.transformU8ArraysToBytesVisitor());
    return root;
  });
}

// src/utils.ts
function hex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// src/discriminators.ts
var getAnchorDiscriminatorV01 = (discriminator) => {
  return nodes.bytesValueNode("base16", hex(new Uint8Array(discriminator)));
};
var getAnchorInstructionDiscriminatorV00 = (idlName) => {
  const bytes = codecs.getUtf8Codec().encode(`global:${nodes.snakeCase(idlName)}`);
  const hash = sha2_js.sha256(bytes).slice(0, 8);
  return nodes.bytesValueNode("base16", hex(hash));
};
var getAnchorAccountDiscriminatorV00 = (idlName) => {
  const bytes = codecs.getUtf8Codec().encode(`account:${nodes.pascalCase(idlName)}`);
  const hash = sha2_js.sha256(bytes).slice(0, 8);
  return nodes.bytesValueNode("base16", hex(hash));
};
function enumEmptyVariantTypeNodeFromAnchorV00(idl) {
  return nodes.enumEmptyVariantTypeNode(idl.name ?? "");
}
function structFieldTypeNodeFromAnchorV00(idl) {
  return nodes.structFieldTypeNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV00(idl) {
  return nodes.structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV00(idl) {
  return nodes.enumStructVariantTypeNode(
    idl.name ?? "",
    structTypeNodeFromAnchorV00({ fields: idl.fields})
  );
}
function tupleTypeNodeFromAnchorV00(idl) {
  return nodes.tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV00(idl) {
  return nodes.enumTupleVariantTypeNode(idl.name ?? "", tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));
}

// src/v00/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV00(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV00(variant);
    }
    if (isStructVariant(variant)) {
      return enumStructVariantTypeNodeFromAnchorV00(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV00(variant);
  });
  return nodes.enumTypeNode(variants, {
    size: idl.size ? nodes.numberTypeNode(idl.size) : void 0
  });
}
function isStructVariant(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}
function mapTypeNodeFromAnchorV00(idl) {
  const [key, value] = "hashMap" in idl ? idl.hashMap : idl.bTreeMap;
  let size;
  if (idl.size === "remainder") {
    size = nodes.remainderCountNode();
  } else if (typeof idl.size === "number") {
    size = nodes.fixedCountNode(idl.size);
  } else {
    size = nodes.prefixedCountNode(nodes.numberTypeNode(idl.size ?? "u32"));
  }
  return nodes.mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);
}
function optionTypeNodeFromAnchorV00(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const defaultPrefix = nodes.numberTypeNode("option" in idl ? "u8" : "u32");
  const defaultFixed = !("option" in idl);
  return nodes.optionTypeNode(typeNodeFromAnchorV00(item), {
    fixed: idl.fixed !== void 0 ? idl.fixed : defaultFixed,
    prefix: idl.prefix ? nodes.numberTypeNode(idl.prefix) : defaultPrefix
  });
}
function setTypeNodeFromAnchorV00(idl) {
  const child = "hashSet" in idl ? idl.hashSet : idl.bTreeSet;
  let size;
  if (idl.size === "remainder") {
    size = nodes.remainderCountNode();
  } else if (typeof idl.size === "number") {
    size = nodes.fixedCountNode(idl.size);
  } else {
    size = nodes.prefixedCountNode(nodes.numberTypeNode(idl.size ?? "u32"));
  }
  return nodes.setTypeNode(typeNodeFromAnchorV00(child), size);
}

// src/v00/typeNodes/TypeNode.ts
var IDL_V00_TYPE_LEAVES = [
  "string",
  "publicKey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV00 = (idlType) => {
  if (typeof idlType === "string" && IDL_V00_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return nodes.booleanTypeNode();
    if (idlType === "publicKey") return nodes.publicKeyTypeNode();
    if (idlType === "string") return nodes.sizePrefixTypeNode(nodes.stringTypeNode("utf8"), nodes.numberTypeNode("u32"));
    if (idlType === "bytes") return nodes.sizePrefixTypeNode(nodes.bytesTypeNode(), nodes.numberTypeNode("u32"));
    return nodes.numberTypeNode(idlType);
  }
  if (typeof idlType !== "object") {
    throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "string") {
    return nodes.definedTypeLinkNode(idlType.defined);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV00(idlType.value);
  }
  if ("hashMap" in idlType && isArrayOfSize(idlType.hashMap, 2) || "bTreeMap" in idlType && isArrayOfSize(idlType.bTreeMap, 2)) {
    return mapTypeNodeFromAnchorV00(idlType);
  }
  if ("option" in idlType || "coption" in idlType) {
    return optionTypeNodeFromAnchorV00(idlType);
  }
  if ("hashSet" in idlType || "bTreeSet" in idlType) {
    return setTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && "fields" in idlType && idlType.kind === "struct") {
    return structTypeNodeFromAnchorV00(idlType);
  }
  if ("tuple" in idlType && Array.isArray(idlType.tuple)) {
    return tupleTypeNodeFromAnchorV00(idlType);
  }
  throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize(array, size) {
  return Array.isArray(array) && array.length === size;
}

// src/v00/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV00(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV00(idl.array[0]);
    return nodes.arrayTypeNode(item2, nodes.fixedCountNode(idl.array[1]));
  }
  const item = typeNodeFromAnchorV00(idl.vec);
  if (idl.size === "remainder") return nodes.arrayTypeNode(item, nodes.remainderCountNode());
  return nodes.arrayTypeNode(item, nodes.prefixedCountNode(nodes.numberTypeNode(idl.size ?? "u32")));
}

// src/v00/AccountNode.ts
function accountNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = nodes.camelCase(idlName);
  const idlStruct = idl.type ?? { fields: []};
  let data = structTypeNodeFromAnchorV00(idlStruct);
  nodes.assertIsNode(data, "structTypeNode");
  const hasSeeds = (idl.seeds ?? []).length > 0;
  let discriminators;
  if (origin === "anchor") {
    const discriminator = nodes.structFieldTypeNode({
      defaultValue: getAnchorAccountDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: nodes.fixedSizeTypeNode(nodes.bytesTypeNode(), 8)
    });
    data = nodes.structTypeNode([discriminator, ...data.fields]);
    discriminators = [nodes.fieldDiscriminatorNode("discriminator")];
  }
  return nodes.accountNode({
    data,
    discriminators,
    docs: idl.docs ?? [],
    name,
    pda: hasSeeds ? nodes.pdaLinkNode(name) : void 0,
    size: idl.size
  });
}
function definedTypeNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV00(idlType);
  return nodes.definedTypeNode({ docs: idl.docs, name, type });
}
function errorNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return nodes.errorNode({
    code: idl.code ?? -1,
    docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],
    message: msg,
    name
  });
}
function hasDuplicateAccountNames(idl) {
  const seenNames = /* @__PURE__ */ new Set();
  function checkDuplicates(items) {
    for (const item of items) {
      if ("accounts" in item) {
        if (checkDuplicates(item.accounts)) {
          return true;
        }
      } else {
        const name = nodes.camelCase(item.name ?? "");
        if (seenNames.has(name)) {
          return true;
        }
        seenNames.add(name);
      }
    }
    return false;
  }
  return checkDuplicates(idl);
}
function instructionAccountNodesFromAnchorV00(idl, prefix) {
  const shouldPrefix = prefix !== void 0 || hasDuplicateAccountNames(idl);
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV00(
      account.accounts,
      shouldPrefix ? prefix ? `${prefix}_${account.name}` : account.name : void 0
    ) : [instructionAccountNodeFromAnchorV00(account, shouldPrefix ? prefix : void 0)]
  );
}
function instructionAccountNodeFromAnchorV00(idl, prefix) {
  const isOptional = idl.optional ?? idl.isOptional ?? false;
  const desc = idl.desc ? [idl.desc] : void 0;
  return nodes.instructionAccountNode({
    docs: idl.docs ?? desc ?? [],
    isOptional,
    isSigner: idl.isOptionalSigner ? "either" : idl.isSigner ?? false,
    isWritable: idl.isMut ?? false,
    name: prefix ? `${prefix}_${idl.name ?? ""}` : idl.name ?? ""
  });
}
function instructionArgumentNodeFromAnchorV00(idl) {
  return nodes.instructionArgumentNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}
function instructionNodeFromAnchorV00(idl, ixIndex, origin) {
  const idlName = idl.name ?? "";
  const name = nodes.camelCase(idlName);
  let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);
  let discriminators;
  if (idl.discriminant) {
    const discriminatorField = nodes.instructionArgumentNode({
      defaultValue: nodes.numberValueNode(idl.discriminant.value),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: typeNodeFromAnchorV00(idl.discriminant.type)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [nodes.fieldDiscriminatorNode("discriminator")];
  } else if (origin === "anchor") {
    const discriminatorField = nodes.instructionArgumentNode({
      defaultValue: getAnchorInstructionDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: nodes.fixedSizeTypeNode(nodes.bytesTypeNode(), 8)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [nodes.fieldDiscriminatorNode("discriminator")];
  } else if (origin === "shank") {
    const discriminatorField = nodes.instructionArgumentNode({
      defaultValue: nodes.bytesValueNode("base16", ixIndex.toString(16)),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: nodes.fixedSizeTypeNode(nodes.bytesTypeNode(), 1)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [nodes.fieldDiscriminatorNode("discriminator")];
  }
  return nodes.instructionNode({
    accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name,
    optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? "omitted" : "programId"
  });
}
function pdaNodeFromAnchorV00(idl) {
  const name = nodes.camelCase(idl.name ?? "");
  const seeds = (idl.seeds ?? []).map((seed) => {
    if (seed.kind === "constant") {
      const type = (() => {
        if (seed.type === "string") return nodes.stringTypeNode("utf8");
        if (seed.type === "bytes") return nodes.bytesTypeNode();
        return typeNodeFromAnchorV00(seed.type);
      })();
      const value = (() => {
        if (typeof seed.value === "string") return nodes.stringValueNode(seed.value);
        if (typeof seed.value === "number") return nodes.numberValueNode(seed.value);
        return nodes.booleanValueNode(seed.value);
      })();
      return nodes.constantPdaSeedNode(type, value);
    }
    if (seed.kind === "variable") {
      return nodes.variablePdaSeedNode(
        seed.name,
        typeNodeFromAnchorV00(seed.type),
        seed.description ? [seed.description] : []
      );
    }
    return nodes.constantPdaSeedNodeFromProgramId();
  });
  return nodes.pdaNode({ name, seeds });
}
function programNodeFromAnchorV00(idl) {
  const origin = idl?.metadata?.origin ?? "anchor";
  const pdas = (idl.accounts ?? []).filter((account) => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);
  const accounts = (idl.accounts ?? []).map((a) => accountNodeFromAnchorV00(a, origin));
  const instructions = (idl.instructions ?? []).map(
    (instruction, index) => instructionNodeFromAnchorV00(instruction, index, origin)
  );
  return nodes.programNode({
    accounts,
    definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),
    errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),
    instructions,
    name: idl?.name ?? "",
    origin,
    pdas,
    publicKey: idl?.metadata?.address ?? "",
    version: idl.version
  });
}
function rootNodeFromAnchorV00(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV00(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);
  return nodes.rootNode(programNode3, additionalProgramNodes);
}
function extractGenerics(types) {
  const [nonGenericTypes, genericTypes] = types.reduce(
    (acc, type) => {
      acc["generics" in type ? 1 : 0].push(type);
      return acc;
    },
    [[], []]
  );
  const generics = {
    constArgs: {},
    typeArgs: {},
    types: Object.fromEntries(genericTypes.map((type) => [type.name, type]))
  };
  return [nonGenericTypes, generics];
}
function unwrapGenericTypeFromAnchorV01(type, generics) {
  const genericType = generics.types[type.defined.name];
  if (!genericType) {
    throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, { name: type.defined.name });
  }
  const constArgs = {};
  const typeArgs = {};
  const genericDefinitions = genericType.generics ?? [];
  const genericArgs = type.defined.generics ?? [];
  genericDefinitions.forEach((genericDefinition, index) => {
    const genericArg = genericArgs[index];
    if (genericDefinition.kind === "const") {
      constArgs[genericDefinition.name] = genericArg;
    } else {
      typeArgs[genericDefinition.name] = genericArg;
    }
  });
  return typeNodeFromAnchorV01(genericType.type, {
    ...generics,
    constArgs: { ...generics.constArgs, ...constArgs },
    typeArgs: { ...generics.typeArgs, ...typeArgs }
  });
}
function enumEmptyVariantTypeNodeFromAnchorV01(idl) {
  return nodes.enumEmptyVariantTypeNode(idl.name ?? "");
}
function structFieldTypeNodeFromAnchorV01(idl, generics) {
  if (!isStructField(idl)) {
    throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idl)
    });
  }
  return nodes.structFieldTypeNode({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}
function isStructField(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV01(idl, generics) {
  const fields = idl.fields ?? [];
  return nodes.structTypeNode(fields.map((field) => structFieldTypeNodeFromAnchorV01(field, generics)));
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV01(idl, generics) {
  return nodes.enumStructVariantTypeNode(
    idl.name ?? "",
    structTypeNodeFromAnchorV01({ fields: idl.fields}, generics)
  );
}
function tupleTypeNodeFromAnchorV01(idl, generics) {
  return nodes.tupleTypeNode(idl.map((type) => typeNodeFromAnchorV01(type, generics)));
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV01(idl, generics) {
  return nodes.enumTupleVariantTypeNode(idl.name ?? "", tupleTypeNodeFromAnchorV01(idl.fields, generics));
}

// src/v01/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV01(idl, generics) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV01(variant);
    }
    if (isStructVariant2(variant)) {
      return enumStructVariantTypeNodeFromAnchorV01(variant, generics);
    }
    return enumTupleVariantTypeNodeFromAnchorV01(
      variant,
      generics
    );
  });
  return nodes.enumTypeNode(variants);
}
function isStructVariant2(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}
function optionTypeNodeFromAnchorV01(idl, generics) {
  const item = "option" in idl ? idl.option : idl.coption;
  const hasOptionField = "option" in idl;
  const prefix = nodes.numberTypeNode(hasOptionField ? "u8" : "u32");
  const fixed = !hasOptionField;
  return nodes.optionTypeNode(typeNodeFromAnchorV01(item, generics), {
    fixed,
    prefix
  });
}

// src/v01/typeNodes/TypeNode.ts
var IDL_V01_TYPE_LEAVES = [
  "string",
  "pubkey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV01 = (idlType, generics) => {
  if (typeof idlType === "string" && IDL_V01_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return nodes.booleanTypeNode();
    if (idlType === "pubkey") return nodes.publicKeyTypeNode();
    if (idlType === "string") return nodes.sizePrefixTypeNode(nodes.stringTypeNode("utf8"), nodes.numberTypeNode("u32"));
    if (idlType === "bytes") return nodes.sizePrefixTypeNode(nodes.bytesTypeNode(), nodes.numberTypeNode("u32"));
    return nodes.numberTypeNode(idlType);
  }
  if (typeof idlType !== "object") {
    throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize2(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("defined" in idlType && typeof idlType.defined === "object") {
    return "generics" in idlType.defined ? unwrapGenericTypeFromAnchorV01(idlType, generics) : nodes.definedTypeLinkNode(idlType.defined.name);
  }
  if ("generic" in idlType) {
    return typeNodeFromAnchorV01(generics.typeArgs[idlType.generic].type, generics);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV01(idlType.value, generics);
  }
  if ("option" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("coption" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "struct") {
    const fields = idlType.fields ?? [];
    if (isStructFieldArray(fields)) {
      return structTypeNodeFromAnchorV01(idlType, generics);
    }
    if (isTupleFieldArray(fields)) {
      return tupleTypeNodeFromAnchorV01(fields, generics);
    }
  }
  throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize2(array, size) {
  return Array.isArray(array) && array.length === size;
}
function isStructFieldArray(field) {
  return field.every(isStructField2);
}
function isTupleFieldArray(field) {
  return field.every((f) => !isStructField2(f));
}
function isStructField2(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV01(idl, generics) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV01(idl.array[0], generics);
    const size = typeof idl.array[1] === "number" ? idl.array[1] : parseInt(generics.constArgs[idl.array[1].generic].value);
    return nodes.arrayTypeNode(item2, nodes.fixedCountNode(size));
  }
  const item = typeNodeFromAnchorV01(idl.vec, generics);
  return nodes.arrayTypeNode(item, nodes.prefixedCountNode(nodes.numberTypeNode("u32")));
}

// src/v01/AccountNode.ts
function accountNodeFromAnchorV01(idl, types, generics) {
  const name = nodes.camelCase(idl.name);
  const type = types.find(({ name: name2 }) => name2 === idl.name);
  if (!type) {
    throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });
  }
  const data = typeNodeFromAnchorV01(type.type, generics);
  nodes.assertIsNode(data, "structTypeNode");
  const discriminator = nodes.structFieldTypeNode({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: nodes.fixedSizeTypeNode(nodes.bytesTypeNode(), idl.discriminator.length)
  });
  return nodes.accountNode({
    data: nodes.structTypeNode([discriminator, ...data.fields]),
    discriminators: [nodes.fieldDiscriminatorNode("discriminator")],
    name
  });
}
function definedTypeNodeFromAnchorV01(idl, generics) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV01(idlType, generics);
  return nodes.definedTypeNode({ docs: idl.docs, name, type });
}
function errorNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return nodes.errorNode({
    code: idl.code ?? -1,
    docs: `${name}: ${msg}`,
    message: msg,
    name
  });
}
function pdaSeedNodeFromAnchorV01(seed, instructionArguments, prefix) {
  const kind = seed.kind;
  switch (kind) {
    case "const":
      return {
        definition: nodes.constantPdaSeedNodeFromBytes("base58", codecs.getBase58Codec().decode(new Uint8Array(seed.value)))
      };
    case "account": {
      const [accountName] = seed.path.split(".");
      const prefixedAccountName = prefix ? `${prefix}_${accountName}` : accountName;
      return {
        definition: nodes.variablePdaSeedNode(prefixedAccountName, nodes.publicKeyTypeNode()),
        value: nodes.pdaSeedValueNode(prefixedAccountName, nodes.accountValueNode(prefixedAccountName))
      };
    }
    case "arg": {
      const [originalArgumentName] = seed.path.split(".");
      const argumentName = nodes.camelCase(originalArgumentName);
      const argumentNode = instructionArguments.find(({ name }) => name === argumentName);
      if (!argumentNode) {
        throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: originalArgumentName });
      }
      const isBorshString = nodes.isNode(argumentNode.type, "sizePrefixTypeNode") && nodes.isNode(argumentNode.type.type, "stringTypeNode") && argumentNode.type.type.encoding === "utf8" && nodes.isNode(argumentNode.type.prefix, "numberTypeNode") && argumentNode.type.prefix.format === "u32";
      const argumentType = isBorshString ? nodes.stringTypeNode("utf8") : argumentNode.type;
      return {
        definition: nodes.variablePdaSeedNode(argumentNode.name, argumentType),
        value: nodes.pdaSeedValueNode(argumentNode.name, nodes.argumentValueNode(argumentNode.name))
      };
    }
    default:
      throw new errors.CodamaError(errors.CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });
  }
}

// src/v01/InstructionAccountNode.ts
function hasDuplicateAccountNames2(idl) {
  const seenNames = /* @__PURE__ */ new Set();
  function checkDuplicates(items) {
    for (const item of items) {
      if ("accounts" in item) {
        if (checkDuplicates(item.accounts)) {
          return true;
        }
      } else {
        const name = nodes.camelCase(item.name ?? "");
        if (seenNames.has(name)) {
          return true;
        }
        seenNames.add(name);
      }
    }
    return false;
  }
  return checkDuplicates(idl);
}
function instructionAccountNodesFromAnchorV01(idl, instructionArguments, prefix) {
  const shouldPrefix = prefix !== void 0 || hasDuplicateAccountNames2(idl);
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV01(
      account.accounts,
      instructionArguments,
      shouldPrefix ? prefix ? `${prefix}_${account.name}` : account.name : void 0
    ) : [instructionAccountNodeFromAnchorV01(account, instructionArguments, shouldPrefix ? prefix : void 0)]
  );
}
function instructionAccountNodeFromAnchorV01(idl, instructionArguments, prefix) {
  const isOptional = idl.optional ?? false;
  const docs = idl.docs ?? [];
  const isSigner = idl.signer ?? false;
  const isWritable = idl.writable ?? false;
  const name = prefix ? `${prefix}_${idl.name ?? ""}` : idl.name ?? "";
  let defaultValue;
  if (idl.address) {
    defaultValue = nodes.publicKeyValueNode(idl.address, name);
  } else if (idl.pda) {
    const seedsWithNestedPaths = idl.pda.seeds.some((seed) => "path" in seed && seed.path.includes("."));
    if (!seedsWithNestedPaths) {
      const [seedDefinitions, seedValues] = idl.pda.seeds.reduce(
        ([seeds, lookups], seed) => {
          const { definition, value } = pdaSeedNodeFromAnchorV01(seed, instructionArguments, prefix);
          return [[...seeds, definition], value ? [...lookups, value] : lookups];
        },
        [[], []]
      );
      let programId;
      let programIdValue;
      if (idl.pda.program !== void 0) {
        const { definition, value } = pdaSeedNodeFromAnchorV01(idl.pda.program, instructionArguments, prefix);
        if (nodes.isNode(definition, "constantPdaSeedNode") && nodes.isNode(definition.value, "bytesValueNode") && definition.value.encoding === "base58") {
          programId = definition.value.data;
        } else if (value && nodes.isNode(value.value, ["accountValueNode", "argumentValueNode"])) {
          programIdValue = value.value;
        }
      }
      defaultValue = nodes.pdaValueNode(
        nodes.pdaNode({ name, programId, seeds: seedDefinitions }),
        seedValues,
        programIdValue
      );
    }
  }
  return nodes.instructionAccountNode({
    defaultValue,
    docs,
    isOptional,
    isSigner,
    isWritable,
    name
  });
}
function instructionArgumentNodeFromAnchorV01(idl, generics) {
  return nodes.instructionArgumentNode({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}
function instructionNodeFromAnchorV01(idl, generics) {
  const name = idl.name;
  let dataArguments = idl.args.map((arg) => instructionArgumentNodeFromAnchorV01(arg, generics));
  const discriminatorField = nodes.instructionArgumentNode({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: nodes.fixedSizeTypeNode(nodes.bytesTypeNode(), idl.discriminator.length)
  });
  dataArguments = [discriminatorField, ...dataArguments];
  const discriminators = [nodes.fieldDiscriminatorNode("discriminator")];
  return nodes.instructionNode({
    accounts: instructionAccountNodesFromAnchorV01(idl.accounts ?? [], dataArguments),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name: nodes.camelCase(name),
    optionalAccountStrategy: "programId"
  });
}
function programNodeFromAnchorV01(idl) {
  const [types, generics] = extractGenerics(idl.types ?? []);
  const accounts = idl.accounts ?? [];
  const instructions = idl.instructions ?? [];
  const errors = idl.errors ?? [];
  const filteredTypes = types.filter((type) => !accounts.some((account) => account.name === type.name));
  const definedTypes = filteredTypes.map((type) => definedTypeNodeFromAnchorV01(type, generics));
  const accountNodes = accounts.map((account) => accountNodeFromAnchorV01(account, types, generics));
  return nodes.programNode({
    accounts: accountNodes,
    definedTypes,
    errors: errors.map(errorNodeFromAnchorV01),
    instructions: instructions.map((instruction) => instructionNodeFromAnchorV01(instruction, generics)),
    name: idl.metadata.name,
    origin: "anchor",
    publicKey: idl.address,
    version: idl.metadata.version
  });
}
function rootNodeFromAnchorV01(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV01(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);
  return nodes.rootNode(programNode3, additionalProgramNodes);
}

// src/index.ts
function rootNodeFromAnchor(idl) {
  return visitors.visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());
}
function rootNodeFromAnchorWithoutDefaultVisitor(idl) {
  if (idl.metadata?.spec === "0.1.0") {
    return rootNodeFromAnchorV01(idl);
  }
  return rootNodeFromAnchorV00(idl);
}

exports.accountNodeFromAnchorV00 = accountNodeFromAnchorV00;
exports.accountNodeFromAnchorV01 = accountNodeFromAnchorV01;
exports.arrayTypeNodeFromAnchorV00 = arrayTypeNodeFromAnchorV00;
exports.arrayTypeNodeFromAnchorV01 = arrayTypeNodeFromAnchorV01;
exports.defaultVisitor = defaultVisitor;
exports.definedTypeNodeFromAnchorV00 = definedTypeNodeFromAnchorV00;
exports.definedTypeNodeFromAnchorV01 = definedTypeNodeFromAnchorV01;
exports.enumEmptyVariantTypeNodeFromAnchorV00 = enumEmptyVariantTypeNodeFromAnchorV00;
exports.enumEmptyVariantTypeNodeFromAnchorV01 = enumEmptyVariantTypeNodeFromAnchorV01;
exports.enumStructVariantTypeNodeFromAnchorV00 = enumStructVariantTypeNodeFromAnchorV00;
exports.enumStructVariantTypeNodeFromAnchorV01 = enumStructVariantTypeNodeFromAnchorV01;
exports.enumTupleVariantTypeNodeFromAnchorV00 = enumTupleVariantTypeNodeFromAnchorV00;
exports.enumTupleVariantTypeNodeFromAnchorV01 = enumTupleVariantTypeNodeFromAnchorV01;
exports.enumTypeNodeFromAnchorV00 = enumTypeNodeFromAnchorV00;
exports.enumTypeNodeFromAnchorV01 = enumTypeNodeFromAnchorV01;
exports.errorNodeFromAnchorV00 = errorNodeFromAnchorV00;
exports.errorNodeFromAnchorV01 = errorNodeFromAnchorV01;
exports.extractGenerics = extractGenerics;
exports.getAnchorAccountDiscriminatorV00 = getAnchorAccountDiscriminatorV00;
exports.getAnchorDiscriminatorV01 = getAnchorDiscriminatorV01;
exports.getAnchorInstructionDiscriminatorV00 = getAnchorInstructionDiscriminatorV00;
exports.instructionAccountNodeFromAnchorV00 = instructionAccountNodeFromAnchorV00;
exports.instructionAccountNodeFromAnchorV01 = instructionAccountNodeFromAnchorV01;
exports.instructionAccountNodesFromAnchorV00 = instructionAccountNodesFromAnchorV00;
exports.instructionAccountNodesFromAnchorV01 = instructionAccountNodesFromAnchorV01;
exports.instructionArgumentNodeFromAnchorV00 = instructionArgumentNodeFromAnchorV00;
exports.instructionArgumentNodeFromAnchorV01 = instructionArgumentNodeFromAnchorV01;
exports.instructionNodeFromAnchorV00 = instructionNodeFromAnchorV00;
exports.instructionNodeFromAnchorV01 = instructionNodeFromAnchorV01;
exports.mapTypeNodeFromAnchorV00 = mapTypeNodeFromAnchorV00;
exports.optionTypeNodeFromAnchorV00 = optionTypeNodeFromAnchorV00;
exports.optionTypeNodeFromAnchorV01 = optionTypeNodeFromAnchorV01;
exports.pdaNodeFromAnchorV00 = pdaNodeFromAnchorV00;
exports.pdaSeedNodeFromAnchorV01 = pdaSeedNodeFromAnchorV01;
exports.programNodeFromAnchorV00 = programNodeFromAnchorV00;
exports.programNodeFromAnchorV01 = programNodeFromAnchorV01;
exports.rootNodeFromAnchor = rootNodeFromAnchor;
exports.rootNodeFromAnchorV00 = rootNodeFromAnchorV00;
exports.rootNodeFromAnchorV01 = rootNodeFromAnchorV01;
exports.rootNodeFromAnchorWithoutDefaultVisitor = rootNodeFromAnchorWithoutDefaultVisitor;
exports.setTypeNodeFromAnchorV00 = setTypeNodeFromAnchorV00;
exports.structFieldTypeNodeFromAnchorV00 = structFieldTypeNodeFromAnchorV00;
exports.structFieldTypeNodeFromAnchorV01 = structFieldTypeNodeFromAnchorV01;
exports.structTypeNodeFromAnchorV00 = structTypeNodeFromAnchorV00;
exports.structTypeNodeFromAnchorV01 = structTypeNodeFromAnchorV01;
exports.tupleTypeNodeFromAnchorV00 = tupleTypeNodeFromAnchorV00;
exports.tupleTypeNodeFromAnchorV01 = tupleTypeNodeFromAnchorV01;
exports.typeNodeFromAnchorV00 = typeNodeFromAnchorV00;
exports.typeNodeFromAnchorV01 = typeNodeFromAnchorV01;
exports.unwrapGenericTypeFromAnchorV01 = unwrapGenericTypeFromAnchorV01;
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map