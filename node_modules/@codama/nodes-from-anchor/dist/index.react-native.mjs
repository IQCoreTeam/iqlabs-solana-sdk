import { rootNodeVisitor, deduplicateIdenticalDefinedTypesVisitor, setFixedAccountSizesVisitor, setInstructionAccountDefaultValuesVisitor, getCommonInstructionAccountDefaultRules, unwrapInstructionArgsDefinedTypesVisitor, flattenInstructionDataArgumentsVisitor, transformU8ArraysToBytesVisitor, visit } from '@codama/visitors';
import { bytesValueNode, snakeCase, pascalCase, enumEmptyVariantTypeNode, structFieldTypeNode, structTypeNode, enumStructVariantTypeNode, tupleTypeNode, enumTupleVariantTypeNode, enumTypeNode, numberTypeNode, remainderCountNode, fixedCountNode, prefixedCountNode, mapTypeNode, optionTypeNode, setTypeNode, booleanTypeNode, publicKeyTypeNode, sizePrefixTypeNode, stringTypeNode, bytesTypeNode, definedTypeLinkNode, arrayTypeNode, camelCase, assertIsNode, fixedSizeTypeNode, fieldDiscriminatorNode, accountNode, pdaLinkNode, definedTypeNode, errorNode, instructionAccountNode, instructionArgumentNode, numberValueNode, instructionNode, stringValueNode, booleanValueNode, constantPdaSeedNode, variablePdaSeedNode, constantPdaSeedNodeFromProgramId, pdaNode, programNode, rootNode, isNode, pdaSeedValueNode, argumentValueNode, accountValueNode, constantPdaSeedNodeFromBytes, publicKeyValueNode, pdaValueNode } from '@codama/nodes';
import { sha256 } from '@noble/hashes/sha2.js';
import { getUtf8Codec, getBase58Codec } from '@solana/codecs';
import { CodamaError, CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING } from '@codama/errors';

// src/index.ts
function defaultVisitor() {
  return rootNodeVisitor((currentRoot) => {
    let root = currentRoot;
    const updateRoot = (visitor) => {
      const newRoot = visit(root, visitor);
      assertIsNode(newRoot, "rootNode");
      root = newRoot;
    };
    updateRoot(deduplicateIdenticalDefinedTypesVisitor());
    updateRoot(setFixedAccountSizesVisitor());
    updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));
    updateRoot(unwrapInstructionArgsDefinedTypesVisitor());
    updateRoot(flattenInstructionDataArgumentsVisitor());
    updateRoot(transformU8ArraysToBytesVisitor());
    return root;
  });
}

// src/utils.ts
function hex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// src/discriminators.ts
var getAnchorDiscriminatorV01 = (discriminator) => {
  return bytesValueNode("base16", hex(new Uint8Array(discriminator)));
};
var getAnchorInstructionDiscriminatorV00 = (idlName) => {
  const bytes = getUtf8Codec().encode(`global:${snakeCase(idlName)}`);
  const hash = sha256(bytes).slice(0, 8);
  return bytesValueNode("base16", hex(hash));
};
var getAnchorAccountDiscriminatorV00 = (idlName) => {
  const bytes = getUtf8Codec().encode(`account:${pascalCase(idlName)}`);
  const hash = sha256(bytes).slice(0, 8);
  return bytesValueNode("base16", hex(hash));
};
function enumEmptyVariantTypeNodeFromAnchorV00(idl) {
  return enumEmptyVariantTypeNode(idl.name ?? "");
}
function structFieldTypeNodeFromAnchorV00(idl) {
  return structFieldTypeNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV00(idl) {
  return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV00(idl) {
  return enumStructVariantTypeNode(
    idl.name ?? "",
    structTypeNodeFromAnchorV00({ fields: idl.fields})
  );
}
function tupleTypeNodeFromAnchorV00(idl) {
  return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV00(idl) {
  return enumTupleVariantTypeNode(idl.name ?? "", tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));
}

// src/v00/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV00(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV00(variant);
    }
    if (isStructVariant(variant)) {
      return enumStructVariantTypeNodeFromAnchorV00(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV00(variant);
  });
  return enumTypeNode(variants, {
    size: idl.size ? numberTypeNode(idl.size) : void 0
  });
}
function isStructVariant(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}
function mapTypeNodeFromAnchorV00(idl) {
  const [key, value] = "hashMap" in idl ? idl.hashMap : idl.bTreeMap;
  let size;
  if (idl.size === "remainder") {
    size = remainderCountNode();
  } else if (typeof idl.size === "number") {
    size = fixedCountNode(idl.size);
  } else {
    size = prefixedCountNode(numberTypeNode(idl.size ?? "u32"));
  }
  return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);
}
function optionTypeNodeFromAnchorV00(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const defaultPrefix = numberTypeNode("option" in idl ? "u8" : "u32");
  const defaultFixed = !("option" in idl);
  return optionTypeNode(typeNodeFromAnchorV00(item), {
    fixed: idl.fixed !== void 0 ? idl.fixed : defaultFixed,
    prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix
  });
}
function setTypeNodeFromAnchorV00(idl) {
  const child = "hashSet" in idl ? idl.hashSet : idl.bTreeSet;
  let size;
  if (idl.size === "remainder") {
    size = remainderCountNode();
  } else if (typeof idl.size === "number") {
    size = fixedCountNode(idl.size);
  } else {
    size = prefixedCountNode(numberTypeNode(idl.size ?? "u32"));
  }
  return setTypeNode(typeNodeFromAnchorV00(child), size);
}

// src/v00/typeNodes/TypeNode.ts
var IDL_V00_TYPE_LEAVES = [
  "string",
  "publicKey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV00 = (idlType) => {
  if (typeof idlType === "string" && IDL_V00_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return booleanTypeNode();
    if (idlType === "publicKey") return publicKeyTypeNode();
    if (idlType === "string") return sizePrefixTypeNode(stringTypeNode("utf8"), numberTypeNode("u32"));
    if (idlType === "bytes") return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode("u32"));
    return numberTypeNode(idlType);
  }
  if (typeof idlType !== "object") {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "string") {
    return definedTypeLinkNode(idlType.defined);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV00(idlType.value);
  }
  if ("hashMap" in idlType && isArrayOfSize(idlType.hashMap, 2) || "bTreeMap" in idlType && isArrayOfSize(idlType.bTreeMap, 2)) {
    return mapTypeNodeFromAnchorV00(idlType);
  }
  if ("option" in idlType || "coption" in idlType) {
    return optionTypeNodeFromAnchorV00(idlType);
  }
  if ("hashSet" in idlType || "bTreeSet" in idlType) {
    return setTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && "fields" in idlType && idlType.kind === "struct") {
    return structTypeNodeFromAnchorV00(idlType);
  }
  if ("tuple" in idlType && Array.isArray(idlType.tuple)) {
    return tupleTypeNodeFromAnchorV00(idlType);
  }
  throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize(array, size) {
  return Array.isArray(array) && array.length === size;
}

// src/v00/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV00(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV00(idl.array[0]);
    return arrayTypeNode(item2, fixedCountNode(idl.array[1]));
  }
  const item = typeNodeFromAnchorV00(idl.vec);
  if (idl.size === "remainder") return arrayTypeNode(item, remainderCountNode());
  return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? "u32")));
}

// src/v00/AccountNode.ts
function accountNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = camelCase(idlName);
  const idlStruct = idl.type ?? { fields: []};
  let data = structTypeNodeFromAnchorV00(idlStruct);
  assertIsNode(data, "structTypeNode");
  const hasSeeds = (idl.seeds ?? []).length > 0;
  let discriminators;
  if (origin === "anchor") {
    const discriminator = structFieldTypeNode({
      defaultValue: getAnchorAccountDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: fixedSizeTypeNode(bytesTypeNode(), 8)
    });
    data = structTypeNode([discriminator, ...data.fields]);
    discriminators = [fieldDiscriminatorNode("discriminator")];
  }
  return accountNode({
    data,
    discriminators,
    docs: idl.docs ?? [],
    name,
    pda: hasSeeds ? pdaLinkNode(name) : void 0,
    size: idl.size
  });
}
function definedTypeNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV00(idlType);
  return definedTypeNode({ docs: idl.docs, name, type });
}
function errorNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return errorNode({
    code: idl.code ?? -1,
    docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],
    message: msg,
    name
  });
}
function hasDuplicateAccountNames(idl) {
  const seenNames = /* @__PURE__ */ new Set();
  function checkDuplicates(items) {
    for (const item of items) {
      if ("accounts" in item) {
        if (checkDuplicates(item.accounts)) {
          return true;
        }
      } else {
        const name = camelCase(item.name ?? "");
        if (seenNames.has(name)) {
          return true;
        }
        seenNames.add(name);
      }
    }
    return false;
  }
  return checkDuplicates(idl);
}
function instructionAccountNodesFromAnchorV00(idl, prefix) {
  const shouldPrefix = prefix !== void 0 || hasDuplicateAccountNames(idl);
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV00(
      account.accounts,
      shouldPrefix ? prefix ? `${prefix}_${account.name}` : account.name : void 0
    ) : [instructionAccountNodeFromAnchorV00(account, shouldPrefix ? prefix : void 0)]
  );
}
function instructionAccountNodeFromAnchorV00(idl, prefix) {
  const isOptional = idl.optional ?? idl.isOptional ?? false;
  const desc = idl.desc ? [idl.desc] : void 0;
  return instructionAccountNode({
    docs: idl.docs ?? desc ?? [],
    isOptional,
    isSigner: idl.isOptionalSigner ? "either" : idl.isSigner ?? false,
    isWritable: idl.isMut ?? false,
    name: prefix ? `${prefix}_${idl.name ?? ""}` : idl.name ?? ""
  });
}
function instructionArgumentNodeFromAnchorV00(idl) {
  return instructionArgumentNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}
function instructionNodeFromAnchorV00(idl, ixIndex, origin) {
  const idlName = idl.name ?? "";
  const name = camelCase(idlName);
  let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);
  let discriminators;
  if (idl.discriminant) {
    const discriminatorField = instructionArgumentNode({
      defaultValue: numberValueNode(idl.discriminant.value),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: typeNodeFromAnchorV00(idl.discriminant.type)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [fieldDiscriminatorNode("discriminator")];
  } else if (origin === "anchor") {
    const discriminatorField = instructionArgumentNode({
      defaultValue: getAnchorInstructionDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: fixedSizeTypeNode(bytesTypeNode(), 8)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [fieldDiscriminatorNode("discriminator")];
  } else if (origin === "shank") {
    const discriminatorField = instructionArgumentNode({
      defaultValue: bytesValueNode("base16", ixIndex.toString(16)),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: fixedSizeTypeNode(bytesTypeNode(), 1)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [fieldDiscriminatorNode("discriminator")];
  }
  return instructionNode({
    accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name,
    optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? "omitted" : "programId"
  });
}
function pdaNodeFromAnchorV00(idl) {
  const name = camelCase(idl.name ?? "");
  const seeds = (idl.seeds ?? []).map((seed) => {
    if (seed.kind === "constant") {
      const type = (() => {
        if (seed.type === "string") return stringTypeNode("utf8");
        if (seed.type === "bytes") return bytesTypeNode();
        return typeNodeFromAnchorV00(seed.type);
      })();
      const value = (() => {
        if (typeof seed.value === "string") return stringValueNode(seed.value);
        if (typeof seed.value === "number") return numberValueNode(seed.value);
        return booleanValueNode(seed.value);
      })();
      return constantPdaSeedNode(type, value);
    }
    if (seed.kind === "variable") {
      return variablePdaSeedNode(
        seed.name,
        typeNodeFromAnchorV00(seed.type),
        seed.description ? [seed.description] : []
      );
    }
    return constantPdaSeedNodeFromProgramId();
  });
  return pdaNode({ name, seeds });
}
function programNodeFromAnchorV00(idl) {
  const origin = idl?.metadata?.origin ?? "anchor";
  const pdas = (idl.accounts ?? []).filter((account) => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);
  const accounts = (idl.accounts ?? []).map((a) => accountNodeFromAnchorV00(a, origin));
  const instructions = (idl.instructions ?? []).map(
    (instruction, index) => instructionNodeFromAnchorV00(instruction, index, origin)
  );
  return programNode({
    accounts,
    definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),
    errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),
    instructions,
    name: idl?.name ?? "",
    origin,
    pdas,
    publicKey: idl?.metadata?.address ?? "",
    version: idl.version
  });
}
function rootNodeFromAnchorV00(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV00(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);
  return rootNode(programNode3, additionalProgramNodes);
}
function extractGenerics(types) {
  const [nonGenericTypes, genericTypes] = types.reduce(
    (acc, type) => {
      acc["generics" in type ? 1 : 0].push(type);
      return acc;
    },
    [[], []]
  );
  const generics = {
    constArgs: {},
    typeArgs: {},
    types: Object.fromEntries(genericTypes.map((type) => [type.name, type]))
  };
  return [nonGenericTypes, generics];
}
function unwrapGenericTypeFromAnchorV01(type, generics) {
  const genericType = generics.types[type.defined.name];
  if (!genericType) {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__GENERIC_TYPE_MISSING, { name: type.defined.name });
  }
  const constArgs = {};
  const typeArgs = {};
  const genericDefinitions = genericType.generics ?? [];
  const genericArgs = type.defined.generics ?? [];
  genericDefinitions.forEach((genericDefinition, index) => {
    const genericArg = genericArgs[index];
    if (genericDefinition.kind === "const") {
      constArgs[genericDefinition.name] = genericArg;
    } else {
      typeArgs[genericDefinition.name] = genericArg;
    }
  });
  return typeNodeFromAnchorV01(genericType.type, {
    ...generics,
    constArgs: { ...generics.constArgs, ...constArgs },
    typeArgs: { ...generics.typeArgs, ...typeArgs }
  });
}
function enumEmptyVariantTypeNodeFromAnchorV01(idl) {
  return enumEmptyVariantTypeNode(idl.name ?? "");
}
function structFieldTypeNodeFromAnchorV01(idl, generics) {
  if (!isStructField(idl)) {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idl)
    });
  }
  return structFieldTypeNode({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}
function isStructField(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV01(idl, generics) {
  const fields = idl.fields ?? [];
  return structTypeNode(fields.map((field) => structFieldTypeNodeFromAnchorV01(field, generics)));
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV01(idl, generics) {
  return enumStructVariantTypeNode(
    idl.name ?? "",
    structTypeNodeFromAnchorV01({ fields: idl.fields}, generics)
  );
}
function tupleTypeNodeFromAnchorV01(idl, generics) {
  return tupleTypeNode(idl.map((type) => typeNodeFromAnchorV01(type, generics)));
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV01(idl, generics) {
  return enumTupleVariantTypeNode(idl.name ?? "", tupleTypeNodeFromAnchorV01(idl.fields, generics));
}

// src/v01/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV01(idl, generics) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV01(variant);
    }
    if (isStructVariant2(variant)) {
      return enumStructVariantTypeNodeFromAnchorV01(variant, generics);
    }
    return enumTupleVariantTypeNodeFromAnchorV01(
      variant,
      generics
    );
  });
  return enumTypeNode(variants);
}
function isStructVariant2(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}
function optionTypeNodeFromAnchorV01(idl, generics) {
  const item = "option" in idl ? idl.option : idl.coption;
  const hasOptionField = "option" in idl;
  const prefix = numberTypeNode(hasOptionField ? "u8" : "u32");
  const fixed = !hasOptionField;
  return optionTypeNode(typeNodeFromAnchorV01(item, generics), {
    fixed,
    prefix
  });
}

// src/v01/typeNodes/TypeNode.ts
var IDL_V01_TYPE_LEAVES = [
  "string",
  "pubkey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV01 = (idlType, generics) => {
  if (typeof idlType === "string" && IDL_V01_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return booleanTypeNode();
    if (idlType === "pubkey") return publicKeyTypeNode();
    if (idlType === "string") return sizePrefixTypeNode(stringTypeNode("utf8"), numberTypeNode("u32"));
    if (idlType === "bytes") return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode("u32"));
    return numberTypeNode(idlType);
  }
  if (typeof idlType !== "object") {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize2(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("defined" in idlType && typeof idlType.defined === "object") {
    return "generics" in idlType.defined ? unwrapGenericTypeFromAnchorV01(idlType, generics) : definedTypeLinkNode(idlType.defined.name);
  }
  if ("generic" in idlType) {
    return typeNodeFromAnchorV01(generics.typeArgs[idlType.generic].type, generics);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "alias" && "value" in idlType) {
    return typeNodeFromAnchorV01(idlType.value, generics);
  }
  if ("option" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("coption" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType, generics);
  }
  if ("kind" in idlType && idlType.kind === "struct") {
    const fields = idlType.fields ?? [];
    if (isStructFieldArray(fields)) {
      return structTypeNodeFromAnchorV01(idlType, generics);
    }
    if (isTupleFieldArray(fields)) {
      return tupleTypeNodeFromAnchorV01(fields, generics);
    }
  }
  throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize2(array, size) {
  return Array.isArray(array) && array.length === size;
}
function isStructFieldArray(field) {
  return field.every(isStructField2);
}
function isTupleFieldArray(field) {
  return field.every((f) => !isStructField2(f));
}
function isStructField2(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV01(idl, generics) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV01(idl.array[0], generics);
    const size = typeof idl.array[1] === "number" ? idl.array[1] : parseInt(generics.constArgs[idl.array[1].generic].value);
    return arrayTypeNode(item2, fixedCountNode(size));
  }
  const item = typeNodeFromAnchorV01(idl.vec, generics);
  return arrayTypeNode(item, prefixedCountNode(numberTypeNode("u32")));
}

// src/v01/AccountNode.ts
function accountNodeFromAnchorV01(idl, types, generics) {
  const name = camelCase(idl.name);
  const type = types.find(({ name: name2 }) => name2 === idl.name);
  if (!type) {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });
  }
  const data = typeNodeFromAnchorV01(type.type, generics);
  assertIsNode(data, "structTypeNode");
  const discriminator = structFieldTypeNode({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length)
  });
  return accountNode({
    data: structTypeNode([discriminator, ...data.fields]),
    discriminators: [fieldDiscriminatorNode("discriminator")],
    name
  });
}
function definedTypeNodeFromAnchorV01(idl, generics) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV01(idlType, generics);
  return definedTypeNode({ docs: idl.docs, name, type });
}
function errorNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return errorNode({
    code: idl.code ?? -1,
    docs: `${name}: ${msg}`,
    message: msg,
    name
  });
}
function pdaSeedNodeFromAnchorV01(seed, instructionArguments, prefix) {
  const kind = seed.kind;
  switch (kind) {
    case "const":
      return {
        definition: constantPdaSeedNodeFromBytes("base58", getBase58Codec().decode(new Uint8Array(seed.value)))
      };
    case "account": {
      const [accountName] = seed.path.split(".");
      const prefixedAccountName = prefix ? `${prefix}_${accountName}` : accountName;
      return {
        definition: variablePdaSeedNode(prefixedAccountName, publicKeyTypeNode()),
        value: pdaSeedValueNode(prefixedAccountName, accountValueNode(prefixedAccountName))
      };
    }
    case "arg": {
      const [originalArgumentName] = seed.path.split(".");
      const argumentName = camelCase(originalArgumentName);
      const argumentNode = instructionArguments.find(({ name }) => name === argumentName);
      if (!argumentNode) {
        throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: originalArgumentName });
      }
      const isBorshString = isNode(argumentNode.type, "sizePrefixTypeNode") && isNode(argumentNode.type.type, "stringTypeNode") && argumentNode.type.type.encoding === "utf8" && isNode(argumentNode.type.prefix, "numberTypeNode") && argumentNode.type.prefix.format === "u32";
      const argumentType = isBorshString ? stringTypeNode("utf8") : argumentNode.type;
      return {
        definition: variablePdaSeedNode(argumentNode.name, argumentType),
        value: pdaSeedValueNode(argumentNode.name, argumentValueNode(argumentNode.name))
      };
    }
    default:
      throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });
  }
}

// src/v01/InstructionAccountNode.ts
function hasDuplicateAccountNames2(idl) {
  const seenNames = /* @__PURE__ */ new Set();
  function checkDuplicates(items) {
    for (const item of items) {
      if ("accounts" in item) {
        if (checkDuplicates(item.accounts)) {
          return true;
        }
      } else {
        const name = camelCase(item.name ?? "");
        if (seenNames.has(name)) {
          return true;
        }
        seenNames.add(name);
      }
    }
    return false;
  }
  return checkDuplicates(idl);
}
function instructionAccountNodesFromAnchorV01(idl, instructionArguments, prefix) {
  const shouldPrefix = prefix !== void 0 || hasDuplicateAccountNames2(idl);
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV01(
      account.accounts,
      instructionArguments,
      shouldPrefix ? prefix ? `${prefix}_${account.name}` : account.name : void 0
    ) : [instructionAccountNodeFromAnchorV01(account, instructionArguments, shouldPrefix ? prefix : void 0)]
  );
}
function instructionAccountNodeFromAnchorV01(idl, instructionArguments, prefix) {
  const isOptional = idl.optional ?? false;
  const docs = idl.docs ?? [];
  const isSigner = idl.signer ?? false;
  const isWritable = idl.writable ?? false;
  const name = prefix ? `${prefix}_${idl.name ?? ""}` : idl.name ?? "";
  let defaultValue;
  if (idl.address) {
    defaultValue = publicKeyValueNode(idl.address, name);
  } else if (idl.pda) {
    const seedsWithNestedPaths = idl.pda.seeds.some((seed) => "path" in seed && seed.path.includes("."));
    if (!seedsWithNestedPaths) {
      const [seedDefinitions, seedValues] = idl.pda.seeds.reduce(
        ([seeds, lookups], seed) => {
          const { definition, value } = pdaSeedNodeFromAnchorV01(seed, instructionArguments, prefix);
          return [[...seeds, definition], value ? [...lookups, value] : lookups];
        },
        [[], []]
      );
      let programId;
      let programIdValue;
      if (idl.pda.program !== void 0) {
        const { definition, value } = pdaSeedNodeFromAnchorV01(idl.pda.program, instructionArguments, prefix);
        if (isNode(definition, "constantPdaSeedNode") && isNode(definition.value, "bytesValueNode") && definition.value.encoding === "base58") {
          programId = definition.value.data;
        } else if (value && isNode(value.value, ["accountValueNode", "argumentValueNode"])) {
          programIdValue = value.value;
        }
      }
      defaultValue = pdaValueNode(
        pdaNode({ name, programId, seeds: seedDefinitions }),
        seedValues,
        programIdValue
      );
    }
  }
  return instructionAccountNode({
    defaultValue,
    docs,
    isOptional,
    isSigner,
    isWritable,
    name
  });
}
function instructionArgumentNodeFromAnchorV01(idl, generics) {
  return instructionArgumentNode({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type, generics)
  });
}
function instructionNodeFromAnchorV01(idl, generics) {
  const name = idl.name;
  let dataArguments = idl.args.map((arg) => instructionArgumentNodeFromAnchorV01(arg, generics));
  const discriminatorField = instructionArgumentNode({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length)
  });
  dataArguments = [discriminatorField, ...dataArguments];
  const discriminators = [fieldDiscriminatorNode("discriminator")];
  return instructionNode({
    accounts: instructionAccountNodesFromAnchorV01(idl.accounts ?? [], dataArguments),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name: camelCase(name),
    optionalAccountStrategy: "programId"
  });
}
function programNodeFromAnchorV01(idl) {
  const [types, generics] = extractGenerics(idl.types ?? []);
  const accounts = idl.accounts ?? [];
  const instructions = idl.instructions ?? [];
  const errors = idl.errors ?? [];
  const filteredTypes = types.filter((type) => !accounts.some((account) => account.name === type.name));
  const definedTypes = filteredTypes.map((type) => definedTypeNodeFromAnchorV01(type, generics));
  const accountNodes = accounts.map((account) => accountNodeFromAnchorV01(account, types, generics));
  return programNode({
    accounts: accountNodes,
    definedTypes,
    errors: errors.map(errorNodeFromAnchorV01),
    instructions: instructions.map((instruction) => instructionNodeFromAnchorV01(instruction, generics)),
    name: idl.metadata.name,
    origin: "anchor",
    publicKey: idl.address,
    version: idl.metadata.version
  });
}
function rootNodeFromAnchorV01(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV01(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);
  return rootNode(programNode3, additionalProgramNodes);
}

// src/index.ts
function rootNodeFromAnchor(idl) {
  return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());
}
function rootNodeFromAnchorWithoutDefaultVisitor(idl) {
  if (idl.metadata?.spec === "0.1.0") {
    return rootNodeFromAnchorV01(idl);
  }
  return rootNodeFromAnchorV00(idl);
}

export { accountNodeFromAnchorV00, accountNodeFromAnchorV01, arrayTypeNodeFromAnchorV00, arrayTypeNodeFromAnchorV01, defaultVisitor, definedTypeNodeFromAnchorV00, definedTypeNodeFromAnchorV01, enumEmptyVariantTypeNodeFromAnchorV00, enumEmptyVariantTypeNodeFromAnchorV01, enumStructVariantTypeNodeFromAnchorV00, enumStructVariantTypeNodeFromAnchorV01, enumTupleVariantTypeNodeFromAnchorV00, enumTupleVariantTypeNodeFromAnchorV01, enumTypeNodeFromAnchorV00, enumTypeNodeFromAnchorV01, errorNodeFromAnchorV00, errorNodeFromAnchorV01, extractGenerics, getAnchorAccountDiscriminatorV00, getAnchorDiscriminatorV01, getAnchorInstructionDiscriminatorV00, instructionAccountNodeFromAnchorV00, instructionAccountNodeFromAnchorV01, instructionAccountNodesFromAnchorV00, instructionAccountNodesFromAnchorV01, instructionArgumentNodeFromAnchorV00, instructionArgumentNodeFromAnchorV01, instructionNodeFromAnchorV00, instructionNodeFromAnchorV01, mapTypeNodeFromAnchorV00, optionTypeNodeFromAnchorV00, optionTypeNodeFromAnchorV01, pdaNodeFromAnchorV00, pdaSeedNodeFromAnchorV01, programNodeFromAnchorV00, programNodeFromAnchorV01, rootNodeFromAnchor, rootNodeFromAnchorV00, rootNodeFromAnchorV01, rootNodeFromAnchorWithoutDefaultVisitor, setTypeNodeFromAnchorV00, structFieldTypeNodeFromAnchorV00, structFieldTypeNodeFromAnchorV01, structTypeNodeFromAnchorV00, structTypeNodeFromAnchorV01, tupleTypeNodeFromAnchorV00, tupleTypeNodeFromAnchorV01, typeNodeFromAnchorV00, typeNodeFromAnchorV01, unwrapGenericTypeFromAnchorV01 };
//# sourceMappingURL=index.react-native.mjs.map
//# sourceMappingURL=index.react-native.mjs.map