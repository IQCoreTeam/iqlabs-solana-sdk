'use strict';

var fs = require('fs');
var errors = require('@codama/errors');
var path = require('path');
var visitorsCore = require('@codama/visitors-core');

// src/fragment.ts
function mapFragmentContent(fragment, mapContent) {
  return setFragmentContent(fragment, mapContent(fragment.content));
}
async function mapFragmentContentAsync(fragment, mapContent) {
  return setFragmentContent(fragment, await mapContent(fragment.content));
}
function setFragmentContent(fragment, content) {
  return Object.freeze({ ...fragment, content });
}
function createFragmentTemplate(template, items, isFragment, mergeFragments) {
  const fragments = items.filter(isFragment);
  const zippedItems = items.map((item, i) => {
    const itemPrefix = template[i];
    if (typeof item === "undefined") return itemPrefix;
    if (isFragment(item)) return itemPrefix + item.content;
    return itemPrefix + String(item);
  });
  return mergeFragments(fragments, () => zippedItems.join("") + template[template.length - 1]);
}
function joinPath(...paths) {
  return path.join(...paths);
}
function pathDirectory(path$1) {
  return path.dirname(path$1);
}

// src/fs.ts
function createDirectory(path) {
  fs.mkdirSync(path, { recursive: true });
}
function deleteDirectory(path) {
  if (fs.existsSync(path)) {
    fs.rmSync(path, { recursive: true });
  }
}
function writeFile(path, content) {
  const directory = pathDirectory(path);
  if (!fs.existsSync(directory)) {
    createDirectory(directory);
  }
  fs.writeFileSync(path, content);
}
function fileExists(path) {
  return fs.existsSync(path);
}
function readFile(path) {
  return fs.readFileSync(path, "utf-8");
}
function readJson(path) {
  return JSON.parse(readFile(path));
}
function createRenderMap(pathOrEntries, content) {
  let entries = [];
  if (typeof pathOrEntries === "string" && pathOrEntries !== void 0 && content !== void 0) {
    entries = [[pathOrEntries, content]];
  } else if (typeof pathOrEntries === "object" && pathOrEntries !== null) {
    entries = Object.entries(pathOrEntries).flatMap(
      ([key, value]) => value === void 0 ? [] : [[key, value]]
    );
  }
  return Object.freeze(new Map(entries));
}
function addToRenderMap(renderMap, path, content) {
  return mergeRenderMaps([renderMap, createRenderMap(path, content)]);
}
function removeFromRenderMap(renderMap, path) {
  const newMap = new Map(renderMap);
  newMap.delete(path);
  return Object.freeze(newMap);
}
function mergeRenderMaps(renderMaps) {
  if (renderMaps.length === 0) return createRenderMap();
  if (renderMaps.length === 1) return renderMaps[0];
  const merged = new Map(renderMaps[0]);
  for (const map of renderMaps.slice(1)) {
    for (const [key, value] of map) {
      merged.set(key, value);
    }
  }
  return Object.freeze(merged);
}
function mapRenderMapFragment(renderMap, fn) {
  return Object.freeze(new Map([...[...renderMap.entries()].map(([key, value]) => [key, fn(value, key)])]));
}
async function mapRenderMapFragmentAsync(renderMap, fn) {
  return Object.freeze(
    new Map(
      await Promise.all([
        ...[...renderMap.entries()].map(async ([key, value]) => [key, await fn(value, key)])
      ])
    )
  );
}
function mapRenderMapContent(renderMap, fn) {
  return mapRenderMapFragment(
    renderMap,
    (fragment, path) => mapFragmentContent(fragment, (content) => fn(content, path))
  );
}
async function mapRenderMapContentAsync(renderMap, fn) {
  return await mapRenderMapFragmentAsync(
    renderMap,
    (fragment, path) => mapFragmentContentAsync(fragment, (content) => fn(content, path))
  );
}
function getFromRenderMap(renderMap, path) {
  const value = renderMap.get(path);
  if (value === void 0) {
    throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key: path });
  }
  return value;
}
function renderMapContains(renderMap, path, value) {
  const { content } = getFromRenderMap(renderMap, path);
  return typeof value === "string" ? content.includes(value) : value.test(content);
}
function writeRenderMap(renderMap, basePath) {
  renderMap.forEach(({ content }, relativePath) => {
    writeFile(joinPath(basePath, relativePath), content);
  });
}
function writeRenderMapVisitor(visitor, basePath) {
  return visitorsCore.mapVisitor(visitor, (renderMap) => writeRenderMap(renderMap, basePath));
}

exports.addToRenderMap = addToRenderMap;
exports.createDirectory = createDirectory;
exports.createFragmentTemplate = createFragmentTemplate;
exports.createRenderMap = createRenderMap;
exports.deleteDirectory = deleteDirectory;
exports.fileExists = fileExists;
exports.getFromRenderMap = getFromRenderMap;
exports.joinPath = joinPath;
exports.mapFragmentContent = mapFragmentContent;
exports.mapFragmentContentAsync = mapFragmentContentAsync;
exports.mapRenderMapContent = mapRenderMapContent;
exports.mapRenderMapContentAsync = mapRenderMapContentAsync;
exports.mapRenderMapFragment = mapRenderMapFragment;
exports.mapRenderMapFragmentAsync = mapRenderMapFragmentAsync;
exports.mergeRenderMaps = mergeRenderMaps;
exports.pathDirectory = pathDirectory;
exports.readFile = readFile;
exports.readJson = readJson;
exports.removeFromRenderMap = removeFromRenderMap;
exports.renderMapContains = renderMapContains;
exports.setFragmentContent = setFragmentContent;
exports.writeFile = writeFile;
exports.writeRenderMap = writeRenderMap;
exports.writeRenderMapVisitor = writeRenderMapVisitor;
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map