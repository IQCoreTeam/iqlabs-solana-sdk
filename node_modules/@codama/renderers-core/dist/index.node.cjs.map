{"version":3,"sources":["../src/fragment.ts","../src/path.ts","../src/fs.ts","../src/renderMap.ts"],"names":["join","path","dirname","mkdirSync","existsSync","rmSync","writeFileSync","readFileSync","CodamaError","CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND","mapVisitor"],"mappings":"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","file":"index.node.cjs","sourcesContent":["export type BaseFragment = Readonly<{ content: string }>;\n\nexport function mapFragmentContent<TFragment extends BaseFragment>(\n    fragment: TFragment,\n    mapContent: (content: string) => string,\n): TFragment {\n    return setFragmentContent(fragment, mapContent(fragment.content));\n}\n\nexport async function mapFragmentContentAsync<TFragment extends BaseFragment>(\n    fragment: TFragment,\n    mapContent: (content: string) => Promise<string>,\n): Promise<TFragment> {\n    return setFragmentContent(fragment, await mapContent(fragment.content));\n}\n\nexport function setFragmentContent<TFragment extends BaseFragment>(fragment: TFragment, content: string): TFragment {\n    return Object.freeze({ ...fragment, content });\n}\n\nexport function createFragmentTemplate<TFragment extends BaseFragment>(\n    template: TemplateStringsArray,\n    items: unknown[],\n    isFragment: (value: unknown) => value is TFragment,\n    mergeFragments: (fragments: TFragment[], mergeContent: (contents: string[]) => string) => TFragment,\n): TFragment {\n    const fragments = items.filter(isFragment);\n    const zippedItems = items.map((item, i) => {\n        const itemPrefix = template[i];\n        if (typeof item === 'undefined') return itemPrefix;\n        if (isFragment(item)) return itemPrefix + item.content;\n        return itemPrefix + String(item as string);\n    });\n    return mergeFragments(fragments, () => zippedItems.join('') + template[template.length - 1]);\n}\n","import { dirname, join } from 'node:path';\n\nexport type Path = string;\n\nexport function joinPath(...paths: Path[]): string {\n    if (!__NODEJS__) {\n        return paths.join('/').replace(/\\/+/g, '/');\n    }\n\n    return join(...paths);\n}\n\nexport function pathDirectory(path: Path): Path {\n    if (!__NODEJS__) {\n        return path.substring(0, path.lastIndexOf('/'));\n    }\n\n    return dirname(path);\n}\n","import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from 'node:fs';\n\nimport { CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, CodamaError } from '@codama/errors';\n\nimport { Path, pathDirectory } from './path';\n\nexport function createDirectory(path: Path): void {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'mkdirSync' });\n    }\n\n    mkdirSync(path, { recursive: true });\n}\n\nexport function deleteDirectory(path: Path): void {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'rmSync' });\n    }\n\n    if (existsSync(path)) {\n        rmSync(path, { recursive: true });\n    }\n}\n\nexport function writeFile(path: Path, content: string): void {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'writeFileSync' });\n    }\n\n    const directory = pathDirectory(path);\n    if (!existsSync(directory)) {\n        createDirectory(directory);\n    }\n    writeFileSync(path, content);\n}\n\nexport function fileExists(path: Path): boolean {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'existsSync' });\n    }\n\n    return existsSync(path);\n}\n\nexport function readFile(path: Path): string {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'readFileSync' });\n    }\n\n    return readFileSync(path, 'utf-8');\n}\n\nexport function readJson<T>(path: Path): T {\n    return JSON.parse(readFile(path)) as T;\n}\n","import { CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, CodamaError } from '@codama/errors';\nimport { NodeKind } from '@codama/nodes';\nimport { mapVisitor, Visitor } from '@codama/visitors-core';\n\nimport { BaseFragment, mapFragmentContent, mapFragmentContentAsync } from './fragment';\nimport { writeFile } from './fs';\nimport { joinPath, Path } from './path';\n\nexport type RenderMap<TFragment extends BaseFragment> = ReadonlyMap<Path, TFragment>;\n\nexport function createRenderMap<TFragment extends BaseFragment = BaseFragment>(): RenderMap<TFragment>;\nexport function createRenderMap<TFragment extends BaseFragment>(path: Path, content: TFragment): RenderMap<TFragment>;\nexport function createRenderMap<TFragment extends BaseFragment>(\n    entries: Record<Path, TFragment | undefined>,\n): RenderMap<TFragment>;\nexport function createRenderMap<TFragment extends BaseFragment>(\n    pathOrEntries?: Path | Record<Path, TFragment | undefined>,\n    content?: TFragment,\n): RenderMap<TFragment> {\n    let entries: [Path, TFragment][] = [];\n    if (typeof pathOrEntries === 'string' && pathOrEntries !== undefined && content !== undefined) {\n        entries = [[pathOrEntries, content]];\n    } else if (typeof pathOrEntries === 'object' && pathOrEntries !== null) {\n        entries = Object.entries(pathOrEntries).flatMap(([key, value]) =>\n            value === undefined ? [] : ([[key, value]] as const),\n        );\n    }\n    return Object.freeze(new Map(entries));\n}\n\nexport function addToRenderMap<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    path: Path,\n    content: TFragment,\n): RenderMap<TFragment> {\n    return mergeRenderMaps([renderMap, createRenderMap(path, content)]);\n}\n\nexport function removeFromRenderMap<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    path: Path,\n): RenderMap<TFragment> {\n    const newMap = new Map(renderMap);\n    newMap.delete(path);\n    return Object.freeze(newMap);\n}\n\nexport function mergeRenderMaps<TFragment extends BaseFragment>(\n    renderMaps: RenderMap<TFragment>[],\n): RenderMap<TFragment> {\n    if (renderMaps.length === 0) return createRenderMap();\n    if (renderMaps.length === 1) return renderMaps[0];\n    const merged = new Map(renderMaps[0]);\n    for (const map of renderMaps.slice(1)) {\n        for (const [key, value] of map) {\n            merged.set(key, value);\n        }\n    }\n    return Object.freeze(merged);\n}\n\nexport function mapRenderMapFragment<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    fn: (fragment: TFragment, path: Path) => TFragment,\n): RenderMap<TFragment> {\n    return Object.freeze(new Map([...[...renderMap.entries()].map(([key, value]) => [key, fn(value, key)] as const)]));\n}\n\nexport async function mapRenderMapFragmentAsync<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    fn: (fragment: TFragment, path: Path) => Promise<TFragment>,\n): Promise<RenderMap<TFragment>> {\n    return Object.freeze(\n        new Map(\n            await Promise.all([\n                ...[...renderMap.entries()].map(async ([key, value]) => [key, await fn(value, key)] as const),\n            ]),\n        ),\n    );\n}\n\nexport function mapRenderMapContent<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    fn: (content: string, path: Path) => string,\n): RenderMap<TFragment> {\n    return mapRenderMapFragment(renderMap, (fragment, path) =>\n        mapFragmentContent(fragment, content => fn(content, path)),\n    );\n}\n\nexport async function mapRenderMapContentAsync<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    fn: (content: string, path: Path) => Promise<string>,\n): Promise<RenderMap<TFragment>> {\n    return await mapRenderMapFragmentAsync(renderMap, (fragment, path) =>\n        mapFragmentContentAsync(fragment, content => fn(content, path)),\n    );\n}\n\nexport function getFromRenderMap<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    path: Path,\n): TFragment {\n    const value = renderMap.get(path);\n    if (value === undefined) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key: path });\n    }\n    return value;\n}\n\nexport function renderMapContains<TFragment extends BaseFragment>(\n    renderMap: RenderMap<TFragment>,\n    path: Path,\n    value: RegExp | string,\n): boolean {\n    const { content } = getFromRenderMap(renderMap, path);\n    return typeof value === 'string' ? content.includes(value) : value.test(content);\n}\n\nexport function writeRenderMap<TFragment extends BaseFragment>(renderMap: RenderMap<TFragment>, basePath: Path): void {\n    renderMap.forEach(({ content }, relativePath) => {\n        writeFile(joinPath(basePath, relativePath), content);\n    });\n}\n\nexport function writeRenderMapVisitor<\n    TFragment extends BaseFragment = BaseFragment,\n    TNodeKind extends NodeKind = NodeKind,\n>(visitor: Visitor<RenderMap<TFragment>, TNodeKind>, basePath: Path): Visitor<void, TNodeKind> {\n    return mapVisitor(visitor, renderMap => writeRenderMap(renderMap, basePath));\n}\n"]}