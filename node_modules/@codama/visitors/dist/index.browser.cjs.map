{"version":3,"sources":["../src/addPdasVisitor.ts","../src/flattenInstructionDataArgumentsVisitor.ts","../src/createSubInstructionsFromEnumArgsVisitor.ts","../src/deduplicateIdenticalDefinedTypesVisitor.ts","../src/fillDefaultPdaSeedValuesVisitor.ts","../src/flattenStructVisitor.ts","../src/getDefinedTypeHistogramVisitor.ts","../src/setAccountDiscriminatorFromFieldVisitor.ts","../src/setFixedAccountSizesVisitor.ts","../src/setInstructionAccountDefaultValuesVisitor.ts","../src/setInstructionDiscriminatorsVisitor.ts","../src/setNumberWrappersVisitor.ts","../src/setStructDefaultValuesVisitor.ts","../src/transformDefinedTypesIntoAccountsVisitor.ts","../src/transformU8ArraysToBytesVisitor.ts","../src/unwrapDefinedTypesVisitor.ts","../src/unwrapInstructionArgsDefinedTypesVisitor.ts","../src/unwrapTupleEnumWithSingleStructVisitor.ts","../src/unwrapTypeDefinedLinksVisitor.ts","../src/renameHelpers.ts","../src/updateAccountsVisitor.ts","../src/updateDefinedTypesVisitor.ts","../src/updateErrorsVisitor.ts","../src/updateInstructionsVisitor.ts","../src/updateProgramsVisitor.ts"],"names":["bottomUpTransformerVisitor","camelCase","assertIsNode","CodamaError","CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES","programNode","pdaNode","instructionNode","nodes","isNode","instructionArgumentNode","CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES","LinkableDictionary","CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND","numberValueNode","numberTypeNode","pipe","recordLinkablesOnFirstVisitVisitor","rootNodeVisitor","getAllPrograms","getUniqueHashStringVisitor","visit","deleteNodesVisitor","getLastNodeFromPath","identityVisitor","INSTRUCTION_INPUT_VALUE_NODES","extendVisitor","CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES","pdaValueNode","pdaSeedValueNode","accountValueNode","getAllInstructionArguments","argumentValueNode","isNodeFilter","structTypeNode","NodeStack","mergeVisitor","interceptVisitor","findProgramNodeFromPath","recordNodeStackVisitor","resolveNestedTypeNode","CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND","accountNode","transformNestedTypeNode","structFieldTypeNode","fieldDiscriminatorNode","topDownTransformerVisitor","isNodePath","getByteSizeVisitor","payerValueNode","identityValueNode","programIdValueNode","publicKeyValueNode","nonNullableIdentityVisitor","assertIsNestedTypeNode","dateTimeTypeNode","solAmountTypeNode","amountTypeNode","CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER","TYPE_NODES","fixedSizeTypeNode","bytesTypeNode","arrayTypeNode","assertIsNodeFilter","getRecordLinkablesVisitor","definedTypeLinkNode","getNodeSelectorFunction","REGISTERED_NODE_KINDS","getAllDefinedTypes","enumStructVariantTypeNode","enumTypeNode","enumTupleVariantTypeNode","enumEmptyVariantTypeNode","pdaLinkNode","accountLinkNode","definedTypeNode","errorNode","instructionAccountNode","programLinkNode"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES, CodamaError } from '@codama/errors';\nimport { assertIsNode, camelCase, pdaNode, PdaNodeInput, programNode } from '@codama/nodes';\nimport { bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function addPdasVisitor(pdas: Record<string, Omit<PdaNodeInput, 'programId'>[]>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(pdas).map(([uncasedProgramName, newPdas]) => {\n            const programName = camelCase(uncasedProgramName);\n            return {\n                select: `[programNode]${programName}`,\n                transform: node => {\n                    assertIsNode(node, 'programNode');\n                    const existingPdaNames = new Set(node.pdas.map(pda => pda.name));\n                    const newPdaNames = new Set(newPdas.map(pda => pda.name));\n                    const overlappingPdaNames = new Set([...existingPdaNames].filter(name => newPdaNames.has(name)));\n                    if (overlappingPdaNames.size > 0) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES, {\n                            duplicatedPdaNames: [...overlappingPdaNames],\n                            program: node,\n                            programName: node.name,\n                        });\n                    }\n                    return programNode({\n                        ...node,\n                        pdas: [...node.pdas, ...newPdas.map(({ name, seeds, docs }) => pdaNode({ docs, name, seeds }))],\n                    });\n                },\n            };\n        }),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    instructionNode,\n    isNode,\n} from '@codama/nodes';\nimport { bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function flattenInstructionDataArgumentsVisitor() {\n    return bottomUpTransformerVisitor([\n        {\n            select: '[instructionNode]',\n            transform: instruction => {\n                assertIsNode(instruction, 'instructionNode');\n                return instructionNode({\n                    ...instruction,\n                    arguments: flattenInstructionArguments(instruction.arguments),\n                });\n            },\n        },\n    ]);\n}\n\nexport type FlattenInstructionArgumentsConfig = string[] | '*';\n\nexport const flattenInstructionArguments = (\n    nodes: InstructionArgumentNode[],\n    options: FlattenInstructionArgumentsConfig = '*',\n): InstructionArgumentNode[] => {\n    const camelCaseOptions = options === '*' ? options : options.map(camelCase);\n    const shouldInline = (node: InstructionArgumentNode): boolean =>\n        options === '*' || camelCaseOptions.includes(camelCase(node.name));\n    const inlinedArguments = nodes.flatMap(node => {\n        if (isNode(node.type, 'structTypeNode') && shouldInline(node)) {\n            return node.type.fields.map(field => instructionArgumentNode({ ...field }));\n        }\n        return node;\n    });\n\n    const inlinedFieldsNames = inlinedArguments.map(arg => arg.name);\n    const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);\n    const uniqueDuplicates = [...new Set(duplicates)];\n    const hasConflictingNames = uniqueDuplicates.length > 0;\n\n    if (hasConflictingNames) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {\n            conflictingAttributes: uniqueDuplicates,\n        });\n    }\n\n    return hasConflictingNames ? nodes : inlinedArguments;\n};\n","import { CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    EnumTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    isNode,\n    numberTypeNode,\n    numberValueNode,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n} from '@codama/visitors-core';\n\nimport { flattenInstructionArguments } from './flattenInstructionDataArgumentsVisitor';\n\nexport function createSubInstructionsFromEnumArgsVisitor(map: Record<string, string>) {\n    const linkables = new LinkableDictionary();\n\n    const visitor = bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, argNameInput]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[instructionNode]', selector],\n                transform: (node, stack) => {\n                    assertIsNode(node, 'instructionNode');\n\n                    const argFields = node.arguments;\n                    const argName = camelCase(argNameInput);\n                    const argFieldIndex = argFields.findIndex(field => field.name === argName);\n                    const argField = argFieldIndex >= 0 ? argFields[argFieldIndex] : null;\n                    if (!argField) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {\n                            argumentName: argName,\n                            instruction: node,\n                            instructionName: node.name,\n                        });\n                    }\n\n                    let argType: EnumTypeNode;\n                    if (isNode(argField.type, 'enumTypeNode')) {\n                        argType = argField.type;\n                    } else if (\n                        isNode(argField.type, 'definedTypeLinkNode') &&\n                        linkables.has([...stack.getPath(), argField.type])\n                    ) {\n                        const linkedType = linkables.get([...stack.getPath(), argField.type])?.type;\n                        assertIsNode(linkedType, 'enumTypeNode');\n                        argType = linkedType;\n                    } else {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {\n                            argumentName: argName,\n                            instruction: node,\n                            instructionName: node.name,\n                        });\n                    }\n\n                    const subInstructions = argType.variants.map((variant, index): InstructionNode => {\n                        const subName = camelCase(`${node.name} ${variant.name}`);\n                        const subFields = argFields.slice(0, argFieldIndex);\n                        subFields.push(\n                            instructionArgumentNode({\n                                defaultValue: numberValueNode(index),\n                                defaultValueStrategy: 'omitted',\n                                name: `${subName}Discriminator`,\n                                type: numberTypeNode('u8'),\n                            }),\n                        );\n                        if (isNode(variant, 'enumStructVariantTypeNode')) {\n                            subFields.push(\n                                instructionArgumentNode({\n                                    ...argField,\n                                    type: variant.struct,\n                                }),\n                            );\n                        } else if (isNode(variant, 'enumTupleVariantTypeNode')) {\n                            subFields.push(\n                                instructionArgumentNode({\n                                    ...argField,\n                                    type: variant.tuple,\n                                }),\n                            );\n                        }\n                        subFields.push(...argFields.slice(argFieldIndex + 1));\n\n                        return instructionNode({\n                            ...node,\n                            arguments: flattenInstructionArguments(subFields),\n                            name: subName,\n                        });\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        subInstructions: [...(node.subInstructions ?? []), ...subInstructions],\n                    });\n                },\n            }),\n        ),\n    );\n\n    return pipe(visitor, v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import { assertIsNode, DefinedTypeNode, getAllPrograms, ProgramNode } from '@codama/nodes';\nimport {\n    deleteNodesVisitor,\n    getUniqueHashStringVisitor,\n    NodeSelector,\n    rootNodeVisitor,\n    visit,\n} from '@codama/visitors-core';\n\ntype DefinedTypeWithProgram = {\n    program: ProgramNode;\n    type: DefinedTypeNode;\n};\n\nexport function deduplicateIdenticalDefinedTypesVisitor() {\n    return rootNodeVisitor(root => {\n        const typeMap = new Map<string, DefinedTypeWithProgram[]>();\n\n        // Fill the type map with all defined types.\n        const allPrograms = getAllPrograms(root);\n        allPrograms.forEach(program => {\n            program.definedTypes.forEach(type => {\n                const typeWithProgram = { program, type };\n                const list = typeMap.get(type.name) ?? [];\n                typeMap.set(type.name, [...list, typeWithProgram]);\n            });\n        });\n\n        // Remove all types that are not duplicated.\n        typeMap.forEach((list, name) => {\n            if (list.length <= 1) {\n                typeMap.delete(name);\n            }\n        });\n\n        // Remove duplicates whose types are not equal.\n        const hashVisitor = getUniqueHashStringVisitor({ removeDocs: true });\n        typeMap.forEach((list, name) => {\n            const types = list.map(item => visit(item.type, hashVisitor));\n            const typesAreEqual = types.every((type, _, arr) => type === arr[0]);\n            if (!typesAreEqual) {\n                typeMap.delete(name);\n            }\n        });\n\n        // Get the selectors for all defined types that needs deleting.\n        // Thus, we must select all but the first duplicate of each list.\n        const deleteSelectors = Array.from(typeMap.values())\n            // Order lists by program index, get their tails and flatten.\n            .flatMap(list => {\n                const sortedList = list.sort((a, b) => allPrograms.indexOf(a.program) - allPrograms.indexOf(b.program));\n                const [, ...sortedListTail] = sortedList;\n                return sortedListTail;\n            })\n            // Get selectors from the defined types and their programs.\n            .map(({ program, type }): NodeSelector => `[programNode]${program.name}.[definedTypeNode]${type.name}`);\n\n        // Delete the identified nodes if any.\n        if (deleteSelectors.length > 0) {\n            const newRoot = visit(root, deleteNodesVisitor(deleteSelectors));\n            assertIsNode(newRoot, 'rootNode');\n            return newRoot;\n        }\n\n        return root;\n    });\n}\n","import { CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES, CodamaError } from '@codama/errors';\nimport {\n    accountValueNode,\n    argumentValueNode,\n    assertIsNode,\n    getAllInstructionArguments,\n    INSTRUCTION_INPUT_VALUE_NODES,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n    isNodeFilter,\n    PdaNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    pdaValueNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    getLastNodeFromPath,\n    identityVisitor,\n    LinkableDictionary,\n    NodePath,\n    pipe,\n    Visitor,\n} from '@codama/visitors-core';\n\n/**\n * Fills in default values for variable PDA seeds that are not explicitly provided.\n * Namely, public key seeds are filled with an accountValueNode using the seed name\n * and other types of seeds are filled with an argumentValueNode using the seed name.\n *\n * An instruction and linkable dictionary are required to determine which seeds are\n * valids and to find the pdaLinkNode for the seed respectively. Any invalid default\n * seed won't be filled in.\n *\n * Strict mode goes one step further and will throw an error if the final array of\n * pdaSeedValueNodes contains invalid seeds or if there aren't enough variable seeds.\n */\nexport function fillDefaultPdaSeedValuesVisitor(\n    instructionPath: NodePath<InstructionNode>,\n    linkables: LinkableDictionary,\n    strictMode: boolean = false,\n) {\n    const instruction = getLastNodeFromPath(instructionPath);\n    return pipe(identityVisitor({ keys: INSTRUCTION_INPUT_VALUE_NODES }), v =>\n        extendVisitor(v, {\n            visitPdaValue(node, { next }) {\n                const visitedNode = next(node);\n                assertIsNode(visitedNode, 'pdaValueNode');\n                const foundPda = isNode(visitedNode.pda, 'pdaNode')\n                    ? visitedNode.pda\n                    : linkables.get([...instructionPath, visitedNode.pda]);\n                if (!foundPda) return visitedNode;\n                const seeds = addDefaultSeedValuesFromPdaWhenMissing(instruction, foundPda, visitedNode.seeds);\n                if (strictMode && !allSeedsAreValid(instruction, foundPda, seeds)) {\n                    throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES, {\n                        instruction,\n                        instructionName: instruction.name,\n                        pda: foundPda,\n                        pdaName: foundPda.name,\n                    });\n                }\n                return pdaValueNode(visitedNode.pda, seeds);\n            },\n        }),\n    ) as Visitor<InstructionInputValueNode, InstructionInputValueNode['kind']>;\n}\n\nfunction addDefaultSeedValuesFromPdaWhenMissing(\n    instruction: InstructionNode,\n    pda: PdaNode,\n    existingSeeds: PdaSeedValueNode[],\n): PdaSeedValueNode[] {\n    const existingSeedNames = new Set(existingSeeds.map(seed => seed.name));\n    const defaultSeeds = getDefaultSeedValuesFromPda(instruction, pda).filter(\n        seed => !existingSeedNames.has(seed.name),\n    );\n    return [...existingSeeds, ...defaultSeeds];\n}\n\nfunction getDefaultSeedValuesFromPda(instruction: InstructionNode, pda: PdaNode): PdaSeedValueNode[] {\n    return pda.seeds.flatMap((seed): PdaSeedValueNode[] => {\n        if (!isNode(seed, 'variablePdaSeedNode')) return [];\n\n        const hasMatchingAccount = instruction.accounts.some(a => a.name === seed.name);\n        if (isNode(seed.type, 'publicKeyTypeNode') && hasMatchingAccount) {\n            return [pdaSeedValueNode(seed.name, accountValueNode(seed.name))];\n        }\n\n        const hasMatchingArgument = getAllInstructionArguments(instruction).some(a => a.name === seed.name);\n        if (hasMatchingArgument) {\n            return [pdaSeedValueNode(seed.name, argumentValueNode(seed.name))];\n        }\n\n        return [];\n    });\n}\n\nfunction allSeedsAreValid(instruction: InstructionNode, foundPda: PdaNode, seeds: PdaSeedValueNode[]) {\n    const hasAllVariableSeeds = foundPda.seeds.filter(isNodeFilter('variablePdaSeedNode')).length === seeds.length;\n    const allAccountsName = instruction.accounts.map(a => a.name);\n    const allArgumentsName = getAllInstructionArguments(instruction).map(a => a.name);\n    const validSeeds = seeds.every(seed => {\n        if (isNode(seed.value, 'accountValueNode')) {\n            return allAccountsName.includes(seed.value.name);\n        }\n        if (isNode(seed.value, 'argumentValueNode')) {\n            return allArgumentsName.includes(seed.value.name);\n        }\n        return true;\n    });\n\n    return hasAllVariableSeeds && validSeeds;\n}\n","import { CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    isNode,\n    Node,\n    StructFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type FlattenStructOptions = string[] | '*';\n\nexport function flattenStructVisitor(map: Record<string, FlattenStructOptions>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([stack, options]): BottomUpNodeTransformerWithSelector => ({\n                select: `${stack}.[structTypeNode]`,\n                transform: node => flattenStruct(node, options),\n            }),\n        ),\n    );\n}\n\nexport const flattenStruct = (node: Node, options: FlattenStructOptions = '*'): StructTypeNode => {\n    assertIsNode(node, 'structTypeNode');\n    const camelCaseOptions = options === '*' ? options : options.map(camelCase);\n    const shouldInline = (field: StructFieldTypeNode): boolean =>\n        options === '*' || camelCaseOptions.includes(camelCase(field.name));\n    const inlinedFields = node.fields.flatMap(field => {\n        if (isNode(field.type, 'structTypeNode') && shouldInline(field)) {\n            return field.type.fields;\n        }\n        return [field];\n    });\n\n    const inlinedFieldsNames = inlinedFields.map(arg => arg.name);\n    const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);\n    const uniqueDuplicates = [...new Set(duplicates)];\n    const hasConflictingNames = uniqueDuplicates.length > 0;\n\n    if (hasConflictingNames) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {\n            conflictingAttributes: uniqueDuplicates,\n        });\n    }\n\n    return hasConflictingNames ? node : structTypeNode(inlinedFields);\n};\n","import { CamelCaseString } from '@codama/nodes';\nimport {\n    extendVisitor,\n    findProgramNodeFromPath,\n    interceptVisitor,\n    mergeVisitor,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\ntype DefinedTypeHistogramKey = CamelCaseString | `${CamelCaseString}.${CamelCaseString}`;\n\nexport type DefinedTypeHistogram = {\n    [key: DefinedTypeHistogramKey]: {\n        directlyAsInstructionArgs: number;\n        inAccounts: number;\n        inDefinedTypes: number;\n        inInstructionArgs: number;\n        total: number;\n    };\n};\n\nfunction mergeHistograms(histograms: DefinedTypeHistogram[]): DefinedTypeHistogram {\n    const result: DefinedTypeHistogram = {};\n\n    histograms.forEach(histogram => {\n        Object.keys(histogram).forEach(key => {\n            const mainCaseKey = key as CamelCaseString;\n            if (result[mainCaseKey] === undefined) {\n                result[mainCaseKey] = histogram[mainCaseKey];\n            } else {\n                result[mainCaseKey].total += histogram[mainCaseKey].total;\n                result[mainCaseKey].inAccounts += histogram[mainCaseKey].inAccounts;\n                result[mainCaseKey].inDefinedTypes += histogram[mainCaseKey].inDefinedTypes;\n                result[mainCaseKey].inInstructionArgs += histogram[mainCaseKey].inInstructionArgs;\n                result[mainCaseKey].directlyAsInstructionArgs += histogram[mainCaseKey].directlyAsInstructionArgs;\n            }\n        });\n    });\n\n    return result;\n}\n\nexport function getDefinedTypeHistogramVisitor(): Visitor<DefinedTypeHistogram> {\n    const stack = new NodeStack();\n    let mode: 'account' | 'definedType' | 'instruction' | null = null;\n    let stackLevel = 0;\n\n    return pipe(\n        mergeVisitor(\n            () => ({}) as DefinedTypeHistogram,\n            (_, histograms) => mergeHistograms(histograms),\n        ),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                stackLevel += 1;\n                const newNode = next(node);\n                stackLevel -= 1;\n                return newNode;\n            }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node, { self }) {\n                    mode = 'account';\n                    stackLevel = 0;\n                    const histogram = visit(node.data, self);\n                    mode = null;\n                    return histogram;\n                },\n\n                visitDefinedType(node, { self }) {\n                    mode = 'definedType';\n                    stackLevel = 0;\n                    const histogram = visit(node.type, self);\n                    mode = null;\n                    return histogram;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const program = findProgramNodeFromPath(stack.getPath());\n                    const key = program ? `${program.name}.${node.name}` : node.name;\n                    return {\n                        [key]: {\n                            directlyAsInstructionArgs: Number(mode === 'instruction' && stackLevel <= 1),\n                            inAccounts: Number(mode === 'account'),\n                            inDefinedTypes: Number(mode === 'definedType'),\n                            inInstructionArgs: Number(mode === 'instruction'),\n                            total: 1,\n                        },\n                    };\n                },\n\n                visitInstruction(node, { self }) {\n                    mode = 'instruction';\n                    stackLevel = 0;\n                    const dataHistograms = node.arguments.map(arg => visit(arg, self));\n                    const extraHistograms = (node.extraArguments ?? []).map(arg => visit(arg, self));\n                    mode = null;\n                    const subHistograms = (node.subInstructions ?? []).map(ix => visit(ix, self));\n                    return mergeHistograms([...dataHistograms, ...extraHistograms, ...subHistograms]);\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND, CodamaError } from '@codama/errors';\nimport {\n    accountNode,\n    assertIsNode,\n    fieldDiscriminatorNode,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    transformNestedTypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function setAccountDiscriminatorFromFieldVisitor(\n    map: Record<string, { field: string; offset?: number; value: ValueNode }>,\n) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, { field, value, offset }]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[accountNode]', selector],\n                transform: node => {\n                    assertIsNode(node, 'accountNode');\n\n                    const accountData = resolveNestedTypeNode(node.data);\n                    const fieldIndex = accountData.fields.findIndex(f => f.name === field);\n                    if (fieldIndex < 0) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND, {\n                            account: node,\n                            missingField: field,\n                            name: node.name,\n                        });\n                    }\n\n                    const fieldNode = accountData.fields[fieldIndex];\n                    return accountNode({\n                        ...node,\n                        data: transformNestedTypeNode(node.data, () =>\n                            structTypeNode([\n                                ...accountData.fields.slice(0, fieldIndex),\n                                structFieldTypeNode({\n                                    ...fieldNode,\n                                    defaultValue: value,\n                                    defaultValueStrategy: 'omitted',\n                                }),\n                                ...accountData.fields.slice(fieldIndex + 1),\n                            ]),\n                        ),\n                        discriminators: [fieldDiscriminatorNode(field, offset), ...(node.discriminators ?? [])],\n                    });\n                },\n            }),\n        ),\n    );\n}\n","import { accountNode, assertIsNode } from '@codama/nodes';\nimport {\n    getByteSizeVisitor,\n    getLastNodeFromPath,\n    isNodePath,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    topDownTransformerVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nexport function setFixedAccountSizesVisitor() {\n    const linkables = new LinkableDictionary();\n\n    const visitor = topDownTransformerVisitor(\n        [\n            {\n                select: path => isNodePath(path, 'accountNode') && getLastNodeFromPath(path).size === undefined,\n                transform: (node, stack) => {\n                    assertIsNode(node, 'accountNode');\n                    const size = visit(node.data, getByteSizeVisitor(linkables, { stack }));\n                    if (size === null) return node;\n                    return accountNode({ ...node, size }) as typeof node;\n                },\n            },\n        ],\n        { keys: ['rootNode', 'programNode', 'accountNode'] },\n    );\n\n    return pipe(visitor, v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import {\n    camelCase,\n    identityValueNode,\n    InstructionAccountNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    instructionNode,\n    payerValueNode,\n    programIdValueNode,\n    publicKeyValueNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    LinkableDictionary,\n    NodeStack,\n    nonNullableIdentityVisitor,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { fillDefaultPdaSeedValuesVisitor } from './fillDefaultPdaSeedValuesVisitor';\n\nexport type InstructionAccountDefaultRule = {\n    /** The name of the instruction account or a pattern to match on it. */\n    account: RegExp | string;\n    /** The default value to assign to it. */\n    defaultValue: InstructionInputValueNode;\n    /** @defaultValue `false`. */\n    ignoreIfOptional?: boolean;\n    /** @defaultValue Defaults to searching accounts on all instructions. */\n    instruction?: string;\n};\n\nexport const getCommonInstructionAccountDefaultRules = (): InstructionAccountDefaultRule[] => [\n    {\n        account: /^(payer|feePayer)$/,\n        defaultValue: payerValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(authority)$/,\n        defaultValue: identityValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(programId)$/,\n        defaultValue: programIdValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(systemProgram|splSystemProgram)$/,\n        defaultValue: publicKeyValueNode('11111111111111111111111111111111', 'splSystem'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenProgram|splTokenProgram)$/,\n        defaultValue: publicKeyValueNode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA', 'splToken'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(ataProgram|splAtaProgram)$/,\n        defaultValue: publicKeyValueNode('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL', 'splAssociatedToken'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenMetadataProgram|mplTokenMetadataProgram)$/,\n        defaultValue: publicKeyValueNode('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s', 'mplTokenMetadata'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenAuth|mplTokenAuth|authorization|mplAuthorization|auth|mplAuth)RulesProgram$/,\n        defaultValue: publicKeyValueNode('auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg', 'mplTokenAuthRules'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(candyMachineProgram|mplCandyMachineProgram)$/,\n        defaultValue: publicKeyValueNode('CndyV3LdqHUfDLmE5naZjVN8rBZz4tqhdefbAnjHG3JR', 'mplCandyMachine'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(candyGuardProgram|mplCandyGuardProgram)$/,\n        defaultValue: publicKeyValueNode('Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g', 'mplCandyGuard'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(clockSysvar|sysvarClock)$/,\n        defaultValue: publicKeyValueNode('SysvarC1ock11111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(epochScheduleSysvar|sysvarEpochSchedule)$/,\n        defaultValue: publicKeyValueNode('SysvarEpochSchedu1e111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(instructions?Sysvar|sysvarInstructions?)(Account)?$/,\n        defaultValue: publicKeyValueNode('Sysvar1nstructions1111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(recentBlockhashesSysvar|sysvarRecentBlockhashes)$/,\n        defaultValue: publicKeyValueNode('SysvarRecentB1ockHashes11111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(rent|rentSysvar|sysvarRent)$/,\n        defaultValue: publicKeyValueNode('SysvarRent111111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(rewardsSysvar|sysvarRewards)$/,\n        defaultValue: publicKeyValueNode('SysvarRewards111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(slotHashesSysvar|sysvarSlotHashes)$/,\n        defaultValue: publicKeyValueNode('SysvarS1otHashes111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(slotHistorySysvar|sysvarSlotHistory)$/,\n        defaultValue: publicKeyValueNode('SysvarS1otHistory11111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(stakeHistorySysvar|sysvarStakeHistory)$/,\n        defaultValue: publicKeyValueNode('SysvarStakeHistory1111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(mplCoreProgram)$/,\n        defaultValue: publicKeyValueNode('CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d', 'mplCore'),\n        ignoreIfOptional: true,\n    },\n];\n\nexport function setInstructionAccountDefaultValuesVisitor(rules: InstructionAccountDefaultRule[]) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    // Place the rules with instructions first.\n    const sortedRules = rules.sort((a, b) => {\n        const ia = 'instruction' in a;\n        const ib = 'instruction' in b;\n        if ((ia && ib) || (!a && !ib)) return 0;\n        return ia ? -1 : 1;\n    });\n\n    function matchRule(\n        instruction: InstructionNode,\n        account: InstructionAccountNode,\n    ): InstructionAccountDefaultRule | undefined {\n        return sortedRules.find(rule => {\n            if ('instruction' in rule && rule.instruction && camelCase(rule.instruction) !== instruction.name) {\n                return false;\n            }\n            return typeof rule.account === 'string'\n                ? camelCase(rule.account) === account.name\n                : rule.account.test(account.name);\n        });\n    }\n\n    return pipe(\n        nonNullableIdentityVisitor({ keys: ['rootNode', 'programNode', 'instructionNode'] }),\n        v =>\n            extendVisitor(v, {\n                visitInstruction(node) {\n                    const instructionPath = stack.getPath('instructionNode');\n                    const instructionAccounts = node.accounts.map((account): InstructionAccountNode => {\n                        const rule = matchRule(node, account);\n                        if (!rule) return account;\n\n                        if ((rule.ignoreIfOptional ?? false) && (account.isOptional || !!account.defaultValue)) {\n                            return account;\n                        }\n\n                        try {\n                            return {\n                                ...account,\n                                defaultValue: visit(\n                                    rule.defaultValue,\n                                    fillDefaultPdaSeedValuesVisitor(instructionPath, linkables, true),\n                                ),\n                            };\n                        } catch {\n                            return account;\n                        }\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        accounts: instructionAccounts,\n                    });\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import {\n    assertIsNode,\n    fieldDiscriminatorNode,\n    instructionArgumentNode,\n    instructionNode,\n    numberTypeNode,\n    TypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\ntype Discriminator = {\n    /** @defaultValue `[]` */\n    docs?: string[];\n    /** @defaultValue `\"discriminator\"` */\n    name?: string;\n    /** @defaultValue `\"omitted\"` */\n    strategy?: 'omitted' | 'optional';\n    /** @defaultValue `numberTypeNode('u8')` */\n    type?: TypeNode;\n    value: ValueNode;\n};\n\nexport function setInstructionDiscriminatorsVisitor(map: Record<string, Discriminator>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, discriminator]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[instructionNode]', selector],\n                transform: node => {\n                    assertIsNode(node, 'instructionNode');\n                    const discriminatorArgument = instructionArgumentNode({\n                        defaultValue: discriminator.value,\n                        defaultValueStrategy: discriminator.strategy ?? 'omitted',\n                        docs: discriminator.docs ?? [],\n                        name: discriminator.name ?? 'discriminator',\n                        type: discriminator.type ?? numberTypeNode('u8'),\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        arguments: [discriminatorArgument, ...node.arguments],\n                        discriminators: [\n                            fieldDiscriminatorNode(discriminator.name ?? 'discriminator'),\n                            ...(node.discriminators ?? []),\n                        ],\n                    });\n                },\n            }),\n        ),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER, CodamaError } from '@codama/errors';\nimport { amountTypeNode, assertIsNestedTypeNode, dateTimeTypeNode, solAmountTypeNode } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type NumberWrapper =\n    | { decimals: number; kind: 'Amount'; unit?: string }\n    | { kind: 'DateTime' }\n    | { kind: 'SolAmount' };\n\ntype NumberWrapperMap = Record<string, NumberWrapper>;\n\nexport function setNumberWrappersVisitor(map: NumberWrapperMap) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selectorStack, wrapper]): BottomUpNodeTransformerWithSelector => ({\n                select: `${selectorStack}.[numberTypeNode]`,\n                transform: node => {\n                    assertIsNestedTypeNode(node, 'numberTypeNode');\n                    switch (wrapper.kind) {\n                        case 'DateTime':\n                            return dateTimeTypeNode(node);\n                        case 'SolAmount':\n                            return solAmountTypeNode(node);\n                        case 'Amount':\n                            return amountTypeNode(node, wrapper.decimals, wrapper.unit);\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER, { wrapper });\n                    }\n                },\n            }),\n        ),\n    );\n}\n","import {\n    assertIsNode,\n    camelCase,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    instructionNode,\n    StructFieldTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\ntype StructDefaultValueMap = Record<string, Record<string, StructDefaultValue>>;\ntype StructDefaultValue = ValueNode | { strategy?: 'omitted' | 'optional'; value: ValueNode } | null;\n\nexport function setStructDefaultValuesVisitor(map: StructDefaultValueMap) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([stack, defaultValues]): BottomUpNodeTransformerWithSelector[] => {\n            const camelCasedDefaultValues = Object.fromEntries(\n                Object.entries(defaultValues).map(([key, value]) => [camelCase(key), value]),\n            );\n\n            return [\n                {\n                    select: `${stack}.[structTypeNode]`,\n                    transform: node => {\n                        assertIsNode(node, 'structTypeNode');\n                        const fields = node.fields.map((field): StructFieldTypeNode => {\n                            const defaultValue = camelCasedDefaultValues[field.name];\n                            if (defaultValue === undefined) return field;\n                            if (defaultValue === null) {\n                                return structFieldTypeNode({\n                                    ...field,\n                                    defaultValue: undefined,\n                                    defaultValueStrategy: undefined,\n                                });\n                            }\n                            return structFieldTypeNode({\n                                ...field,\n                                defaultValue: 'kind' in defaultValue ? defaultValue : defaultValue.value,\n                                defaultValueStrategy: 'kind' in defaultValue ? undefined : defaultValue.strategy,\n                            });\n                        });\n                        return structTypeNode(fields);\n                    },\n                },\n                {\n                    select: ['[instructionNode]', stack],\n                    transform: node => {\n                        assertIsNode(node, 'instructionNode');\n                        const transformArguments = (arg: InstructionArgumentNode): InstructionArgumentNode => {\n                            const defaultValue = camelCasedDefaultValues[arg.name];\n                            if (defaultValue === undefined) return arg;\n                            if (defaultValue === null) {\n                                return instructionArgumentNode({\n                                    ...arg,\n                                    defaultValue: undefined,\n                                    defaultValueStrategy: undefined,\n                                });\n                            }\n                            return instructionArgumentNode({\n                                ...arg,\n                                defaultValue: 'kind' in defaultValue ? defaultValue : defaultValue.value,\n                                defaultValueStrategy: 'kind' in defaultValue ? undefined : defaultValue.strategy,\n                            });\n                        };\n                        return instructionNode({\n                            ...node,\n                            arguments: node.arguments.map(transformArguments),\n                            extraArguments: node.extraArguments\n                                ? node.extraArguments.map(transformArguments)\n                                : undefined,\n                        });\n                    },\n                },\n            ];\n        }),\n    );\n}\n","import { accountNode, assertIsNode, programNode } from '@codama/nodes';\nimport { extendVisitor, nonNullableIdentityVisitor, pipe } from '@codama/visitors-core';\n\nexport function transformDefinedTypesIntoAccountsVisitor(definedTypes: string[]) {\n    return pipe(nonNullableIdentityVisitor({ keys: ['rootNode', 'programNode'] }), v =>\n        extendVisitor(v, {\n            visitProgram(program) {\n                const typesToExtract = program.definedTypes.filter(node => definedTypes.includes(node.name));\n\n                const newDefinedTypes = program.definedTypes.filter(node => !definedTypes.includes(node.name));\n\n                const newAccounts = typesToExtract.map(node => {\n                    assertIsNode(node.type, 'structTypeNode');\n                    return accountNode({\n                        ...node,\n                        data: node.type,\n                        discriminators: [],\n                        size: undefined,\n                    });\n                });\n\n                return programNode({\n                    ...program,\n                    accounts: [...program.accounts, ...newAccounts],\n                    definedTypes: newDefinedTypes,\n                });\n            },\n        }),\n    );\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    assertIsNode,\n    bytesTypeNode,\n    fixedSizeTypeNode,\n    isNode,\n    TYPE_NODES,\n} from '@codama/nodes';\nimport { extendVisitor, nonNullableIdentityVisitor, pipe, visit } from '@codama/visitors-core';\n\nexport function transformU8ArraysToBytesVisitor(sizes: number[] | '*' = '*') {\n    const hasRequiredSize = (count: ArrayTypeNode['count']): boolean => {\n        if (!isNode(count, 'fixedCountNode')) return false;\n        return sizes === '*' || sizes.includes(count.value);\n    };\n\n    return pipe(nonNullableIdentityVisitor(), v =>\n        extendVisitor(v, {\n            visitArrayType(node, { self }) {\n                const child = visit(node.item, self);\n                assertIsNode(child, TYPE_NODES);\n\n                if (\n                    isNode(child, 'numberTypeNode') &&\n                    child.format === 'u8' &&\n                    isNode(node.count, 'fixedCountNode') &&\n                    hasRequiredSize(node.count)\n                ) {\n                    return fixedSizeTypeNode(bytesTypeNode(), node.count.value);\n                }\n\n                return arrayTypeNode(child, node.count);\n            },\n        }),\n    );\n}\n","import { assertIsNodeFilter, camelCase, CamelCaseString, programNode } from '@codama/nodes';\nimport {\n    extendVisitor,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    LinkableDictionary,\n    NodeStack,\n    nonNullableIdentityVisitor,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nexport function unwrapDefinedTypesVisitor(typesToInline: string[] | '*' = '*') {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n    const typesToInlineCamelCased = (typesToInline === '*' ? [] : typesToInline).map(fullPath => {\n        if (!fullPath.includes('.')) return camelCase(fullPath);\n        const [programName, typeName] = fullPath.split('.');\n        return `${camelCase(programName)}.${camelCase(typeName)}`;\n    });\n    const shouldInline = (typeName: CamelCaseString, programName: CamelCaseString | undefined): boolean => {\n        if (typesToInline === '*') return true;\n        const fullPath = `${programName}.${typeName}`;\n        if (!!programName && typesToInlineCamelCased.includes(fullPath)) return true;\n        return typesToInlineCamelCased.includes(typeName);\n    };\n\n    return pipe(\n        nonNullableIdentityVisitor(),\n        v =>\n            extendVisitor(v, {\n                visitDefinedTypeLink(linkType, { self }) {\n                    const programName = linkType.program?.name ?? findProgramNodeFromPath(stack.getPath())?.name;\n                    if (!shouldInline(linkType.name, programName)) {\n                        return linkType;\n                    }\n                    const definedTypePath = linkables.getPathOrThrow(stack.getPath('definedTypeLinkNode'));\n                    const definedType = getLastNodeFromPath(definedTypePath);\n\n                    stack.pushPath(definedTypePath);\n                    const result = visit(definedType.type, self);\n                    stack.popPath();\n                    return result;\n                },\n\n                visitProgram(program, { self }) {\n                    return programNode({\n                        ...program,\n                        accounts: program.accounts\n                            .map(account => visit(account, self))\n                            .filter(assertIsNodeFilter('accountNode')),\n                        definedTypes: program.definedTypes\n                            .filter(definedType => !shouldInline(definedType.name, program.name))\n                            .map(type => visit(type, self))\n                            .filter(assertIsNodeFilter('definedTypeNode')),\n                        instructions: program.instructions\n                            .map(instruction => visit(instruction, self))\n                            .filter(assertIsNodeFilter('instructionNode')),\n                    });\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import { assertIsNode, CamelCaseString, definedTypeLinkNode, isNode } from '@codama/nodes';\nimport { getRecordLinkablesVisitor, LinkableDictionary, rootNodeVisitor, visit } from '@codama/visitors-core';\n\nimport { getDefinedTypeHistogramVisitor } from './getDefinedTypeHistogramVisitor';\nimport { unwrapDefinedTypesVisitor } from './unwrapDefinedTypesVisitor';\n\nexport function unwrapInstructionArgsDefinedTypesVisitor() {\n    return rootNodeVisitor(root => {\n        const histogram = visit(root, getDefinedTypeHistogramVisitor());\n        const linkables = new LinkableDictionary();\n        visit(root, getRecordLinkablesVisitor(linkables));\n\n        const definedTypesToInline = (Object.keys(histogram) as CamelCaseString[])\n            // Get all defined types used exactly once as an instruction argument.\n            .filter(key => (histogram[key].total ?? 0) === 1 && (histogram[key].directlyAsInstructionArgs ?? 0) === 1)\n            // Filter out enums which are better defined as external types.\n            .filter(key => {\n                const names = key.split('.');\n                const link = names.length == 2 ? definedTypeLinkNode(names[1], names[0]) : definedTypeLinkNode(key);\n                const found = linkables.get([link]);\n                return found && !isNode(found.type, 'enumTypeNode');\n            });\n\n        // Inline the identified defined types if any.\n        if (definedTypesToInline.length > 0) {\n            const inlineVisitor = unwrapDefinedTypesVisitor(definedTypesToInline);\n            const newRoot = visit(root, inlineVisitor);\n            assertIsNode(newRoot, 'rootNode');\n            return newRoot;\n        }\n\n        return root;\n    });\n}\n","import {\n    assertIsNode,\n    CamelCaseString,\n    DefinedTypeNode,\n    enumStructVariantTypeNode,\n    getAllDefinedTypes,\n    isNode,\n    REGISTERED_NODE_KINDS,\n    resolveNestedTypeNode,\n    StructTypeNode,\n    transformNestedTypeNode,\n} from '@codama/nodes';\nimport {\n    bottomUpTransformerVisitor,\n    getNodeSelectorFunction,\n    NodeSelectorFunction,\n    NodeStack,\n    rootNodeVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { getDefinedTypeHistogramVisitor } from './getDefinedTypeHistogramVisitor';\nimport { unwrapDefinedTypesVisitor } from './unwrapDefinedTypesVisitor';\n\nexport function unwrapTupleEnumWithSingleStructVisitor(enumsOrVariantsToUnwrap: string[] | '*' = '*') {\n    const selectorFunctions: NodeSelectorFunction[] =\n        enumsOrVariantsToUnwrap === '*'\n            ? [() => true]\n            : enumsOrVariantsToUnwrap.map(selector => getNodeSelectorFunction(selector));\n\n    const shouldUnwrap = (stack: NodeStack): boolean =>\n        selectorFunctions.some(selector => selector(stack.getPath(REGISTERED_NODE_KINDS)));\n\n    return rootNodeVisitor(root => {\n        const typesToPotentiallyUnwrap: string[] = [];\n        const definedTypes: Map<string, DefinedTypeNode> = new Map(\n            getAllDefinedTypes(root).map(definedType => [definedType.name, definedType]),\n        );\n\n        let newRoot = visit(\n            root,\n            bottomUpTransformerVisitor([\n                {\n                    select: '[enumTupleVariantTypeNode]',\n                    transform: (node, stack) => {\n                        assertIsNode(node, 'enumTupleVariantTypeNode');\n                        if (!shouldUnwrap(stack)) return node;\n                        const tupleNode = resolveNestedTypeNode(node.tuple);\n                        if (tupleNode.items.length !== 1) return node;\n                        let item = tupleNode.items[0];\n                        if (isNode(item, 'definedTypeLinkNode')) {\n                            const definedType = definedTypes.get(item.name);\n                            if (!definedType) return node;\n                            if (!isNode(definedType.type, 'structTypeNode')) return node;\n                            typesToPotentiallyUnwrap.push(item.name);\n                            item = definedType.type;\n                        }\n                        if (!isNode(item, 'structTypeNode')) return node;\n                        const nestedStruct = transformNestedTypeNode(node.tuple, () => item as StructTypeNode);\n                        return enumStructVariantTypeNode(node.name, nestedStruct);\n                    },\n                },\n            ]),\n        );\n        assertIsNode(newRoot, 'rootNode');\n\n        const histogram = visit(newRoot, getDefinedTypeHistogramVisitor());\n        const typesToUnwrap = typesToPotentiallyUnwrap.filter(\n            type => !histogram[type as CamelCaseString] || histogram[type as CamelCaseString].total === 0,\n        );\n\n        newRoot = visit(newRoot, unwrapDefinedTypesVisitor(typesToUnwrap));\n        assertIsNode(newRoot, 'rootNode');\n\n        return newRoot;\n    });\n}\n","import {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n} from '@codama/visitors-core';\n\nexport function unwrapTypeDefinedLinksVisitor(definedLinksType: string[]) {\n    const linkables = new LinkableDictionary();\n\n    const transformers: BottomUpNodeTransformerWithSelector[] = definedLinksType.map(selector => ({\n        select: ['[definedTypeLinkNode]', selector],\n        transform: (_, stack) => {\n            const definedType = linkables.getOrThrow(stack.getPath('definedTypeLinkNode'));\n            return definedType.type;\n        },\n    }));\n\n    return pipe(bottomUpTransformerVisitor(transformers), v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import {\n    enumEmptyVariantTypeNode,\n    enumStructVariantTypeNode,\n    enumTupleVariantTypeNode,\n    EnumTypeNode,\n    enumTypeNode,\n    EnumVariantTypeNode,\n    isNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nexport function renameStructNode(node: StructTypeNode, map: Record<string, string>): StructTypeNode {\n    return structTypeNode(\n        node.fields.map(field => (map[field.name] ? structFieldTypeNode({ ...field, name: map[field.name] }) : field)),\n    );\n}\n\nexport function renameEnumNode(node: EnumTypeNode, map: Record<string, string>): EnumTypeNode {\n    return enumTypeNode(\n        node.variants.map(variant => (map[variant.name] ? renameEnumVariant(variant, map[variant.name]) : variant)),\n        { ...node },\n    );\n}\n\nfunction renameEnumVariant(variant: EnumVariantTypeNode, newName: string) {\n    if (isNode(variant, 'enumStructVariantTypeNode')) {\n        return enumStructVariantTypeNode(newName, variant.struct);\n    }\n    if (isNode(variant, 'enumTupleVariantTypeNode')) {\n        return enumTupleVariantTypeNode(newName, variant.tuple);\n    }\n    return enumEmptyVariantTypeNode(newName);\n}\n","import {\n    accountLinkNode,\n    accountNode,\n    AccountNodeInput,\n    assertIsNode,\n    camelCase,\n    CamelCaseString,\n    pdaLinkNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    programNode,\n    transformNestedTypeNode,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    findProgramNodeFromPath,\n} from '@codama/visitors-core';\n\nimport { renameStructNode } from './renameHelpers';\n\nexport type AccountUpdates =\n    | { delete: true }\n    | (Partial<Omit<AccountNodeInput, 'data'>> & {\n          data?: Record<string, string>;\n          seeds?: PdaSeedNode[];\n      });\n\nexport function updateAccountsVisitor(map: Record<string, AccountUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([selector, updates]) => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n            const pdasToUpsert = [] as { pda: PdaNode; program: CamelCaseString }[];\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: ['[accountNode]', selector],\n                    transform: (node, stack) => {\n                        assertIsNode(node, 'accountNode');\n                        if ('delete' in updates) return null;\n\n                        const programNode = findProgramNodeFromPath(stack.getPath())!;\n                        const { seeds, pda, ...assignableUpdates } = updates;\n                        let newPda = node.pda;\n                        if (pda && seeds !== undefined) {\n                            newPda = pda;\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: pda.name, seeds }),\n                                program: programNode.name,\n                            });\n                        } else if (pda) {\n                            newPda = pda;\n                        } else if (seeds !== undefined && node.pda) {\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: node.pda.name, seeds }),\n                                program: programNode.name,\n                            });\n                        } else if (seeds !== undefined) {\n                            newPda = pdaLinkNode(newName ?? node.name);\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: newName ?? node.name, seeds }),\n                                program: programNode.name,\n                            });\n                        }\n\n                        return accountNode({\n                            ...node,\n                            ...assignableUpdates,\n                            data: transformNestedTypeNode(node.data, struct =>\n                                renameStructNode(struct, updates.data ?? {}),\n                            ),\n                            pda: newPda,\n                        });\n                    },\n                },\n                {\n                    select: `[programNode]`,\n                    transform: node => {\n                        assertIsNode(node, 'programNode');\n                        const pdasToUpsertForProgram = pdasToUpsert\n                            .filter(p => p.program === node.name)\n                            .map(p => p.pda);\n                        if (pdasToUpsertForProgram.length === 0) return node;\n                        const existingPdaNames = new Set(node.pdas.map(pda => pda.name));\n                        const pdasToCreate = pdasToUpsertForProgram.filter(p => !existingPdaNames.has(p.name));\n                        const pdasToUpdate = new Map(\n                            pdasToUpsertForProgram.filter(p => existingPdaNames.has(p.name)).map(p => [p.name, p]),\n                        );\n                        const newPdas = [...node.pdas.map(p => pdasToUpdate.get(p.name) ?? p), ...pdasToCreate];\n                        return programNode({ ...node, pdas: newPdas });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push(\n                    {\n                        select: ['[accountLinkNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'accountLinkNode');\n                            return accountLinkNode(newName);\n                        },\n                    },\n                    {\n                        select: ['[pdaNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'pdaNode');\n                            return pdaNode({ name: newName, seeds: node.seeds });\n                        },\n                    },\n                    {\n                        select: ['[pdaLinkNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'pdaLinkNode');\n                            return pdaLinkNode(newName);\n                        },\n                    },\n                );\n            }\n\n            return transformers;\n        }),\n    );\n}\n","import {\n    assertIsNode,\n    camelCase,\n    definedTypeLinkNode,\n    definedTypeNode,\n    DefinedTypeNodeInput,\n    isNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nimport { renameEnumNode, renameStructNode } from './renameHelpers';\n\nexport type DefinedTypeUpdates =\n    | { delete: true }\n    | (Partial<Omit<DefinedTypeNodeInput, 'data'>> & {\n          data?: Record<string, string>;\n      });\n\nexport function updateDefinedTypesVisitor(map: Record<string, DefinedTypeUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([selector, updates]): BottomUpNodeTransformerWithSelector[] => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: ['[definedTypeNode]', selector],\n                    transform: node => {\n                        assertIsNode(node, 'definedTypeNode');\n                        if ('delete' in updates) {\n                            return null;\n                        }\n                        const { data: dataUpdates, ...otherUpdates } = updates;\n                        let newType = node.type;\n                        if (isNode(node.type, 'structTypeNode')) {\n                            newType = renameStructNode(node.type, dataUpdates ?? {});\n                        } else if (isNode(node.type, 'enumTypeNode')) {\n                            newType = renameEnumNode(node.type, dataUpdates ?? {});\n                        }\n                        return definedTypeNode({\n                            ...node,\n                            ...otherUpdates,\n                            name: newName ?? node.name,\n                            type: newType,\n                        });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push({\n                    select: ['[definedTypeLinkNode]', selector],\n                    transform: node => {\n                        assertIsNode(node, 'definedTypeLinkNode');\n                        return definedTypeLinkNode(newName);\n                    },\n                });\n            }\n\n            return transformers;\n        }),\n    );\n}\n","import { assertIsNode, errorNode, ErrorNodeInput } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type ErrorUpdates = Partial<ErrorNodeInput> | { delete: true };\n\nexport function updateErrorsVisitor(map: Record<string, ErrorUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([name, updates]): BottomUpNodeTransformerWithSelector => ({\n                select: `[errorNode]${name}`,\n                transform: node => {\n                    assertIsNode(node, 'errorNode');\n                    if ('delete' in updates) return null;\n                    return errorNode({ ...node, ...updates });\n                },\n            }),\n        ),\n    );\n}\n","import {\n    assertIsNode,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionAccountNodeInput,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    InstructionArgumentNodeInput,\n    InstructionInputValueNode,\n    InstructionNode,\n    instructionNode,\n    InstructionNodeInput,\n    TYPE_NODES,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    NodePath,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { fillDefaultPdaSeedValuesVisitor } from './fillDefaultPdaSeedValuesVisitor';\n\nexport type InstructionUpdates =\n    | Partial<\n          Omit<InstructionNodeInput, 'accounts' | 'arguments' | 'extraArguments'> & {\n              accounts?: InstructionAccountUpdates;\n              arguments?: InstructionArgumentUpdates;\n          }\n      >\n    | { delete: true };\n\nexport type InstructionAccountUpdates = Record<\n    string,\n    Partial<Omit<InstructionAccountNodeInput, 'defaultValue'>> & {\n        defaultValue?: InstructionInputValueNode | null;\n    }\n>;\n\nexport type InstructionArgumentUpdates = Record<\n    string,\n    Partial<Omit<InstructionArgumentNodeInput, 'defaultValue'>> & {\n        defaultValue?: InstructionInputValueNode | null;\n    }\n>;\n\nexport function updateInstructionsVisitor(map: Record<string, InstructionUpdates>) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    const transformers = Object.entries(map).map(\n        ([selector, updates]): BottomUpNodeTransformerWithSelector => ({\n            select: ['[instructionNode]', selector],\n            transform: node => {\n                assertIsNode(node, 'instructionNode');\n                if ('delete' in updates) {\n                    return null;\n                }\n\n                const instructionPath = stack.getPath('instructionNode');\n                const { accounts: accountUpdates, arguments: argumentUpdates, ...metadataUpdates } = updates;\n                const { newArguments, newExtraArguments } = handleInstructionArguments(node, argumentUpdates ?? {});\n                const newAccounts = node.accounts.map(account =>\n                    handleInstructionAccount(instructionPath, account, accountUpdates ?? {}, linkables),\n                );\n                return instructionNode({\n                    ...node,\n                    ...metadataUpdates,\n                    accounts: newAccounts,\n                    arguments: newArguments,\n                    extraArguments: newExtraArguments.length > 0 ? newExtraArguments : undefined,\n                });\n            },\n        }),\n    );\n\n    return pipe(\n        bottomUpTransformerVisitor(transformers),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n\nfunction handleInstructionAccount(\n    instructionPath: NodePath<InstructionNode>,\n    account: InstructionAccountNode,\n    accountUpdates: InstructionAccountUpdates,\n    linkables: LinkableDictionary,\n): InstructionAccountNode {\n    const accountUpdate = accountUpdates?.[account.name];\n    if (!accountUpdate) return account;\n    const { defaultValue, ...acountWithoutDefault } = {\n        ...account,\n        ...accountUpdate,\n    };\n\n    if (!defaultValue) {\n        return instructionAccountNode(acountWithoutDefault);\n    }\n\n    return instructionAccountNode({\n        ...acountWithoutDefault,\n        defaultValue: visit(defaultValue, fillDefaultPdaSeedValuesVisitor(instructionPath, linkables)),\n    });\n}\n\nfunction handleInstructionArguments(\n    instruction: InstructionNode,\n    argUpdates: InstructionArgumentUpdates,\n): {\n    newArguments: InstructionArgumentNode[];\n    newExtraArguments: InstructionArgumentNode[];\n} {\n    const usedArguments = new Set<string>();\n\n    const newArguments = instruction.arguments.map(node => {\n        const argUpdate = argUpdates[node.name];\n        if (!argUpdate) return node;\n        usedArguments.add(node.name);\n        return instructionArgumentNode({\n            ...node,\n            defaultValue: argUpdate.defaultValue ?? node.defaultValue,\n            defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,\n            docs: argUpdate.docs ?? node.docs,\n            name: argUpdate.name ?? node.name,\n            type: argUpdate.type ?? node.type,\n        });\n    });\n\n    const updatedExtraArguments = (instruction.extraArguments ?? []).map(node => {\n        if (usedArguments.has(node.name)) return node;\n        const argUpdate = argUpdates[node.name];\n        if (!argUpdate) return node;\n        usedArguments.add(node.name);\n        return instructionArgumentNode({\n            ...node,\n            defaultValue: argUpdate.defaultValue ?? node.defaultValue,\n            defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,\n            docs: argUpdate.docs ?? node.docs,\n            name: argUpdate.name ?? node.name,\n            type: argUpdate.type ?? node.type,\n        });\n    });\n\n    const newExtraArguments = [\n        ...updatedExtraArguments,\n        ...Object.entries(argUpdates)\n            .filter(([argName]) => !usedArguments.has(argName))\n            .map(([argName, argUpdate]) => {\n                const { type } = argUpdate;\n                assertIsNode(type, TYPE_NODES);\n                return instructionArgumentNode({\n                    defaultValue: argUpdate.defaultValue ?? undefined,\n                    defaultValueStrategy: argUpdate.defaultValueStrategy ?? undefined,\n                    docs: argUpdate.docs ?? [],\n                    name: argUpdate.name ?? argName,\n                    type,\n                });\n            }),\n    ];\n\n    return { newArguments, newExtraArguments };\n}\n","import { assertIsNode, camelCase, programLinkNode, programNode, ProgramNodeInput } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type ProgramUpdates =\n    | Partial<Omit<ProgramNodeInput, 'accounts' | 'definedTypes' | 'errors' | 'instructions'>>\n    | { delete: true };\n\nexport function updateProgramsVisitor(map: Record<string, ProgramUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([name, updates]): BottomUpNodeTransformerWithSelector[] => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: `[programNode]${name}`,\n                    transform: node => {\n                        assertIsNode(node, 'programNode');\n                        if ('delete' in updates) return null;\n                        return programNode({ ...node, ...updates });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push({\n                    select: `[programLinkNode]${name}`,\n                    transform: node => {\n                        assertIsNode(node, 'programLinkNode');\n                        return programLinkNode(newName);\n                    },\n                });\n            }\n\n            return transformers;\n        }),\n    );\n}\n"]}