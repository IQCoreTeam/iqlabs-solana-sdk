'use strict';

var nodes = require('@codama/nodes');
var errors = require('@codama/errors');
var stringify = require('json-stable-stringify');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var stringify__default = /*#__PURE__*/_interopDefault(stringify);

// src/bottomUpTransformerVisitor.ts
function visit(node, visitor) {
  const key = getVisitFunctionName(node.kind);
  return visitor[key](node);
}
function visitOrElse(node, visitor, fallback) {
  const key = getVisitFunctionName(node.kind);
  return (key in visitor ? visitor[key] : fallback)(node);
}
function getVisitFunctionName(nodeKind) {
  if (!nodes.REGISTERED_NODE_KINDS.includes(nodeKind)) {
    throw new errors.CodamaError(errors.CODAMA_ERROR__UNRECOGNIZED_NODE_KIND, { kind: nodeKind });
  }
  return `visit${nodes.pascalCase(nodeKind.slice(0, -4))}`;
}

// src/staticVisitor.ts
function staticVisitor(fn, options = {}) {
  const keys = options.keys ?? nodes.REGISTERED_NODE_KINDS;
  const visitor = {};
  keys.forEach((key) => {
    visitor[getVisitFunctionName(key)] = fn.bind(visitor);
  });
  return visitor;
}

// src/identityVisitor.ts
function identityVisitor(options = {}) {
  const keys = options.keys ?? nodes.REGISTERED_NODE_KINDS;
  const visitor = staticVisitor((node) => Object.freeze({ ...node }), { keys });
  const visit2 = (v) => (node) => keys.includes(node.kind) ? visit(node, v) : Object.freeze({ ...node });
  if (keys.includes("rootNode")) {
    visitor.visitRoot = function visitRoot(node) {
      const program = visit2(this)(node.program);
      if (program === null) return null;
      nodes.assertIsNode(program, "programNode");
      return nodes.rootNode(
        program,
        node.additionalPrograms.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("programNode"))
      );
    };
  }
  if (keys.includes("programNode")) {
    visitor.visitProgram = function visitProgram(node) {
      return nodes.programNode({
        ...node,
        accounts: node.accounts.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("accountNode")),
        definedTypes: node.definedTypes.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("definedTypeNode")),
        errors: node.errors.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("errorNode")),
        instructions: node.instructions.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionNode")),
        pdas: node.pdas.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("pdaNode"))
      });
    };
  }
  if (keys.includes("pdaNode")) {
    visitor.visitPda = function visitPda(node) {
      return nodes.pdaNode({
        ...node,
        seeds: node.seeds.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.PDA_SEED_NODES))
      });
    };
  }
  if (keys.includes("accountNode")) {
    visitor.visitAccount = function visitAccount(node) {
      const data = visit2(this)(node.data);
      if (data === null) return null;
      nodes.assertIsNode(data, "structTypeNode");
      const pda = node.pda ? visit2(this)(node.pda) ?? void 0 : void 0;
      if (pda) nodes.assertIsNode(pda, "pdaLinkNode");
      return nodes.accountNode({ ...node, data, pda });
    };
  }
  if (keys.includes("instructionNode")) {
    visitor.visitInstruction = function visitInstruction(node) {
      const status = node.status ? visit2(this)(node.status) ?? void 0 : void 0;
      if (status) nodes.assertIsNode(status, "instructionStatusNode");
      return nodes.instructionNode({
        ...node,
        accounts: node.accounts.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionAccountNode")),
        arguments: node.arguments.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionArgumentNode")),
        byteDeltas: node.byteDeltas ? node.byteDeltas.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionByteDeltaNode")) : void 0,
        discriminators: node.discriminators ? node.discriminators.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.DISCRIMINATOR_NODES)) : void 0,
        extraArguments: node.extraArguments ? node.extraArguments.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionArgumentNode")) : void 0,
        remainingAccounts: node.remainingAccounts ? node.remainingAccounts.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionRemainingAccountsNode")) : void 0,
        status,
        subInstructions: node.subInstructions ? node.subInstructions.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("instructionNode")) : void 0
      });
    };
  }
  if (keys.includes("instructionAccountNode")) {
    visitor.visitInstructionAccount = function visitInstructionAccount(node) {
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) nodes.assertIsNode(defaultValue, nodes.INSTRUCTION_INPUT_VALUE_NODES);
      return nodes.instructionAccountNode({ ...node, defaultValue });
    };
  }
  if (keys.includes("instructionArgumentNode")) {
    visitor.visitInstructionArgument = function visitInstructionArgument(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) nodes.assertIsNode(defaultValue, nodes.INSTRUCTION_INPUT_VALUE_NODES);
      return nodes.instructionArgumentNode({ ...node, defaultValue, type });
    };
  }
  if (keys.includes("instructionRemainingAccountsNode")) {
    visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, ["argumentValueNode", "resolverValueNode"]);
      return nodes.instructionRemainingAccountsNode(value, { ...node });
    };
  }
  if (keys.includes("instructionByteDeltaNode")) {
    visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, ["numberValueNode", "accountLinkNode", "argumentValueNode", "resolverValueNode"]);
      return nodes.instructionByteDeltaNode(value, { ...node });
    };
  }
  if (keys.includes("instructionStatusNode")) {
    visitor.visitInstructionStatus = function visitInstructionStatus(node) {
      return nodes.instructionStatusNode(node.lifecycle, node.message);
    };
  }
  if (keys.includes("definedTypeNode")) {
    visitor.visitDefinedType = function visitDefinedType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.definedTypeNode({ ...node, type });
    };
  }
  if (keys.includes("arrayTypeNode")) {
    visitor.visitArrayType = function visitArrayType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      nodes.assertIsNode(size, nodes.COUNT_NODES);
      const item = visit2(this)(node.item);
      if (item === null) return null;
      nodes.assertIsNode(item, nodes.TYPE_NODES);
      return nodes.arrayTypeNode(item, size);
    };
  }
  if (keys.includes("enumTypeNode")) {
    visitor.visitEnumType = function visitEnumType(node) {
      return nodes.enumTypeNode(
        node.variants.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.ENUM_VARIANT_TYPE_NODES)),
        { size: node.size }
      );
    };
  }
  if (keys.includes("enumStructVariantTypeNode")) {
    visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {
      const newStruct = visit2(this)(node.struct);
      if (!newStruct) {
        return nodes.enumEmptyVariantTypeNode(node.name);
      }
      nodes.assertIsNode(newStruct, "structTypeNode");
      if (newStruct.fields.length === 0) {
        return nodes.enumEmptyVariantTypeNode(node.name);
      }
      return nodes.enumStructVariantTypeNode(node.name, newStruct);
    };
  }
  if (keys.includes("enumTupleVariantTypeNode")) {
    visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {
      const newTuple = visit2(this)(node.tuple);
      if (!newTuple) {
        return nodes.enumEmptyVariantTypeNode(node.name);
      }
      nodes.assertIsNode(newTuple, "tupleTypeNode");
      if (newTuple.items.length === 0) {
        return nodes.enumEmptyVariantTypeNode(node.name);
      }
      return nodes.enumTupleVariantTypeNode(node.name, newTuple);
    };
  }
  if (keys.includes("mapTypeNode")) {
    visitor.visitMapType = function visitMapType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      nodes.assertIsNode(size, nodes.COUNT_NODES);
      const key = visit2(this)(node.key);
      if (key === null) return null;
      nodes.assertIsNode(key, nodes.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, nodes.TYPE_NODES);
      return nodes.mapTypeNode(key, value, size);
    };
  }
  if (keys.includes("optionTypeNode")) {
    visitor.visitOptionType = function visitOptionType(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      nodes.assertIsNestedTypeNode(prefix, "numberTypeNode");
      const item = visit2(this)(node.item);
      if (item === null) return null;
      nodes.assertIsNode(item, nodes.TYPE_NODES);
      return nodes.optionTypeNode(item, { ...node, prefix });
    };
  }
  if (keys.includes("zeroableOptionTypeNode")) {
    visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {
      const item = visit2(this)(node.item);
      if (item === null) return null;
      nodes.assertIsNode(item, nodes.TYPE_NODES);
      const zeroValue = node.zeroValue ? visit2(this)(node.zeroValue) ?? void 0 : void 0;
      if (zeroValue) nodes.assertIsNode(zeroValue, "constantValueNode");
      return nodes.zeroableOptionTypeNode(item, zeroValue);
    };
  }
  if (keys.includes("remainderOptionTypeNode")) {
    visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {
      const item = visit2(this)(node.item);
      if (item === null) return null;
      nodes.assertIsNode(item, nodes.TYPE_NODES);
      return nodes.remainderOptionTypeNode(item);
    };
  }
  if (keys.includes("booleanTypeNode")) {
    visitor.visitBooleanType = function visitBooleanType(node) {
      const size = visit2(this)(node.size);
      if (size === null) return null;
      nodes.assertIsNestedTypeNode(size, "numberTypeNode");
      return nodes.booleanTypeNode(size);
    };
  }
  if (keys.includes("setTypeNode")) {
    visitor.visitSetType = function visitSetType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      nodes.assertIsNode(size, nodes.COUNT_NODES);
      const item = visit2(this)(node.item);
      if (item === null) return null;
      nodes.assertIsNode(item, nodes.TYPE_NODES);
      return nodes.setTypeNode(item, size);
    };
  }
  if (keys.includes("structTypeNode")) {
    visitor.visitStructType = function visitStructType(node) {
      const fields = node.fields.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("structFieldTypeNode"));
      return nodes.structTypeNode(fields);
    };
  }
  if (keys.includes("structFieldTypeNode")) {
    visitor.visitStructFieldType = function visitStructFieldType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) nodes.assertIsNode(defaultValue, nodes.VALUE_NODES);
      return nodes.structFieldTypeNode({ ...node, defaultValue, type });
    };
  }
  if (keys.includes("tupleTypeNode")) {
    visitor.visitTupleType = function visitTupleType(node) {
      const items = node.items.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.TYPE_NODES));
      return nodes.tupleTypeNode(items);
    };
  }
  if (keys.includes("amountTypeNode")) {
    visitor.visitAmountType = function visitAmountType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      nodes.assertIsNestedTypeNode(number, "numberTypeNode");
      return nodes.amountTypeNode(number, node.decimals, node.unit);
    };
  }
  if (keys.includes("dateTimeTypeNode")) {
    visitor.visitDateTimeType = function visitDateTimeType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      nodes.assertIsNestedTypeNode(number, "numberTypeNode");
      return nodes.dateTimeTypeNode(number);
    };
  }
  if (keys.includes("solAmountTypeNode")) {
    visitor.visitSolAmountType = function visitSolAmountType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      nodes.assertIsNestedTypeNode(number, "numberTypeNode");
      return nodes.solAmountTypeNode(number);
    };
  }
  if (keys.includes("prefixedCountNode")) {
    visitor.visitPrefixedCount = function visitPrefixedCount(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      nodes.assertIsNestedTypeNode(prefix, "numberTypeNode");
      return nodes.prefixedCountNode(prefix);
    };
  }
  if (keys.includes("arrayValueNode")) {
    visitor.visitArrayValue = function visitArrayValue(node) {
      return nodes.arrayValueNode(node.items.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.VALUE_NODES)));
    };
  }
  if (keys.includes("constantValueNode")) {
    visitor.visitConstantValue = function visitConstantValue(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, nodes.VALUE_NODES);
      return nodes.constantValueNode(type, value);
    };
  }
  if (keys.includes("enumValueNode")) {
    visitor.visitEnumValue = function visitEnumValue(node) {
      const enumLink = visit2(this)(node.enum);
      if (enumLink === null) return null;
      nodes.assertIsNode(enumLink, ["definedTypeLinkNode"]);
      const value = node.value ? visit2(this)(node.value) ?? void 0 : void 0;
      if (value) nodes.assertIsNode(value, ["structValueNode", "tupleValueNode"]);
      return nodes.enumValueNode(enumLink, node.variant, value);
    };
  }
  if (keys.includes("mapValueNode")) {
    visitor.visitMapValue = function visitMapValue(node) {
      return nodes.mapValueNode(
        node.entries.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("mapEntryValueNode"))
      );
    };
  }
  if (keys.includes("mapEntryValueNode")) {
    visitor.visitMapEntryValue = function visitMapEntryValue(node) {
      const key = visit2(this)(node.key);
      if (key === null) return null;
      nodes.assertIsNode(key, nodes.VALUE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, nodes.VALUE_NODES);
      return nodes.mapEntryValueNode(key, value);
    };
  }
  if (keys.includes("setValueNode")) {
    visitor.visitSetValue = function visitSetValue(node) {
      return nodes.setValueNode(node.items.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.VALUE_NODES)));
    };
  }
  if (keys.includes("someValueNode")) {
    visitor.visitSomeValue = function visitSomeValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, nodes.VALUE_NODES);
      return nodes.someValueNode(value);
    };
  }
  if (keys.includes("structValueNode")) {
    visitor.visitStructValue = function visitStructValue(node) {
      return nodes.structValueNode(
        node.fields.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("structFieldValueNode"))
      );
    };
  }
  if (keys.includes("structFieldValueNode")) {
    visitor.visitStructFieldValue = function visitStructFieldValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, nodes.VALUE_NODES);
      return nodes.structFieldValueNode(node.name, value);
    };
  }
  if (keys.includes("tupleValueNode")) {
    visitor.visitTupleValue = function visitTupleValue(node) {
      return nodes.tupleValueNode(node.items.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(nodes.VALUE_NODES)));
    };
  }
  if (keys.includes("constantPdaSeedNode")) {
    visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, [...nodes.VALUE_NODES, "programIdValueNode"]);
      return nodes.constantPdaSeedNode(type, value);
    };
  }
  if (keys.includes("variablePdaSeedNode")) {
    visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.variablePdaSeedNode(node.name, type, node.docs);
    };
  }
  if (keys.includes("resolverValueNode")) {
    visitor.visitResolverValue = function visitResolverValue(node) {
      const dependsOn = (node.dependsOn ?? []).map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter(["accountValueNode", "argumentValueNode"]));
      return nodes.resolverValueNode(node.name, {
        ...node,
        dependsOn: dependsOn.length === 0 ? void 0 : dependsOn
      });
    };
  }
  if (keys.includes("conditionalValueNode")) {
    visitor.visitConditionalValue = function visitConditionalValue(node) {
      const condition = visit2(this)(node.condition);
      if (condition === null) return null;
      nodes.assertIsNode(condition, ["resolverValueNode", "accountValueNode", "argumentValueNode"]);
      const value = node.value ? visit2(this)(node.value) ?? void 0 : void 0;
      if (value) nodes.assertIsNode(value, nodes.VALUE_NODES);
      const ifTrue = node.ifTrue ? visit2(this)(node.ifTrue) ?? void 0 : void 0;
      if (ifTrue) nodes.assertIsNode(ifTrue, nodes.INSTRUCTION_INPUT_VALUE_NODES);
      const ifFalse = node.ifFalse ? visit2(this)(node.ifFalse) ?? void 0 : void 0;
      if (ifFalse) nodes.assertIsNode(ifFalse, nodes.INSTRUCTION_INPUT_VALUE_NODES);
      if (!ifTrue && !ifFalse) return null;
      return nodes.conditionalValueNode({ condition, ifFalse, ifTrue, value });
    };
  }
  if (keys.includes("pdaValueNode")) {
    visitor.visitPdaValue = function visitPdaValue(node) {
      const pda = visit2(this)(node.pda);
      if (pda === null) return null;
      nodes.assertIsNode(pda, ["pdaLinkNode", "pdaNode"]);
      const seeds = node.seeds.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("pdaSeedValueNode"));
      return nodes.pdaValueNode(pda, seeds);
    };
  }
  if (keys.includes("pdaSeedValueNode")) {
    visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      nodes.assertIsNode(value, [...nodes.VALUE_NODES, "accountValueNode", "argumentValueNode"]);
      return nodes.pdaSeedValueNode(node.name, value);
    };
  }
  if (keys.includes("fixedSizeTypeNode")) {
    visitor.visitFixedSizeType = function visitFixedSizeType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.fixedSizeTypeNode(type, node.size);
    };
  }
  if (keys.includes("sizePrefixTypeNode")) {
    visitor.visitSizePrefixType = function visitSizePrefixType(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      nodes.assertIsNestedTypeNode(prefix, "numberTypeNode");
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.sizePrefixTypeNode(type, prefix);
    };
  }
  if (keys.includes("preOffsetTypeNode")) {
    visitor.visitPreOffsetType = function visitPreOffsetType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.preOffsetTypeNode(type, node.offset, node.strategy);
    };
  }
  if (keys.includes("postOffsetTypeNode")) {
    visitor.visitPostOffsetType = function visitPostOffsetType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.postOffsetTypeNode(type, node.offset, node.strategy);
    };
  }
  if (keys.includes("sentinelTypeNode")) {
    visitor.visitSentinelType = function visitSentinelType(node) {
      const sentinel = visit2(this)(node.sentinel);
      if (sentinel === null) return null;
      nodes.assertIsNode(sentinel, "constantValueNode");
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      return nodes.sentinelTypeNode(type, sentinel);
    };
  }
  if (keys.includes("hiddenPrefixTypeNode")) {
    visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const prefix = node.prefix.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("constantValueNode"));
      if (prefix.length === 0) return type;
      return nodes.hiddenPrefixTypeNode(type, prefix);
    };
  }
  if (keys.includes("hiddenSuffixTypeNode")) {
    visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      nodes.assertIsNode(type, nodes.TYPE_NODES);
      const suffix = node.suffix.map(visit2(this)).filter(nodes.removeNullAndAssertIsNodeFilter("constantValueNode"));
      if (suffix.length === 0) return type;
      return nodes.hiddenSuffixTypeNode(type, suffix);
    };
  }
  if (keys.includes("constantDiscriminatorNode")) {
    visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {
      const constant = visit2(this)(node.constant);
      if (constant === null) return null;
      nodes.assertIsNode(constant, "constantValueNode");
      return nodes.constantDiscriminatorNode(constant, node.offset);
    };
  }
  if (keys.includes("accountLinkNode")) {
    visitor.visitAccountLink = function visitAccountLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) nodes.assertIsNode(program, "programLinkNode");
      return nodes.accountLinkNode(node.name, program);
    };
  }
  if (keys.includes("definedTypeLinkNode")) {
    visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) nodes.assertIsNode(program, "programLinkNode");
      return nodes.definedTypeLinkNode(node.name, program);
    };
  }
  if (keys.includes("instructionLinkNode")) {
    visitor.visitInstructionLink = function visitInstructionLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) nodes.assertIsNode(program, "programLinkNode");
      return nodes.instructionLinkNode(node.name, program);
    };
  }
  if (keys.includes("instructionAccountLinkNode")) {
    visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {
      const instruction = node.instruction ? visit2(this)(node.instruction) ?? void 0 : void 0;
      if (instruction) nodes.assertIsNode(instruction, "instructionLinkNode");
      return nodes.instructionAccountLinkNode(node.name, instruction);
    };
  }
  if (keys.includes("instructionArgumentLinkNode")) {
    visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {
      const instruction = node.instruction ? visit2(this)(node.instruction) ?? void 0 : void 0;
      if (instruction) nodes.assertIsNode(instruction, "instructionLinkNode");
      return nodes.instructionArgumentLinkNode(node.name, instruction);
    };
  }
  if (keys.includes("pdaLinkNode")) {
    visitor.visitPdaLink = function visitPdaLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) nodes.assertIsNode(program, "programLinkNode");
      return nodes.pdaLinkNode(node.name, program);
    };
  }
  return visitor;
}
function interceptVisitor(visitor, interceptor) {
  const registeredVisitFunctions = nodes.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  return Object.fromEntries(
    Object.keys(visitor).flatMap((key) => {
      const castedKey = key;
      if (!registeredVisitFunctions.includes(castedKey)) {
        return [];
      }
      return [
        [
          castedKey,
          function interceptedVisitNode(node) {
            const baseFunction = visitor[castedKey];
            return interceptor(node, baseFunction.bind(this));
          }
        ]
      ];
    })
  );
}
var getNodeSelectorFunction = (selector) => {
  if (typeof selector === "function") return selector;
  const checkNode = (node, nodeSelector) => {
    if (nodeSelector === "*") return true;
    const matches = nodeSelector.match(/^(?:\[([^\]]+)\])?(.*)?$/);
    if (!matches) return false;
    const [, kinds, name] = matches;
    const kindArray = kinds ? kinds.split("|").map(nodes.camelCase) : [];
    if (kindArray.length > 0 && !kindArray.includes(node.kind)) {
      return false;
    }
    if (name && (!("name" in node) || nodes.camelCase(name) !== node.name)) {
      return false;
    }
    return true;
  };
  const checkPath = (path, nodeSelectors2) => {
    if (nodeSelectors2.length === 0) return true;
    if (path.length === 0) return false;
    const lastNode = path.pop();
    const lastNodeSelector = nodeSelectors2.pop();
    return checkNode(lastNode, lastNodeSelector) ? checkPath(path, nodeSelectors2) : checkPath(path, [...nodeSelectors2, lastNodeSelector]);
  };
  const checkInitialPath = (path, nodeSelectors2) => {
    if (nodeSelectors2.length === 0 || path.length === 0) return false;
    const lastNode = path.pop();
    const lastNodeSelector = nodeSelectors2.pop();
    return checkNode(lastNode, lastNodeSelector) && checkPath(path, nodeSelectors2);
  };
  const nodeSelectors = selector.split(".");
  return (path) => checkInitialPath([...path], [...nodeSelectors]);
};
var getConjunctiveNodeSelectorFunction = (selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  const selectorFunctions = selectors.map(getNodeSelectorFunction);
  return (path) => selectorFunctions.every((fn) => fn(path));
};
function getLastNodeFromPath(path) {
  return path[path.length - 1];
}
function findFirstNodeFromPath(path, kind) {
  return path.find((node) => nodes.isNode(node, kind));
}
function findLastNodeFromPath(path, kind) {
  for (let index = path.length - 1; index >= 0; index--) {
    const node = path[index];
    if (nodes.isNode(node, kind)) return node;
  }
  return void 0;
}
function findProgramNodeFromPath(path) {
  return findLastNodeFromPath(path, "programNode");
}
function findInstructionNodeFromPath(path) {
  return findLastNodeFromPath(path, "instructionNode");
}
function getNodePathUntilLastNode(path, kind) {
  const lastIndex = (() => {
    for (let index = path.length - 1; index >= 0; index--) {
      const node = path[index];
      if (nodes.isNode(node, kind)) return index;
    }
    return -1;
  })();
  if (lastIndex === -1) return void 0;
  return path.slice(0, lastIndex + 1);
}
function isFilledNodePath(path) {
  return !!path && path.length > 0;
}
function isNodePath(path, kind) {
  return nodes.isNode(isFilledNodePath(path) ? getLastNodeFromPath(path) : null, kind);
}
function assertIsNodePath(path, kind) {
  nodes.assertIsNode(isFilledNodePath(path) ? getLastNodeFromPath(path) : null, kind);
}
function nodePathToStringArray(path) {
  return path.map((node) => {
    return "name" in node ? `[${node.kind}]${node.name}` : `[${node.kind}]`;
  });
}
function nodePathToString(path) {
  return nodePathToStringArray(path).join(" > ");
}

// src/NodeStack.ts
var NodeStack = class _NodeStack {
  /**
   * Contains all the node paths saved during the traversal.
   *
   * - The very last path is the current path which is being
   *   used during the traversal.
   * - The other paths can be used to save and restore the
   *   current path when jumping to different parts of the tree.
   *
   * There must at least be one path in the stack at all times.
   */
  stack;
  constructor(...stack) {
    this.stack = stack.length === 0 ? [[]] : [...stack.map((nodes) => [...nodes])];
  }
  get currentPath() {
    return this.stack[this.stack.length - 1];
  }
  push(node) {
    this.currentPath.push(node);
  }
  pop() {
    return this.currentPath.pop();
  }
  peek() {
    return this.isEmpty() ? void 0 : this.currentPath[this.currentPath.length - 1];
  }
  pushPath(newPath = []) {
    this.stack.push([...newPath]);
  }
  popPath() {
    if (this.stack.length <= 1) {
      throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__CANNOT_REMOVE_LAST_PATH_IN_NODE_STACK, {
        path: [...this.stack[this.stack.length - 1]]
      });
    }
    return [...this.stack.pop()];
  }
  getPath(kind) {
    const path = [...this.currentPath];
    if (kind) {
      assertIsNodePath(path, kind);
    }
    return path;
  }
  isEmpty() {
    return this.currentPath.length === 0;
  }
  clone() {
    return new _NodeStack(...this.stack);
  }
  toString() {
    return nodePathToString(this.getPath());
  }
};

// src/pipe.ts
function pipe(init, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), init);
}

// src/recordNodeStackVisitor.ts
function recordNodeStackVisitor(visitor, stack) {
  return interceptVisitor(visitor, (node, next) => {
    stack.push(node);
    const newNode = next(node);
    stack.pop();
    return newNode;
  });
}

// src/bottomUpTransformerVisitor.ts
function bottomUpTransformerVisitor(transformers, options = {}) {
  const transformerFunctions = transformers.map((transformer) => {
    if (typeof transformer === "function") return transformer;
    return (node, stack2) => getConjunctiveNodeSelectorFunction(transformer.select)(stack2.getPath(nodes.REGISTERED_NODE_KINDS)) ? transformer.transform(node, stack2) : node;
  });
  const stack = options.stack ?? new NodeStack();
  return pipe(
    identityVisitor(options),
    (v) => interceptVisitor(v, (node, next) => {
      return transformerFunctions.reduce(
        (acc, transformer) => acc === null ? null : transformer(acc, stack),
        next(node)
      );
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}
function mapVisitor(visitor, map) {
  const registeredVisitFunctions = nodes.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  return Object.fromEntries(
    Object.keys(visitor).flatMap((key) => {
      const castedKey = key;
      if (!registeredVisitFunctions.includes(castedKey)) {
        return [];
      }
      return [
        [
          castedKey,
          (node) => map(visitor[castedKey](node))
        ]
      ];
    })
  );
}

// src/consoleLogVisitor.ts
function consoleLogVisitor(visitor) {
  return mapVisitor(visitor, (value) => console.log(value));
}
function topDownTransformerVisitor(transformers, options = {}) {
  const transformerFunctions = transformers.map((transformer) => {
    if (typeof transformer === "function") return transformer;
    return (node, stack2) => getConjunctiveNodeSelectorFunction(transformer.select)(stack2.getPath(nodes.REGISTERED_NODE_KINDS)) ? transformer.transform(node, stack2) : node;
  });
  const stack = options.stack ?? new NodeStack();
  return pipe(
    identityVisitor(options),
    (v) => interceptVisitor(v, (node, next) => {
      const appliedNode = transformerFunctions.reduce(
        (acc, transformer) => acc === null ? null : transformer(acc, stack),
        node
      );
      if (appliedNode === null) return null;
      return next(appliedNode);
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}

// src/deleteNodesVisitor.ts
function deleteNodesVisitor(selectors, options) {
  return topDownTransformerVisitor(
    selectors.map(
      (selector) => ({
        select: selector,
        transform: () => null
      })
    ),
    options
  );
}
function extendVisitor(visitor, overrides) {
  const registeredVisitFunctions = nodes.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  const overriddenFunctions = Object.fromEntries(
    Object.keys(overrides).flatMap((key) => {
      if (!registeredVisitFunctions.includes(key)) {
        return [];
      }
      const castedKey = key;
      if (!visitor[castedKey]) {
        throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__CANNOT_EXTEND_MISSING_VISIT_FUNCTION, {
          visitFunction: castedKey
        });
      }
      return [
        [
          castedKey,
          function extendedVisitNode(node) {
            const extendedFunction = overrides[castedKey];
            const nextFunction = visitor[castedKey];
            return extendedFunction.bind(this)(node, {
              next: nextFunction.bind(this),
              self: this
            });
          }
        ]
      ];
    })
  );
  return {
    ...visitor,
    ...overriddenFunctions
  };
}
function mergeVisitor(leafValue, merge, options = {}) {
  const keys = options.keys ?? nodes.REGISTERED_NODE_KINDS;
  const visitor = staticVisitor(leafValue, { keys });
  const visit2 = (v) => (node) => keys.includes(node.kind) ? [visit(node, v)] : [];
  if (keys.includes("rootNode")) {
    visitor.visitRoot = function visitRoot(node) {
      return merge(node, nodes.getAllPrograms(node).flatMap(visit2(this)));
    };
  }
  if (keys.includes("programNode")) {
    visitor.visitProgram = function visitProgram(node) {
      return merge(node, [
        ...node.pdas.flatMap(visit2(this)),
        ...node.accounts.flatMap(visit2(this)),
        ...node.instructions.flatMap(visit2(this)),
        ...node.definedTypes.flatMap(visit2(this)),
        ...node.errors.flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("pdaNode")) {
    visitor.visitPda = function visitPda(node) {
      return merge(node, node.seeds.flatMap(visit2(this)));
    };
  }
  if (keys.includes("accountNode")) {
    visitor.visitAccount = function visitAccount(node) {
      return merge(node, [
        ...visit2(this)(node.data),
        ...node.pda ? visit2(this)(node.pda) : [],
        ...(node.discriminators ?? []).flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("instructionNode")) {
    visitor.visitInstruction = function visitInstruction(node) {
      return merge(node, [
        ...node.status ? visit2(this)(node.status) : [],
        ...node.accounts.flatMap(visit2(this)),
        ...node.arguments.flatMap(visit2(this)),
        ...(node.extraArguments ?? []).flatMap(visit2(this)),
        ...(node.remainingAccounts ?? []).flatMap(visit2(this)),
        ...(node.byteDeltas ?? []).flatMap(visit2(this)),
        ...(node.discriminators ?? []).flatMap(visit2(this)),
        ...(node.subInstructions ?? []).flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("instructionAccountNode")) {
    visitor.visitInstructionAccount = function visitInstructionAccount(node) {
      return merge(node, [...node.defaultValue ? visit2(this)(node.defaultValue) : []]);
    };
  }
  if (keys.includes("instructionArgumentNode")) {
    visitor.visitInstructionArgument = function visitInstructionArgument(node) {
      return merge(node, [
        ...visit2(this)(node.type),
        ...node.defaultValue ? visit2(this)(node.defaultValue) : []
      ]);
    };
  }
  if (keys.includes("instructionRemainingAccountsNode")) {
    visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("instructionByteDeltaNode")) {
    visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("instructionStatusNode")) {
    visitor.visitInstructionStatus = function visitInstructionStatus(node) {
      return merge(node, []);
    };
  }
  if (keys.includes("definedTypeNode")) {
    visitor.visitDefinedType = function visitDefinedType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("arrayTypeNode")) {
    visitor.visitArrayType = function visitArrayType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("enumTypeNode")) {
    visitor.visitEnumType = function visitEnumType(node) {
      return merge(node, [...visit2(this)(node.size), ...node.variants.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("enumStructVariantTypeNode")) {
    visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {
      return merge(node, visit2(this)(node.struct));
    };
  }
  if (keys.includes("enumTupleVariantTypeNode")) {
    visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {
      return merge(node, visit2(this)(node.tuple));
    };
  }
  if (keys.includes("mapTypeNode")) {
    visitor.visitMapType = function visitMapType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.key), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("optionTypeNode")) {
    visitor.visitOptionType = function visitOptionType(node) {
      return merge(node, [...visit2(this)(node.prefix), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("zeroableOptionTypeNode")) {
    visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {
      return merge(node, [...visit2(this)(node.item), ...node.zeroValue ? visit2(this)(node.zeroValue) : []]);
    };
  }
  if (keys.includes("remainderOptionTypeNode")) {
    visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {
      return merge(node, visit2(this)(node.item));
    };
  }
  if (keys.includes("booleanTypeNode")) {
    visitor.visitBooleanType = function visitBooleanType(node) {
      return merge(node, visit2(this)(node.size));
    };
  }
  if (keys.includes("setTypeNode")) {
    visitor.visitSetType = function visitSetType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("structTypeNode")) {
    visitor.visitStructType = function visitStructType(node) {
      return merge(node, node.fields.flatMap(visit2(this)));
    };
  }
  if (keys.includes("structFieldTypeNode")) {
    visitor.visitStructFieldType = function visitStructFieldType(node) {
      return merge(node, [
        ...visit2(this)(node.type),
        ...node.defaultValue ? visit2(this)(node.defaultValue) : []
      ]);
    };
  }
  if (keys.includes("tupleTypeNode")) {
    visitor.visitTupleType = function visitTupleType(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("amountTypeNode")) {
    visitor.visitAmountType = function visitAmountType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("dateTimeTypeNode")) {
    visitor.visitDateTimeType = function visitDateTimeType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("solAmountTypeNode")) {
    visitor.visitSolAmountType = function visitSolAmountType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("prefixedCountNode")) {
    visitor.visitPrefixedCount = function visitPrefixedCount(node) {
      return merge(node, visit2(this)(node.prefix));
    };
  }
  if (keys.includes("arrayValueNode")) {
    visitor.visitArrayValue = function visitArrayValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("constantValueNode")) {
    visitor.visitConstantValue = function visitConstantValue(node) {
      return merge(node, [...visit2(this)(node.type), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("enumValueNode")) {
    visitor.visitEnumValue = function visitEnumValue(node) {
      return merge(node, [...visit2(this)(node.enum), ...node.value ? visit2(this)(node.value) : []]);
    };
  }
  if (keys.includes("mapValueNode")) {
    visitor.visitMapValue = function visitMapValue(node) {
      return merge(node, node.entries.flatMap(visit2(this)));
    };
  }
  if (keys.includes("mapEntryValueNode")) {
    visitor.visitMapEntryValue = function visitMapEntryValue(node) {
      return merge(node, [...visit2(this)(node.key), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("setValueNode")) {
    visitor.visitSetValue = function visitSetValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("someValueNode")) {
    visitor.visitSomeValue = function visitSomeValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("structValueNode")) {
    visitor.visitStructValue = function visitStructValue(node) {
      return merge(node, node.fields.flatMap(visit2(this)));
    };
  }
  if (keys.includes("structFieldValueNode")) {
    visitor.visitStructFieldValue = function visitStructFieldValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("tupleValueNode")) {
    visitor.visitTupleValue = function visitTupleValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("constantPdaSeedNode")) {
    visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {
      return merge(node, [...visit2(this)(node.type), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("variablePdaSeedNode")) {
    visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("resolverValueNode")) {
    visitor.visitResolverValue = function visitResolverValue(node) {
      return merge(node, (node.dependsOn ?? []).flatMap(visit2(this)));
    };
  }
  if (keys.includes("conditionalValueNode")) {
    visitor.visitConditionalValue = function visitConditionalValue(node) {
      return merge(node, [
        ...visit2(this)(node.condition),
        ...node.value ? visit2(this)(node.value) : [],
        ...node.ifTrue ? visit2(this)(node.ifTrue) : [],
        ...node.ifFalse ? visit2(this)(node.ifFalse) : []
      ]);
    };
  }
  if (keys.includes("pdaValueNode")) {
    visitor.visitPdaValue = function visitPdaValue(node) {
      return merge(node, [...visit2(this)(node.pda), ...node.seeds.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("pdaSeedValueNode")) {
    visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("fixedSizeTypeNode")) {
    visitor.visitFixedSizeType = function visitFixedSizeType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("sizePrefixTypeNode")) {
    visitor.visitSizePrefixType = function visitSizePrefixType(node) {
      return merge(node, [...visit2(this)(node.prefix), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("preOffsetTypeNode")) {
    visitor.visitPreOffsetType = function visitPreOffsetType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("postOffsetTypeNode")) {
    visitor.visitPostOffsetType = function visitPostOffsetType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("sentinelTypeNode")) {
    visitor.visitSentinelType = function visitSentinelType(node) {
      return merge(node, [...visit2(this)(node.sentinel), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("hiddenPrefixTypeNode")) {
    visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {
      return merge(node, [...node.prefix.flatMap(visit2(this)), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("hiddenSuffixTypeNode")) {
    visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {
      return merge(node, [...visit2(this)(node.type), ...node.suffix.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("constantDiscriminatorNode")) {
    visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {
      return merge(node, visit2(this)(node.constant));
    };
  }
  if (keys.includes("accountLinkNode")) {
    visitor.visitAccountLink = function visitAccountLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("definedTypeLinkNode")) {
    visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("instructionLinkNode")) {
    visitor.visitInstructionLink = function visitInstructionLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("instructionAccountLinkNode")) {
    visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {
      return merge(node, node.instruction ? visit2(this)(node.instruction) : []);
    };
  }
  if (keys.includes("instructionArgumentLinkNode")) {
    visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {
      return merge(node, node.instruction ? visit2(this)(node.instruction) : []);
    };
  }
  if (keys.includes("pdaLinkNode")) {
    visitor.visitPdaLink = function visitPdaLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  return visitor;
}

// src/getByteSizeVisitor.ts
function getByteSizeVisitor(linkables, options = {}) {
  const stack = options.stack ?? new NodeStack();
  const visitedDefinedTypes = /* @__PURE__ */ new Map();
  const definedTypeStack = [];
  const sumSizes = (values) => values.reduce((all, one) => all === null || one === null ? null : all + one, 0);
  const baseVisitor = mergeVisitor(
    () => null,
    (_, values) => sumSizes(values),
    {
      keys: [
        ...nodes.REGISTERED_TYPE_NODE_KINDS,
        "accountNode",
        "constantValueNode",
        "definedTypeLinkNode",
        "definedTypeNode",
        "instructionArgumentNode",
        "instructionNode"
      ]
    }
  );
  return pipe(
    baseVisitor,
    (v) => extendVisitor(v, {
      visitAccount(node, { self }) {
        return visit(node.data, self);
      },
      visitArrayType(node, { self }) {
        return getArrayLikeSize(node.count, visit(node.item, self), self);
      },
      visitConstantValue(node, { self }) {
        const typeSize = visit(node.type, self);
        if (typeSize !== null) return typeSize;
        if (nodes.isNode(node.value, "bytesValueNode") && node.value.encoding === "base16") {
          return Math.ceil(node.value.data.length / 2);
        }
        if (nodes.isNode(node.type, "stringTypeNode") && node.type.encoding === "base16" && nodes.isNode(node.value, "stringValueNode")) {
          return Math.ceil(node.value.string.length / 2);
        }
        return null;
      },
      visitDefinedType(node, { self }) {
        if (visitedDefinedTypes.has(node.name)) {
          return visitedDefinedTypes.get(node.name);
        }
        definedTypeStack.push(node.name);
        const child = visit(node.type, self);
        definedTypeStack.pop();
        visitedDefinedTypes.set(node.name, child);
        return child;
      },
      visitDefinedTypeLink(node, { self }) {
        const linkedDefinedPath = linkables.getPath(stack.getPath(node.kind));
        if (!linkedDefinedPath) return null;
        const linkedDefinedType = getLastNodeFromPath(linkedDefinedPath);
        if (definedTypeStack.includes(linkedDefinedType.name)) return null;
        stack.pushPath(linkedDefinedPath);
        const result = visit(linkedDefinedType, self);
        stack.popPath();
        return result;
      },
      visitEnumEmptyVariantType() {
        return 0;
      },
      visitEnumType(node, { self }) {
        const prefix = visit(node.size, self);
        if (prefix === null) return null;
        if (nodes.isScalarEnum(node)) return prefix;
        const variantSizes = node.variants.map((v2) => visit(v2, self));
        const allVariantHaveTheSameFixedSize = variantSizes.every((one, _, all) => one === all[0]);
        return allVariantHaveTheSameFixedSize && variantSizes.length > 0 && variantSizes[0] !== null ? variantSizes[0] + prefix : null;
      },
      visitFixedSizeType(node) {
        return node.size;
      },
      visitInstruction(node, { self }) {
        return sumSizes(node.arguments.map((arg) => visit(arg, self)));
      },
      visitInstructionArgument(node, { self }) {
        return visit(node.type, self);
      },
      visitMapType(node, { self }) {
        const innerSize = sumSizes([visit(node.key, self), visit(node.value, self)]);
        return getArrayLikeSize(node.count, innerSize, self);
      },
      visitNumberType(node) {
        if (node.format === "shortU16") return null;
        return parseInt(node.format.slice(1), 10) / 8;
      },
      visitOptionType(node, { self }) {
        if (!node.fixed) return null;
        return sumSizes([visit(node.prefix, self), visit(node.item, self)]);
      },
      visitPostOffsetType(node, { self }) {
        const typeSize = visit(node.type, self);
        return node.strategy === "padded" ? sumSizes([typeSize, node.offset]) : typeSize;
      },
      visitPreOffsetType(node, { self }) {
        const typeSize = visit(node.type, self);
        return node.strategy === "padded" ? sumSizes([typeSize, node.offset]) : typeSize;
      },
      visitPublicKeyType() {
        return 32;
      },
      visitRemainderOptionType(node, { self }) {
        const itemSize = visit(node.item, self);
        return itemSize === 0 ? 0 : null;
      },
      visitSetType(node, { self }) {
        return getArrayLikeSize(node.count, visit(node.item, self), self);
      },
      visitZeroableOptionType(node, { self }) {
        const itemSize = visit(node.item, self);
        if (!node.zeroValue) return itemSize;
        const zeroSize = visit(node.zeroValue, self);
        return zeroSize === itemSize ? itemSize : null;
      }
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}
function getArrayLikeSize(count, innerSize, self) {
  if (innerSize === 0 && nodes.isNode(count, "prefixedCountNode")) return visit(count.prefix, self);
  if (innerSize === 0) return 0;
  if (!nodes.isNode(count, "fixedCountNode")) return null;
  if (count.value === 0) return 0;
  return innerSize !== null ? innerSize * count.value : null;
}

// src/getDebugStringVisitor.ts
function getDebugStringVisitor(options = {}) {
  const indent = options.indent ?? false;
  const indentSeparator = options.indentSeparator ?? "|   ";
  let stackLevel = -1;
  return pipe(
    mergeVisitor(
      (node) => {
        const details = getNodeDetails(node).join(".");
        if (indent) {
          return `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ""}`;
        }
        return `${node.kind}${details ? `[${details}]` : ""}`;
      },
      (node, values) => {
        const details = getNodeDetails(node).join(".");
        if (indent) {
          return [
            `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ""}`,
            ...values
          ].join("\n");
        }
        return `${node.kind}${details ? `[${details}]` : ""}(${values.join(", ")})`;
      }
    ),
    (v) => interceptVisitor(v, (node, next) => {
      stackLevel += 1;
      const newNode = next(node);
      stackLevel -= 1;
      return newNode;
    })
  );
}
function getNodeDetails(node) {
  switch (node.kind) {
    case "programNode":
      return [node.name, node.publicKey];
    case "instructionAccountNode":
      return [
        node.name,
        ...node.isWritable ? ["writable"] : [],
        ...node.isSigner === true ? ["signer"] : [],
        ...node.isSigner === "either" ? ["optionalSigner"] : [],
        ...node.isOptional ? ["optional"] : []
      ];
    case "instructionRemainingAccountsNode":
      return [
        ...node.isOptional ? ["optional"] : [],
        ...node.isWritable ? ["writable"] : [],
        ...node.isSigner === true ? ["signer"] : [],
        ...node.isSigner === "either" ? ["optionalSigner"] : []
      ];
    case "instructionByteDeltaNode":
      return [...node.subtract ? ["subtract"] : [], ...node.withHeader ? ["withHeader"] : []];
    case "instructionStatusNode":
      return [node.lifecycle, ...node.message ? [node.message] : []];
    case "errorNode":
      return [node.code.toString(), node.name];
    case "accountLinkNode":
    case "definedTypeLinkNode":
    case "instructionAccountLinkNode":
    case "instructionArgumentLinkNode":
    case "instructionLinkNode":
    case "pdaLinkNode":
    case "programLinkNode":
      return [node.name];
    case "numberTypeNode":
      return [node.format, ...node.endian === "be" ? ["bigEndian"] : []];
    case "amountTypeNode":
      return [node.decimals.toString(), ...node.unit ? [node.unit] : []];
    case "stringTypeNode":
      return [node.encoding];
    case "optionTypeNode":
      return node.fixed ? ["fixed"] : [];
    case "fixedCountNode":
      return [node.value.toString()];
    case "numberValueNode":
      return [node.number.toString()];
    case "stringValueNode":
      return [node.string];
    case "booleanValueNode":
      return [node.boolean ? "true" : "false"];
    case "bytesValueNode":
      return [node.encoding, node.data];
    case "publicKeyValueNode":
      return [...node.identifier ? [`${node.identifier}`] : [], node.publicKey];
    case "enumValueNode":
      return [node.variant];
    case "resolverValueNode":
      return [node.name];
    case "constantDiscriminatorNode":
      return [...node.offset > 0 ? [`offset:${node.offset}`] : []];
    case "fieldDiscriminatorNode":
      return [node.name, ...node.offset > 0 ? [`offset:${node.offset}`] : []];
    case "sizeDiscriminatorNode":
      return [node.size.toString()];
    case "fixedSizeTypeNode":
      return [node.size.toString()];
    case "preOffsetTypeNode":
      return [node.offset.toString(), node.strategy ?? "relative"];
    case "postOffsetTypeNode":
      return [node.offset.toString(), node.strategy ?? "relative"];
    default:
      return "name" in node ? [node.name] : [];
  }
}
function getMaxByteSizeVisitor(linkables, options = {}) {
  const stack = options.stack ?? new NodeStack();
  const visitedDefinedTypes = /* @__PURE__ */ new Map();
  const definedTypeStack = [];
  const sumSizes = (values) => values.reduce((all, one) => all === null || one === null ? null : all + one, 0);
  const baseVisitor = mergeVisitor(
    () => null,
    (_, values) => sumSizes(values),
    {
      keys: [
        ...nodes.REGISTERED_TYPE_NODE_KINDS,
        "accountNode",
        "constantValueNode",
        "definedTypeLinkNode",
        "definedTypeNode",
        "instructionArgumentNode",
        "instructionNode"
      ]
    }
  );
  return pipe(
    baseVisitor,
    (v) => extendVisitor(v, {
      visitAccount(node, { self }) {
        return visit(node.data, self);
      },
      visitArrayType(node, { self }) {
        return getArrayLikeSize2(node.count, visit(node.item, self), self);
      },
      visitConstantValue(node, { self }) {
        const typeSize = visit(node.type, self);
        if (typeSize !== null) return typeSize;
        if (nodes.isNode(node.value, "bytesValueNode") && node.value.encoding === "base16") {
          return Math.ceil(node.value.data.length / 2);
        }
        if (nodes.isNode(node.type, "stringTypeNode") && node.type.encoding === "base16" && nodes.isNode(node.value, "stringValueNode")) {
          return Math.ceil(node.value.string.length / 2);
        }
        return null;
      },
      visitDefinedType(node, { self }) {
        if (visitedDefinedTypes.has(node.name)) {
          return visitedDefinedTypes.get(node.name);
        }
        definedTypeStack.push(node.name);
        const child = visit(node.type, self);
        definedTypeStack.pop();
        visitedDefinedTypes.set(node.name, child);
        return child;
      },
      visitDefinedTypeLink(node, { self }) {
        const linkedDefinedPath = linkables.getPath(stack.getPath(node.kind));
        if (!linkedDefinedPath) return null;
        const linkedDefinedType = getLastNodeFromPath(linkedDefinedPath);
        if (definedTypeStack.includes(linkedDefinedType.name)) return null;
        stack.pushPath(linkedDefinedPath);
        const result = visit(linkedDefinedType, self);
        stack.popPath();
        return result;
      },
      visitEnumEmptyVariantType() {
        return 0;
      },
      visitEnumType(node, { self }) {
        const prefix = visit(node.size, self);
        if (prefix === null) return null;
        if (nodes.isScalarEnum(node)) return prefix;
        const variantSizes = node.variants.map((v2) => visit(v2, self));
        if (variantSizes.includes(null)) return null;
        const maxVariantSize = Math.max(...variantSizes);
        return prefix + maxVariantSize;
      },
      visitFixedSizeType(node) {
        return node.size;
      },
      visitInstruction(node, { self }) {
        return sumSizes(node.arguments.map((arg) => visit(arg, self)));
      },
      visitInstructionArgument(node, { self }) {
        return visit(node.type, self);
      },
      visitMapType(node, { self }) {
        const innerSize = sumSizes([visit(node.key, self), visit(node.value, self)]);
        return getArrayLikeSize2(node.count, innerSize, self);
      },
      visitNumberType(node) {
        if (node.format === "shortU16") return 3;
        return parseInt(node.format.slice(1), 10) / 8;
      },
      visitOptionType(node, { self }) {
        return sumSizes([visit(node.prefix, self), visit(node.item, self)]);
      },
      visitPostOffsetType(node, { self }) {
        const typeSize = visit(node.type, self);
        return node.strategy === "padded" ? sumSizes([typeSize, node.offset]) : typeSize;
      },
      visitPreOffsetType(node, { self }) {
        const typeSize = visit(node.type, self);
        return node.strategy === "padded" ? sumSizes([typeSize, node.offset]) : typeSize;
      },
      visitPublicKeyType() {
        return 32;
      },
      visitRemainderOptionType(node, { self }) {
        const itemSize = visit(node.item, self);
        return itemSize === 0 ? 0 : null;
      },
      visitSetType(node, { self }) {
        return getArrayLikeSize2(node.count, visit(node.item, self), self);
      },
      visitZeroableOptionType(node, { self }) {
        const itemSize = visit(node.item, self);
        if (!node.zeroValue) return itemSize;
        const zeroSize = visit(node.zeroValue, self);
        if (itemSize === null || zeroSize === null) return null;
        return Math.max(itemSize, zeroSize);
      }
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}
function getArrayLikeSize2(count, innerSize, self) {
  if (innerSize === 0 && nodes.isNode(count, "prefixedCountNode")) return visit(count.prefix, self);
  if (innerSize === 0) return 0;
  if (!nodes.isNode(count, "fixedCountNode")) return null;
  if (count.value === 0) return 0;
  return innerSize !== null ? innerSize * count.value : null;
}

// src/singleNodeVisitor.ts
function singleNodeVisitor(key, fn) {
  const visitor = {};
  visitor[getVisitFunctionName(key)] = fn;
  return visitor;
}
function rootNodeVisitor(fn) {
  return singleNodeVisitor("rootNode", fn);
}

// src/getResolvedInstructionInputsVisitor.ts
function getResolvedInstructionInputsVisitor(options = {}) {
  const includeDataArgumentValueNodes = options.includeDataArgumentValueNodes ?? false;
  let stack = [];
  let resolved = [];
  let visitedAccounts = /* @__PURE__ */ new Map();
  let visitedArgs = /* @__PURE__ */ new Map();
  function resolveInstructionInput(instruction, input) {
    if (nodes.isNode(input, "instructionAccountNode") && visitedAccounts.has(input.name) || nodes.isNode(input, "instructionArgumentNode") && visitedArgs.has(input.name)) {
      return;
    }
    const isCircular = stack.some(({ kind, name }) => kind === input.kind && name === input.name);
    if (isCircular) {
      const cycle = [...stack, input];
      throw new errors.CodamaError(
        errors.CODAMA_ERROR__VISITORS__CYCLIC_DEPENDENCY_DETECTED_WHEN_RESOLVING_INSTRUCTION_DEFAULT_VALUES,
        {
          cycle,
          formattedCycle: cycle.map(({ name }) => name).join(" -> "),
          instruction,
          instructionName: instruction.name
        }
      );
    }
    stack.push(input);
    const localResolved = input.kind === "instructionAccountNode" ? resolveInstructionAccount(instruction, input) : resolveInstructionArgument(instruction, input);
    stack.pop();
    resolved.push(localResolved);
    if (localResolved.kind === "instructionAccountNode") {
      visitedAccounts.set(input.name, localResolved);
    } else {
      visitedArgs.set(input.name, localResolved);
    }
  }
  function resolveInstructionAccount(instruction, account) {
    const dependsOn = getInstructionDependencies(account);
    resolveInstructionDependencies(instruction, account, dependsOn);
    const localResolved = {
      ...account,
      dependsOn,
      isPda: nodes.getAllInstructionArguments(instruction).some(
        (argument) => nodes.isNode(argument.defaultValue, "accountBumpValueNode") && argument.defaultValue.name === account.name
      ),
      resolvedIsOptional: !!account.isOptional,
      resolvedIsSigner: account.isSigner
    };
    switch (localResolved.defaultValue?.kind) {
      case "accountValueNode":
        const defaultAccount = visitedAccounts.get(localResolved.defaultValue.name);
        const resolvedIsPublicKey = account.isSigner === false && defaultAccount.isSigner === false;
        const resolvedIsSigner = account.isSigner === true && defaultAccount.isSigner === true;
        const resolvedIsOptionalSigner = !resolvedIsPublicKey && !resolvedIsSigner;
        localResolved.resolvedIsSigner = resolvedIsOptionalSigner ? "either" : resolvedIsSigner;
        localResolved.resolvedIsOptional = !!defaultAccount.isOptional;
        break;
      case "publicKeyValueNode":
      case "programLinkNode":
      case "programIdValueNode":
        localResolved.resolvedIsSigner = account.isSigner === false ? false : "either";
        localResolved.resolvedIsOptional = false;
        break;
      case "pdaValueNode":
        localResolved.resolvedIsSigner = account.isSigner === false ? false : "either";
        localResolved.resolvedIsOptional = false;
        const { seeds } = localResolved.defaultValue;
        seeds.forEach((seed) => {
          if (!nodes.isNode(seed.value, "accountValueNode")) return;
          const dependency = visitedAccounts.get(seed.value.name);
          if (dependency.resolvedIsOptional) {
            throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__CANNOT_USE_OPTIONAL_ACCOUNT_AS_PDA_SEED_VALUE, {
              instruction,
              instructionAccount: account,
              instructionAccountName: account.name,
              instructionName: instruction.name,
              seed,
              seedName: seed.name,
              seedValueName: seed.value.name
            });
          }
        });
        break;
      case "identityValueNode":
      case "payerValueNode":
      case "resolverValueNode":
        localResolved.resolvedIsOptional = false;
        break;
    }
    return localResolved;
  }
  function resolveInstructionArgument(instruction, argument) {
    const dependsOn = getInstructionDependencies(argument);
    resolveInstructionDependencies(instruction, argument, dependsOn);
    return { ...argument, dependsOn };
  }
  function resolveInstructionDependencies(instruction, parent, dependencies) {
    dependencies.forEach((dependency) => {
      let input = null;
      if (nodes.isNode(dependency, "accountValueNode")) {
        const dependencyAccount = instruction.accounts.find((a) => a.name === dependency.name);
        if (!dependencyAccount) {
          throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {
            dependency,
            dependencyKind: dependency.kind,
            dependencyName: dependency.name,
            instruction,
            instructionName: instruction.name,
            parent,
            parentKind: parent.kind,
            parentName: parent.name
          });
        }
        input = { ...dependencyAccount };
      } else if (nodes.isNode(dependency, "argumentValueNode")) {
        const dependencyArgument = nodes.getAllInstructionArguments(instruction).find(
          (a) => a.name === dependency.name
        );
        if (!dependencyArgument) {
          throw new errors.CodamaError(errors.CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {
            dependency,
            dependencyKind: dependency.kind,
            dependencyName: dependency.name,
            instruction,
            instructionName: instruction.name,
            parent,
            parentKind: parent.kind,
            parentName: parent.name
          });
        }
        input = { ...dependencyArgument };
      }
      if (input) {
        resolveInstructionInput(instruction, input);
      }
    });
  }
  return singleNodeVisitor("instructionNode", (node) => {
    stack = [];
    resolved = [];
    visitedAccounts = /* @__PURE__ */ new Map();
    visitedArgs = /* @__PURE__ */ new Map();
    const inputs = [
      ...node.accounts,
      ...node.arguments.filter((a) => {
        if (includeDataArgumentValueNodes) return a.defaultValue;
        return a.defaultValue && !nodes.isNode(a.defaultValue, nodes.VALUE_NODES);
      }),
      ...(node.extraArguments ?? []).filter((a) => a.defaultValue)
    ];
    inputs.forEach((input) => {
      resolveInstructionInput(node, input);
    });
    return resolved;
  });
}
function deduplicateInstructionDependencies(dependencies) {
  const accounts = /* @__PURE__ */ new Map();
  const args = /* @__PURE__ */ new Map();
  dependencies.forEach((dependency) => {
    if (nodes.isNode(dependency, "accountValueNode")) {
      accounts.set(dependency.name, dependency);
    } else if (nodes.isNode(dependency, "argumentValueNode")) {
      args.set(dependency.name, dependency);
    }
  });
  return [...accounts.values(), ...args.values()];
}
function getInstructionDependencies(input) {
  if (nodes.isNode(input, "instructionNode")) {
    return deduplicateInstructionDependencies([
      ...input.accounts.flatMap(getInstructionDependencies),
      ...input.arguments.flatMap(getInstructionDependencies),
      ...(input.extraArguments ?? []).flatMap(getInstructionDependencies)
    ]);
  }
  if (!input.defaultValue) return [];
  const getNestedDependencies = (defaultValue) => {
    if (!defaultValue) return [];
    return getInstructionDependencies({ ...input, defaultValue });
  };
  if (nodes.isNode(input.defaultValue, ["accountValueNode", "accountBumpValueNode"])) {
    return [nodes.accountValueNode(input.defaultValue.name)];
  }
  if (nodes.isNode(input.defaultValue, ["argumentValueNode"])) {
    return [nodes.argumentValueNode(input.defaultValue.name)];
  }
  if (nodes.isNode(input.defaultValue, "pdaValueNode")) {
    const dependencies = /* @__PURE__ */ new Map();
    input.defaultValue.seeds.forEach((seed) => {
      if (nodes.isNode(seed.value, ["accountValueNode", "argumentValueNode"])) {
        dependencies.set(seed.value.name, { ...seed.value });
      }
    });
    return [
      ...dependencies.values(),
      ...input.defaultValue.programId ? [input.defaultValue.programId] : []
    ];
  }
  if (nodes.isNode(input.defaultValue, "resolverValueNode")) {
    return input.defaultValue.dependsOn ?? [];
  }
  if (nodes.isNode(input.defaultValue, "conditionalValueNode")) {
    return deduplicateInstructionDependencies([
      ...getNestedDependencies(input.defaultValue.condition),
      ...getNestedDependencies(input.defaultValue.ifTrue),
      ...getNestedDependencies(input.defaultValue.ifFalse)
    ]);
  }
  return [];
}

// src/nonNullableIdentityVisitor.ts
function nonNullableIdentityVisitor(options = {}) {
  return identityVisitor(options);
}

// src/removeDocsVisitor.ts
function removeDocsVisitor(options = {}) {
  return interceptVisitor(nonNullableIdentityVisitor(options), (node, next) => {
    if ("docs" in node) {
      return next({ ...node, docs: [] });
    }
    return next(node);
  });
}

// src/getUniqueHashStringVisitor.ts
function getUniqueHashStringVisitor(options = {}) {
  const removeDocs = options.removeDocs ?? false;
  if (!removeDocs) {
    return staticVisitor((node) => stringify__default.default(node));
  }
  return mapVisitor(removeDocsVisitor(), (node) => stringify__default.default(node));
}

// src/interceptFirstVisitVisitor.ts
function interceptFirstVisitVisitor(visitor, interceptor) {
  let isFirstVisit = true;
  return interceptVisitor(visitor, (node, next) => {
    try {
      if (isFirstVisit) {
        isFirstVisit = false;
        const result = interceptor(node, next);
        isFirstVisit = true;
        return result;
      }
      return next(node);
    } catch (error) {
      isFirstVisit = true;
      throw error;
    }
  });
}
var LINKABLE_NODES = [
  "accountNode",
  "definedTypeNode",
  "instructionAccountNode",
  "instructionArgumentNode",
  "instructionNode",
  "pdaNode",
  "programNode"
];
var LinkableDictionary = class {
  programs = /* @__PURE__ */ new Map();
  recordPath(linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const programDictionary = this.getOrCreateProgramDictionary(linkablePath);
    if (!programDictionary) return this;
    const instructionDictionary = this.getOrCreateInstructionDictionary(programDictionary, linkablePath);
    if (isNodePath(linkablePath, "accountNode")) {
      programDictionary.accounts.set(linkableNode.name, linkablePath);
    } else if (isNodePath(linkablePath, "definedTypeNode")) {
      programDictionary.definedTypes.set(linkableNode.name, linkablePath);
    } else if (isNodePath(linkablePath, "pdaNode")) {
      programDictionary.pdas.set(linkableNode.name, linkablePath);
    } else if (instructionDictionary && isNodePath(linkablePath, "instructionAccountNode")) {
      instructionDictionary.accounts.set(linkableNode.name, linkablePath);
    } else if (instructionDictionary && isNodePath(linkablePath, "instructionArgumentNode")) {
      instructionDictionary.arguments.set(linkableNode.name, linkablePath);
    }
    return this;
  }
  getPathOrThrow(linkPath) {
    const linkablePath = this.getPath(linkPath);
    if (!linkablePath) {
      const linkNode = getLastNodeFromPath(linkPath);
      throw new errors.CodamaError(errors.CODAMA_ERROR__LINKED_NODE_NOT_FOUND, {
        kind: linkNode.kind,
        linkNode,
        name: linkNode.name,
        path: linkPath
      });
    }
    return linkablePath;
  }
  getPath(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    const programDictionary = this.getProgramDictionary(linkPath);
    if (!programDictionary) return void 0;
    const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);
    if (nodes.isNode(linkNode, "accountLinkNode")) {
      return programDictionary.accounts.get(linkNode.name);
    } else if (nodes.isNode(linkNode, "definedTypeLinkNode")) {
      return programDictionary.definedTypes.get(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionAccountLinkNode")) {
      return instructionDictionary?.accounts.get(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionArgumentLinkNode")) {
      return instructionDictionary?.arguments.get(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionLinkNode")) {
      return instructionDictionary?.instruction;
    } else if (nodes.isNode(linkNode, "pdaLinkNode")) {
      return programDictionary.pdas.get(linkNode.name);
    } else if (nodes.isNode(linkNode, "programLinkNode")) {
      return programDictionary.program;
    }
    return void 0;
  }
  getOrThrow(linkPath) {
    return getLastNodeFromPath(this.getPathOrThrow(linkPath));
  }
  get(linkPath) {
    const path = this.getPath(linkPath);
    return path ? getLastNodeFromPath(path) : void 0;
  }
  has(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    const programDictionary = this.getProgramDictionary(linkPath);
    if (!programDictionary) return false;
    const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);
    if (nodes.isNode(linkNode, "accountLinkNode")) {
      return programDictionary.accounts.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "definedTypeLinkNode")) {
      return programDictionary.definedTypes.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionAccountLinkNode")) {
      return !!instructionDictionary && instructionDictionary.accounts.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionArgumentLinkNode")) {
      return !!instructionDictionary && instructionDictionary.arguments.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "instructionLinkNode")) {
      return programDictionary.instructions.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "pdaLinkNode")) {
      return programDictionary.pdas.has(linkNode.name);
    } else if (nodes.isNode(linkNode, "programLinkNode")) {
      return true;
    }
    return false;
  }
  getOrCreateProgramDictionary(linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const programNode2 = nodes.isNode(linkableNode, "programNode") ? linkableNode : findProgramNodeFromPath(linkablePath);
    if (!programNode2) return void 0;
    let programDictionary = this.programs.get(programNode2.name);
    if (!programDictionary) {
      programDictionary = {
        accounts: /* @__PURE__ */ new Map(),
        definedTypes: /* @__PURE__ */ new Map(),
        instructions: /* @__PURE__ */ new Map(),
        pdas: /* @__PURE__ */ new Map(),
        program: getNodePathUntilLastNode(linkablePath, "programNode")
      };
      this.programs.set(programNode2.name, programDictionary);
    }
    return programDictionary;
  }
  getOrCreateInstructionDictionary(programDictionary, linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const instructionNode2 = nodes.isNode(linkableNode, "instructionNode") ? linkableNode : findInstructionNodeFromPath(linkablePath);
    if (!instructionNode2) return void 0;
    let instructionDictionary = programDictionary.instructions.get(instructionNode2.name);
    if (!instructionDictionary) {
      instructionDictionary = {
        accounts: /* @__PURE__ */ new Map(),
        arguments: /* @__PURE__ */ new Map(),
        instruction: getNodePathUntilLastNode(linkablePath, "instructionNode")
      };
      programDictionary.instructions.set(instructionNode2.name, instructionDictionary);
    }
    return instructionDictionary;
  }
  getProgramDictionary(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    let programName = void 0;
    if (nodes.isNode(linkNode, "programLinkNode")) {
      programName = linkNode.name;
    } else if ("program" in linkNode) {
      programName = linkNode.program?.name;
    } else if ("instruction" in linkNode) {
      programName = linkNode.instruction?.program?.name;
    }
    programName = programName ?? findProgramNodeFromPath(linkPath)?.name;
    return programName ? this.programs.get(programName) : void 0;
  }
  getInstructionDictionary(programDictionary, linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    let instructionName = void 0;
    if (nodes.isNode(linkNode, "instructionLinkNode")) {
      instructionName = linkNode.name;
    } else if ("instruction" in linkNode) {
      instructionName = linkNode.instruction?.name;
    }
    instructionName = instructionName ?? findInstructionNodeFromPath(linkPath)?.name;
    return instructionName ? programDictionary.instructions.get(instructionName) : void 0;
  }
};

// src/voidVisitor.ts
function voidVisitor(options = {}) {
  return mergeVisitor(
    () => void 0,
    () => void 0,
    options
  );
}

// src/recordLinkablesVisitor.ts
function getRecordLinkablesVisitor(linkables) {
  const stack = new NodeStack();
  return pipe(
    voidVisitor(),
    (v) => interceptVisitor(v, (node, next) => {
      if (nodes.isNode(node, LINKABLE_NODES)) {
        linkables.recordPath(stack.getPath(LINKABLE_NODES));
      }
      return next(node);
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}
function recordLinkablesOnFirstVisitVisitor(visitor, linkables) {
  const recordingVisitor = getRecordLinkablesVisitor(linkables);
  return pipe(
    visitor,
    (v) => interceptFirstVisitVisitor(v, (node, next) => {
      visit(node, recordingVisitor);
      return next(node);
    })
  );
}

// src/tapVisitor.ts
function tapVisitor(visitor, key, tap) {
  const newVisitor = { ...visitor };
  newVisitor[getVisitFunctionName(key)] = function tappedVisitNode(node) {
    tap(node);
    const parentFunction = visitor[getVisitFunctionName(key)];
    return parentFunction.bind(this)(node);
  };
  return newVisitor;
}

exports.LINKABLE_NODES = LINKABLE_NODES;
exports.LinkableDictionary = LinkableDictionary;
exports.NodeStack = NodeStack;
exports.assertIsNodePath = assertIsNodePath;
exports.bottomUpTransformerVisitor = bottomUpTransformerVisitor;
exports.consoleLogVisitor = consoleLogVisitor;
exports.deduplicateInstructionDependencies = deduplicateInstructionDependencies;
exports.deleteNodesVisitor = deleteNodesVisitor;
exports.extendVisitor = extendVisitor;
exports.findFirstNodeFromPath = findFirstNodeFromPath;
exports.findInstructionNodeFromPath = findInstructionNodeFromPath;
exports.findLastNodeFromPath = findLastNodeFromPath;
exports.findProgramNodeFromPath = findProgramNodeFromPath;
exports.getByteSizeVisitor = getByteSizeVisitor;
exports.getConjunctiveNodeSelectorFunction = getConjunctiveNodeSelectorFunction;
exports.getDebugStringVisitor = getDebugStringVisitor;
exports.getInstructionDependencies = getInstructionDependencies;
exports.getLastNodeFromPath = getLastNodeFromPath;
exports.getMaxByteSizeVisitor = getMaxByteSizeVisitor;
exports.getNodePathUntilLastNode = getNodePathUntilLastNode;
exports.getNodeSelectorFunction = getNodeSelectorFunction;
exports.getRecordLinkablesVisitor = getRecordLinkablesVisitor;
exports.getResolvedInstructionInputsVisitor = getResolvedInstructionInputsVisitor;
exports.getUniqueHashStringVisitor = getUniqueHashStringVisitor;
exports.getVisitFunctionName = getVisitFunctionName;
exports.identityVisitor = identityVisitor;
exports.interceptFirstVisitVisitor = interceptFirstVisitVisitor;
exports.interceptVisitor = interceptVisitor;
exports.isFilledNodePath = isFilledNodePath;
exports.isNodePath = isNodePath;
exports.mapVisitor = mapVisitor;
exports.mergeVisitor = mergeVisitor;
exports.nodePathToString = nodePathToString;
exports.nodePathToStringArray = nodePathToStringArray;
exports.nonNullableIdentityVisitor = nonNullableIdentityVisitor;
exports.pipe = pipe;
exports.recordLinkablesOnFirstVisitVisitor = recordLinkablesOnFirstVisitVisitor;
exports.recordNodeStackVisitor = recordNodeStackVisitor;
exports.removeDocsVisitor = removeDocsVisitor;
exports.rootNodeVisitor = rootNodeVisitor;
exports.singleNodeVisitor = singleNodeVisitor;
exports.staticVisitor = staticVisitor;
exports.tapVisitor = tapVisitor;
exports.topDownTransformerVisitor = topDownTransformerVisitor;
exports.visit = visit;
exports.visitOrElse = visitOrElse;
exports.voidVisitor = voidVisitor;
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map