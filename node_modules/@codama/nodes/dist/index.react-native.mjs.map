{"version":3,"sources":["../src/shared/docs.ts","../src/shared/stringCases.ts","../src/contextualValueNodes/AccountBumpValueNode.ts","../src/contextualValueNodes/AccountValueNode.ts","../src/contextualValueNodes/ArgumentValueNode.ts","../src/contextualValueNodes/ConditionalValueNode.ts","../src/valueNodes/ValueNode.ts","../src/contextualValueNodes/ContextualValueNode.ts","../src/contextualValueNodes/IdentityValueNode.ts","../src/contextualValueNodes/PayerValueNode.ts","../src/contextualValueNodes/PdaSeedValueNode.ts","../src/linkNodes/ProgramLinkNode.ts","../src/linkNodes/AccountLinkNode.ts","../src/linkNodes/DefinedTypeLinkNode.ts","../src/linkNodes/InstructionLinkNode.ts","../src/linkNodes/InstructionAccountLinkNode.ts","../src/linkNodes/InstructionArgumentLinkNode.ts","../src/linkNodes/LinkNode.ts","../src/linkNodes/PdaLinkNode.ts","../src/contextualValueNodes/PdaValueNode.ts","../src/contextualValueNodes/ProgramIdValueNode.ts","../src/contextualValueNodes/ResolverValueNode.ts","../src/countNodes/CountNode.ts","../src/countNodes/FixedCountNode.ts","../src/countNodes/PrefixedCountNode.ts","../src/countNodes/RemainderCountNode.ts","../src/discriminatorNodes/ConstantDiscriminatorNode.ts","../src/discriminatorNodes/DiscriminatorNode.ts","../src/discriminatorNodes/FieldDiscriminatorNode.ts","../src/discriminatorNodes/SizeDiscriminatorNode.ts","../src/typeNodes/BytesTypeNode.ts","../src/typeNodes/PublicKeyTypeNode.ts","../src/typeNodes/StringTypeNode.ts","../src/valueNodes/BytesValueNode.ts","../src/valueNodes/StringValueNode.ts","../src/pdaSeedNodes/ConstantPdaSeedNode.ts","../src/pdaSeedNodes/PdaSeedNode.ts","../src/pdaSeedNodes/VariablePdaSeedNode.ts","../src/typeNodes/AmountTypeNode.ts","../src/typeNodes/ArrayTypeNode.ts","../src/typeNodes/NumberTypeNode.ts","../src/typeNodes/BooleanTypeNode.ts","../src/typeNodes/DateTimeTypeNode.ts","../src/typeNodes/EnumEmptyVariantTypeNode.ts","../src/typeNodes/EnumStructVariantTypeNode.ts","../src/typeNodes/EnumTupleVariantTypeNode.ts","../src/typeNodes/EnumTypeNode.ts","../src/typeNodes/EnumVariantTypeNode.ts","../src/typeNodes/FixedSizeTypeNode.ts","../src/typeNodes/HiddenPrefixTypeNode.ts","../src/typeNodes/HiddenSuffixTypeNode.ts","../src/typeNodes/MapTypeNode.ts","../src/typeNodes/TypeNode.ts","../src/Node.ts","../src/typeNodes/NestedTypeNode.ts","../src/typeNodes/OptionTypeNode.ts","../src/typeNodes/PostOffsetTypeNode.ts","../src/typeNodes/PreOffsetTypeNode.ts","../src/typeNodes/RemainderOptionTypeNode.ts","../src/typeNodes/SentinelTypeNode.ts","../src/typeNodes/SetTypeNode.ts","../src/typeNodes/SizePrefixTypeNode.ts","../src/typeNodes/SolAmountTypeNode.ts","../src/typeNodes/StructFieldTypeNode.ts","../src/typeNodes/StructTypeNode.ts","../src/typeNodes/TupleTypeNode.ts","../src/typeNodes/ZeroableOptionTypeNode.ts","../src/valueNodes/ArrayValueNode.ts","../src/valueNodes/BooleanValueNode.ts","../src/valueNodes/ConstantValueNode.ts","../src/valueNodes/EnumValueNode.ts","../src/valueNodes/MapEntryValueNode.ts","../src/valueNodes/MapValueNode.ts","../src/valueNodes/NoneValueNode.ts","../src/valueNodes/NumberValueNode.ts","../src/valueNodes/PublicKeyValueNode.ts","../src/valueNodes/SetValueNode.ts","../src/valueNodes/SomeValueNode.ts","../src/valueNodes/StructFieldValueNode.ts","../src/valueNodes/StructValueNode.ts","../src/valueNodes/TupleValueNode.ts","../src/AccountNode.ts","../src/DefinedTypeNode.ts","../src/ErrorNode.ts","../src/InstructionAccountNode.ts","../src/InstructionArgumentNode.ts","../src/InstructionByteDeltaNode.ts","../src/ProgramNode.ts","../src/InstructionNode.ts","../src/InstructionRemainingAccountsNode.ts","../src/InstructionStatusNode.ts","../src/PdaNode.ts","../src/RootNode.ts"],"names":["CodamaError"],"mappings":"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","file":"index.react-native.mjs","sourcesContent":["import type { Docs } from '@codama/node-types';\n\nexport type DocsInput = string[] | string;\n\nexport function parseDocs(docs: DocsInput | null | undefined): Docs {\n    if (docs === null || docs === undefined) return [];\n    return Array.isArray(docs) ? docs : [docs];\n}\n","import type {\n    CamelCaseString,\n    KebabCaseString,\n    PascalCaseString,\n    SnakeCaseString,\n    TitleCaseString,\n} from '@codama/node-types';\n\nexport function capitalize(str: string): string {\n    if (str.length === 0) return str;\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\nexport function titleCase(str: string): TitleCaseString {\n    return str\n        .replace(/([A-Z])/g, ' $1')\n        .split(/[^a-zA-Z0-9]+/)\n        .filter(word => word.length > 0)\n        .map(capitalize)\n        .join(' ') as TitleCaseString;\n}\n\nexport function pascalCase(str: string): PascalCaseString {\n    return titleCase(str).split(' ').join('') as PascalCaseString;\n}\n\nexport function camelCase(str: string): CamelCaseString {\n    if (str.length === 0) return str as CamelCaseString;\n    const pascalStr = pascalCase(str);\n    return (pascalStr.charAt(0).toLowerCase() + pascalStr.slice(1)) as CamelCaseString;\n}\n\nexport function kebabCase(str: string): KebabCaseString {\n    return titleCase(str).split(' ').join('-').toLowerCase() as KebabCaseString;\n}\n\nexport function snakeCase(str: string): SnakeCaseString {\n    return titleCase(str).split(' ').join('_').toLowerCase() as SnakeCaseString;\n}\n","import type { AccountBumpValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function accountBumpValueNode(name: string): AccountBumpValueNode {\n    return Object.freeze({\n        kind: 'accountBumpValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { AccountValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function accountValueNode(name: string): AccountValueNode {\n    return Object.freeze({\n        kind: 'accountValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { ArgumentValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function argumentValueNode(name: string): ArgumentValueNode {\n    return Object.freeze({\n        kind: 'argumentValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type {\n    AccountValueNode,\n    ArgumentValueNode,\n    ConditionalValueNode,\n    InstructionInputValueNode,\n    ResolverValueNode,\n    ValueNode,\n} from '@codama/node-types';\n\ntype ConditionNode = AccountValueNode | ArgumentValueNode | ResolverValueNode;\n\nexport function conditionalValueNode<\n    TCondition extends ConditionNode,\n    TValue extends ValueNode | undefined = undefined,\n    TIfTrue extends InstructionInputValueNode | undefined = undefined,\n    TIfFalse extends InstructionInputValueNode | undefined = undefined,\n>(input: {\n    condition: TCondition;\n    ifFalse?: TIfFalse;\n    ifTrue?: TIfTrue;\n    value?: TValue;\n}): ConditionalValueNode<TCondition, TValue, TIfTrue, TIfFalse> {\n    return Object.freeze({\n        kind: 'conditionalValueNode',\n\n        // Children.\n        condition: input.condition,\n        ...(input.value !== undefined && { value: input.value }),\n        ...(input.ifTrue !== undefined && { ifTrue: input.ifTrue }),\n        ...(input.ifFalse !== undefined && { ifFalse: input.ifFalse }),\n    });\n}\n","// Standalone Value Node Registration.\nexport const STANDALONE_VALUE_NODE_KINDS = [\n    'arrayValueNode' as const,\n    'bytesValueNode' as const,\n    'booleanValueNode' as const,\n    'constantValueNode' as const,\n    'enumValueNode' as const,\n    'mapValueNode' as const,\n    'noneValueNode' as const,\n    'numberValueNode' as const,\n    'setValueNode' as const,\n    'someValueNode' as const,\n    'structValueNode' as const,\n    'tupleValueNode' as const,\n    'publicKeyValueNode' as const,\n    'stringValueNode' as const,\n];\n\n// Value Node Registration.\nexport const REGISTERED_VALUE_NODE_KINDS = [\n    ...STANDALONE_VALUE_NODE_KINDS,\n    'mapEntryValueNode' as const,\n    'structFieldValueNode' as const,\n];\n\n// Value Node Helpers.\nexport const VALUE_NODES = STANDALONE_VALUE_NODE_KINDS;\n","import { VALUE_NODES } from '../valueNodes/ValueNode';\n\n// Standalone Contextual Value Node Registration.\nexport const STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS = [\n    'accountBumpValueNode' as const,\n    'accountValueNode' as const,\n    'argumentValueNode' as const,\n    'conditionalValueNode' as const,\n    'identityValueNode' as const,\n    'payerValueNode' as const,\n    'pdaValueNode' as const,\n    'programIdValueNode' as const,\n    'resolverValueNode' as const,\n];\n\n// Contextual Value Node Registration.\nexport const REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS = [\n    ...STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS,\n    'pdaSeedValueNode' as const,\n];\n\n// Contextual Value Node Helpers.\nexport const CONTEXTUAL_VALUE_NODES = STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS;\nexport const INSTRUCTION_INPUT_VALUE_NODES = [...VALUE_NODES, ...CONTEXTUAL_VALUE_NODES, 'programLinkNode' as const];\n","import type { IdentityValueNode } from '@codama/node-types';\n\nexport function identityValueNode(): IdentityValueNode {\n    return Object.freeze({ kind: 'identityValueNode' });\n}\n","import type { PayerValueNode } from '@codama/node-types';\n\nexport function payerValueNode(): PayerValueNode {\n    return Object.freeze({ kind: 'payerValueNode' });\n}\n","import type { AccountValueNode, ArgumentValueNode, PdaSeedValueNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function pdaSeedValueNode<\n    TValue extends AccountValueNode | ArgumentValueNode | ValueNode = AccountValueNode | ArgumentValueNode | ValueNode,\n>(name: string, value: TValue): PdaSeedValueNode<TValue> {\n    return Object.freeze({\n        kind: 'pdaSeedValueNode',\n\n        // Data.\n        name: camelCase(name),\n\n        // Children.\n        value,\n    });\n}\n","import type { ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function programLinkNode(name: string): ProgramLinkNode {\n    return Object.freeze({\n        kind: 'programLinkNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { AccountLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function accountLinkNode(name: string, program?: ProgramLinkNode | string): AccountLinkNode {\n    return Object.freeze({\n        kind: 'accountLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { DefinedTypeLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function definedTypeLinkNode(name: string, program?: ProgramLinkNode | string): DefinedTypeLinkNode {\n    return Object.freeze({\n        kind: 'definedTypeLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function instructionLinkNode(name: string, program?: ProgramLinkNode | string): InstructionLinkNode {\n    return Object.freeze({\n        kind: 'instructionLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionAccountLinkNode, InstructionLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { instructionLinkNode } from './InstructionLinkNode';\n\nexport function instructionAccountLinkNode(\n    name: string,\n    instruction?: InstructionLinkNode | string,\n): InstructionAccountLinkNode {\n    return Object.freeze({\n        kind: 'instructionAccountLinkNode',\n\n        // Children.\n        ...(instruction === undefined\n            ? {}\n            : { instruction: typeof instruction === 'string' ? instructionLinkNode(instruction) : instruction }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionArgumentLinkNode, InstructionLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { instructionLinkNode } from './InstructionLinkNode';\n\nexport function instructionArgumentLinkNode(\n    name: string,\n    instruction?: InstructionLinkNode | string,\n): InstructionArgumentLinkNode {\n    return Object.freeze({\n        kind: 'instructionArgumentLinkNode',\n\n        // Children.\n        ...(instruction === undefined\n            ? {}\n            : { instruction: typeof instruction === 'string' ? instructionLinkNode(instruction) : instruction }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","// Link Node Registration.\nexport const REGISTERED_LINK_NODE_KINDS = [\n    'accountLinkNode' as const,\n    'definedTypeLinkNode' as const,\n    'instructionAccountLinkNode' as const,\n    'instructionArgumentLinkNode' as const,\n    'instructionLinkNode' as const,\n    'pdaLinkNode' as const,\n    'programLinkNode' as const,\n];\n\n// Link Node Helpers.\nexport const LINK_NODES = REGISTERED_LINK_NODE_KINDS;\n","import type { PdaLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function pdaLinkNode(name: string, program?: ProgramLinkNode | string): PdaLinkNode {\n    return Object.freeze({\n        kind: 'pdaLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type {\n    AccountValueNode,\n    ArgumentValueNode,\n    PdaLinkNode,\n    PdaNode,\n    PdaSeedValueNode,\n    PdaValueNode,\n} from '@codama/node-types';\n\nimport { pdaLinkNode } from '../linkNodes';\n\nexport function pdaValueNode<\n    const TSeeds extends PdaSeedValueNode[] = [],\n    const TProgram extends AccountValueNode | ArgumentValueNode | undefined = undefined,\n>(\n    pda: PdaLinkNode | PdaNode | string,\n    seeds: TSeeds = [] as PdaSeedValueNode[] as TSeeds,\n    programId: TProgram = undefined as TProgram,\n): PdaValueNode<TSeeds, TProgram> {\n    return Object.freeze({\n        kind: 'pdaValueNode',\n\n        // Children.\n        pda: typeof pda === 'string' ? pdaLinkNode(pda) : pda,\n        seeds,\n        ...(programId ? { programId } : {}),\n    });\n}\n","import type { ProgramIdValueNode } from '@codama/node-types';\n\nexport function programIdValueNode(): ProgramIdValueNode {\n    return Object.freeze({ kind: 'programIdValueNode' });\n}\n","import type { AccountValueNode, ArgumentValueNode, ResolverValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport function resolverValueNode<const TDependsOn extends (AccountValueNode | ArgumentValueNode)[] = []>(\n    name: string,\n    options: {\n        dependsOn?: TDependsOn;\n        docs?: DocsInput;\n    } = {},\n): ResolverValueNode<TDependsOn> {\n    return Object.freeze({\n        kind: 'resolverValueNode',\n\n        // Data.\n        name: camelCase(name),\n        docs: parseDocs(options.docs),\n\n        // Children.\n        dependsOn: options.dependsOn,\n    });\n}\n","// Count Node Registration.\nexport const REGISTERED_COUNT_NODE_KINDS = [\n    'fixedCountNode' as const,\n    'remainderCountNode' as const,\n    'prefixedCountNode' as const,\n];\n\n// Count Node Helpers.\nexport const COUNT_NODES = REGISTERED_COUNT_NODE_KINDS;\n","import type { FixedCountNode } from '@codama/node-types';\n\nexport function fixedCountNode(value: number): FixedCountNode {\n    return Object.freeze({\n        kind: 'fixedCountNode',\n\n        // Data.\n        value,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, PrefixedCountNode } from '@codama/node-types';\n\nexport function prefixedCountNode<TPrefix extends NestedTypeNode<NumberTypeNode>>(\n    prefix: TPrefix,\n): PrefixedCountNode<TPrefix> {\n    return Object.freeze({\n        kind: 'prefixedCountNode',\n\n        // Children.\n        prefix,\n    });\n}\n","import type { RemainderCountNode } from '@codama/node-types';\n\nexport function remainderCountNode(): RemainderCountNode {\n    return Object.freeze({ kind: 'remainderCountNode' });\n}\n","import type { ConstantDiscriminatorNode, ConstantValueNode } from '@codama/node-types';\n\nexport function constantDiscriminatorNode<TConstant extends ConstantValueNode>(\n    constant: TConstant,\n    offset: number = 0,\n): ConstantDiscriminatorNode {\n    return Object.freeze({\n        kind: 'constantDiscriminatorNode',\n\n        // Data.\n        offset,\n\n        // Children.\n        constant,\n    });\n}\n","// Discriminator Node Registration.\nexport const REGISTERED_DISCRIMINATOR_NODE_KINDS = [\n    'constantDiscriminatorNode' as const,\n    'fieldDiscriminatorNode' as const,\n    'sizeDiscriminatorNode' as const,\n];\n\n// Discriminator Node Helpers.\nexport const DISCRIMINATOR_NODES = REGISTERED_DISCRIMINATOR_NODE_KINDS;\n","import type { FieldDiscriminatorNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function fieldDiscriminatorNode(name: string, offset: number = 0): FieldDiscriminatorNode {\n    return Object.freeze({\n        kind: 'fieldDiscriminatorNode',\n\n        // Data.\n        name: camelCase(name),\n        offset,\n    });\n}\n","import type { SizeDiscriminatorNode } from '@codama/node-types';\n\nexport function sizeDiscriminatorNode(size: number): SizeDiscriminatorNode {\n    return Object.freeze({\n        kind: 'sizeDiscriminatorNode',\n\n        // Data.\n        size,\n    });\n}\n","import type { BytesTypeNode } from '@codama/node-types';\n\nexport function bytesTypeNode(): BytesTypeNode {\n    return Object.freeze({ kind: 'bytesTypeNode' });\n}\n","import type { PublicKeyTypeNode } from '@codama/node-types';\n\nexport function publicKeyTypeNode(): PublicKeyTypeNode {\n    return Object.freeze({ kind: 'publicKeyTypeNode' });\n}\n","import type { BytesEncoding, StringTypeNode } from '@codama/node-types';\n\nexport function stringTypeNode<TEncoding extends BytesEncoding>(encoding: TEncoding): StringTypeNode<TEncoding> {\n    return Object.freeze({\n        kind: 'stringTypeNode',\n\n        // Data.\n        encoding,\n    });\n}\n","import type { BytesEncoding, BytesValueNode } from '@codama/node-types';\n\nexport function bytesValueNode(encoding: BytesEncoding, data: string): BytesValueNode {\n    return Object.freeze({\n        kind: 'bytesValueNode',\n\n        // Data.\n        data,\n        encoding,\n    });\n}\n","import type { StringValueNode } from '@codama/node-types';\n\nexport function stringValueNode(string: string): StringValueNode {\n    return Object.freeze({\n        kind: 'stringValueNode',\n\n        // Data.\n        string,\n    });\n}\n","import type { BytesEncoding, ConstantPdaSeedNode, ProgramIdValueNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { programIdValueNode } from '../contextualValueNodes/ProgramIdValueNode';\nimport { bytesTypeNode } from '../typeNodes/BytesTypeNode';\nimport { publicKeyTypeNode } from '../typeNodes/PublicKeyTypeNode';\nimport { stringTypeNode } from '../typeNodes/StringTypeNode';\nimport { bytesValueNode } from '../valueNodes/BytesValueNode';\nimport { stringValueNode } from '../valueNodes/StringValueNode';\n\nexport function constantPdaSeedNode<TType extends TypeNode, TValue extends ProgramIdValueNode | ValueNode>(\n    type: TType,\n    value: TValue,\n): ConstantPdaSeedNode<TType, TValue> {\n    return Object.freeze({\n        kind: 'constantPdaSeedNode',\n\n        // Children.\n        type,\n        value,\n    });\n}\n\nexport function constantPdaSeedNodeFromProgramId() {\n    return constantPdaSeedNode(publicKeyTypeNode(), programIdValueNode());\n}\n\nexport function constantPdaSeedNodeFromString<TEncoding extends BytesEncoding>(encoding: TEncoding, string: string) {\n    return constantPdaSeedNode(stringTypeNode(encoding), stringValueNode(string));\n}\n\nexport function constantPdaSeedNodeFromBytes<TEncoding extends BytesEncoding>(encoding: TEncoding, data: string) {\n    return constantPdaSeedNode(bytesTypeNode(), bytesValueNode(encoding, data));\n}\n","// Pda Seed Node Registration.\nexport const REGISTERED_PDA_SEED_NODE_KINDS = ['constantPdaSeedNode' as const, 'variablePdaSeedNode' as const];\n\n// Pda Seed Node Helpers.\nexport const PDA_SEED_NODES = REGISTERED_PDA_SEED_NODE_KINDS;\n","import type { TypeNode, VariablePdaSeedNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport function variablePdaSeedNode<TType extends TypeNode>(\n    name: string,\n    type: TType,\n    docs?: DocsInput,\n): VariablePdaSeedNode<TType> {\n    return Object.freeze({\n        kind: 'variablePdaSeedNode',\n\n        // Data.\n        name: camelCase(name),\n        docs: parseDocs(docs),\n\n        // Children.\n        type,\n    });\n}\n","import type { AmountTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nexport function amountTypeNode<TNumber extends NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n    decimals: number,\n    unit?: string,\n): AmountTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'amountTypeNode',\n\n        // Data.\n        decimals,\n        ...(unit !== undefined && { unit }),\n\n        // Children.\n        number,\n    });\n}\n","import type { ArrayTypeNode, CountNode, TypeNode } from '@codama/node-types';\n\nexport function arrayTypeNode<TItem extends TypeNode, TCount extends CountNode>(\n    item: TItem,\n    count: TCount,\n): ArrayTypeNode<TItem, TCount> {\n    return Object.freeze({\n        kind: 'arrayTypeNode',\n\n        // Children.\n        item,\n        count,\n    });\n}\n","import type { NumberFormat, NumberTypeNode } from '@codama/node-types';\n\nexport function numberTypeNode<TFormat extends NumberFormat = NumberFormat>(\n    format: TFormat,\n    endian: 'be' | 'le' = 'le',\n): NumberTypeNode<TFormat> {\n    return Object.freeze({\n        kind: 'numberTypeNode',\n\n        // Data.\n        format,\n        endian,\n    });\n}\n\nexport function isSignedInteger(node: NumberTypeNode): boolean {\n    return node.format.startsWith('i');\n}\n\nexport function isUnsignedInteger(node: NumberTypeNode): boolean {\n    return node.format.startsWith('u') || node.format === 'shortU16';\n}\n\nexport function isInteger(node: NumberTypeNode): boolean {\n    return !node.format.startsWith('f');\n}\n\nexport function isDecimal(node: NumberTypeNode): boolean {\n    return node.format.startsWith('f');\n}\n","import type { BooleanTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function booleanTypeNode<TSize extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>>(\n    size?: TSize,\n): BooleanTypeNode<TSize> {\n    return Object.freeze({\n        kind: 'booleanTypeNode',\n\n        // Children.\n        size: (size ?? numberTypeNode('u8')) as TSize,\n    });\n}\n","import type { DateTimeTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nexport function dateTimeTypeNode<TNumber extends NestedTypeNode<NumberTypeNode> = NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n): DateTimeTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'dateTimeTypeNode',\n\n        // Children.\n        number,\n    });\n}\n","import type { EnumEmptyVariantTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumEmptyVariantTypeNode(name: string, discriminator?: number): EnumEmptyVariantTypeNode {\n    return Object.freeze({\n        kind: 'enumEmptyVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        discriminator,\n    });\n}\n","import type { EnumStructVariantTypeNode, NestedTypeNode, StructTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumStructVariantTypeNode<TStruct extends NestedTypeNode<StructTypeNode>>(\n    name: string,\n    struct: TStruct,\n    discriminator?: number,\n): EnumStructVariantTypeNode<TStruct> {\n    return Object.freeze({\n        kind: 'enumStructVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        ...(discriminator !== undefined && { discriminator }),\n\n        // Children.\n        struct,\n    });\n}\n","import type { EnumTupleVariantTypeNode, NestedTypeNode, TupleTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumTupleVariantTypeNode<TTuple extends NestedTypeNode<TupleTypeNode>>(\n    name: string,\n    tuple: TTuple,\n    discriminator?: number,\n): EnumTupleVariantTypeNode<TTuple> {\n    return Object.freeze({\n        kind: 'enumTupleVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        ...(discriminator !== undefined && { discriminator }),\n\n        // Children.\n        tuple,\n    });\n}\n","import type { EnumTypeNode, EnumVariantTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function enumTypeNode<\n    const TVariants extends EnumVariantTypeNode[],\n    TSize extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>,\n>(variants: TVariants, options: { size?: TSize } = {}): EnumTypeNode<TVariants, TSize> {\n    return Object.freeze({\n        kind: 'enumTypeNode',\n\n        // Children.\n        variants,\n        size: (options.size ?? numberTypeNode('u8')) as TSize,\n    });\n}\n\nexport function isScalarEnum(node: EnumTypeNode): boolean {\n    return node.variants.every(variant => variant.kind === 'enumEmptyVariantTypeNode');\n}\n\nexport function isDataEnum(node: EnumTypeNode): boolean {\n    return !isScalarEnum(node);\n}\n","export const ENUM_VARIANT_TYPE_NODES = [\n    'enumEmptyVariantTypeNode' as const,\n    'enumStructVariantTypeNode' as const,\n    'enumTupleVariantTypeNode' as const,\n];\n","import type { FixedSizeTypeNode, TypeNode } from '@codama/node-types';\n\nexport function fixedSizeTypeNode<TType extends TypeNode>(type: TType, size: number): FixedSizeTypeNode<TType> {\n    return Object.freeze({\n        kind: 'fixedSizeTypeNode',\n\n        // Data.\n        size,\n\n        // Children.\n        type,\n    });\n}\n","import type { ConstantValueNode, HiddenPrefixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function hiddenPrefixTypeNode<TType extends TypeNode, const TPrefix extends ConstantValueNode[]>(\n    type: TType,\n    prefix: TPrefix,\n): HiddenPrefixTypeNode<TType, TPrefix> {\n    return Object.freeze({\n        kind: 'hiddenPrefixTypeNode',\n\n        // Children.\n        type,\n        prefix,\n    });\n}\n","import type { ConstantValueNode, HiddenSuffixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function hiddenSuffixTypeNode<TType extends TypeNode, const TSuffix extends ConstantValueNode[]>(\n    type: TType,\n    suffix: TSuffix,\n): HiddenSuffixTypeNode<TType, TSuffix> {\n    return Object.freeze({\n        kind: 'hiddenSuffixTypeNode',\n\n        // Children.\n        type,\n        suffix,\n    });\n}\n","import type { CountNode, MapTypeNode, TypeNode } from '@codama/node-types';\n\nexport function mapTypeNode<TKey extends TypeNode, TValue extends TypeNode, TCount extends CountNode>(\n    key: TKey,\n    value: TValue,\n    count: TCount,\n): MapTypeNode<TKey, TValue, TCount> {\n    return Object.freeze({\n        kind: 'mapTypeNode',\n\n        // Children.\n        key,\n        value,\n        count,\n    });\n}\n","// Standalone Type Node Registration.\nexport const STANDALONE_TYPE_NODE_KINDS = [\n    'amountTypeNode' as const,\n    'arrayTypeNode' as const,\n    'booleanTypeNode' as const,\n    'bytesTypeNode' as const,\n    'dateTimeTypeNode' as const,\n    'enumTypeNode' as const,\n    'fixedSizeTypeNode' as const,\n    'hiddenPrefixTypeNode' as const,\n    'hiddenSuffixTypeNode' as const,\n    'mapTypeNode' as const,\n    'numberTypeNode' as const,\n    'optionTypeNode' as const,\n    'postOffsetTypeNode' as const,\n    'preOffsetTypeNode' as const,\n    'publicKeyTypeNode' as const,\n    'remainderOptionTypeNode' as const,\n    'sentinelTypeNode' as const,\n    'setTypeNode' as const,\n    'sizePrefixTypeNode' as const,\n    'solAmountTypeNode' as const,\n    'stringTypeNode' as const,\n    'structTypeNode' as const,\n    'tupleTypeNode' as const,\n    'zeroableOptionTypeNode' as const,\n];\n\n// Type Node Registration.\nexport const REGISTERED_TYPE_NODE_KINDS = [\n    ...STANDALONE_TYPE_NODE_KINDS,\n    'structFieldTypeNode' as const,\n    'enumEmptyVariantTypeNode' as const,\n    'enumStructVariantTypeNode' as const,\n    'enumTupleVariantTypeNode' as const,\n];\n\n/**\n * Type Node Helpers.\n * This only includes type nodes that can be used as standalone types.\n * E.g. this excludes structFieldTypeNode, enumEmptyVariantTypeNode, etc.\n * It also includes the definedTypeLinkNode to compose types.\n */\nexport const TYPE_NODES = [...STANDALONE_TYPE_NODE_KINDS, 'definedTypeLinkNode' as const];\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport type { GetNodeFromKind, Node, NodeKind } from '@codama/node-types';\n\nimport { REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS } from './contextualValueNodes/ContextualValueNode';\nimport { REGISTERED_COUNT_NODE_KINDS } from './countNodes/CountNode';\nimport { REGISTERED_DISCRIMINATOR_NODE_KINDS } from './discriminatorNodes/DiscriminatorNode';\nimport { REGISTERED_LINK_NODE_KINDS } from './linkNodes/LinkNode';\nimport { REGISTERED_PDA_SEED_NODE_KINDS } from './pdaSeedNodes/PdaSeedNode';\nimport { REGISTERED_TYPE_NODE_KINDS } from './typeNodes/TypeNode';\nimport { REGISTERED_VALUE_NODE_KINDS } from './valueNodes/ValueNode';\n\n// Node Registration.\nexport const REGISTERED_NODE_KINDS = [\n    ...REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS,\n    ...REGISTERED_DISCRIMINATOR_NODE_KINDS,\n    ...REGISTERED_LINK_NODE_KINDS,\n    ...REGISTERED_PDA_SEED_NODE_KINDS,\n    ...REGISTERED_COUNT_NODE_KINDS,\n    ...REGISTERED_TYPE_NODE_KINDS,\n    ...REGISTERED_VALUE_NODE_KINDS,\n    'rootNode' as const,\n    'programNode' as const,\n    'pdaNode' as const,\n    'accountNode' as const,\n    'instructionAccountNode' as const,\n    'instructionArgumentNode' as const,\n    'instructionByteDeltaNode' as const,\n    'instructionNode' as const,\n    'instructionRemainingAccountsNode' as const,\n    'instructionStatusNode' as const,\n    'errorNode' as const,\n    'definedTypeNode' as const,\n];\n\n// Node Helpers.\n\nexport function isNode<TKind extends NodeKind>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): node is GetNodeFromKind<TKind> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    return !!node && (kinds as NodeKind[]).includes(node.kind);\n}\n\nexport function assertIsNode<TKind extends NodeKind>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): asserts node is GetNodeFromKind<TKind> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    if (!isNode(node, kinds)) {\n        throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n            expectedKinds: kinds,\n            kind: node?.kind ?? null,\n            node,\n        });\n    }\n}\n\nexport function isNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => isNode(node, kind);\n}\n\nexport function assertIsNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => {\n        assertIsNode(node, kind);\n        return true;\n    };\n}\n\nexport function removeNullAndAssertIsNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => {\n        if (node) assertIsNode(node, kind);\n        return node != null;\n    };\n}\n","import { CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport type { NestedTypeNode, Node, TypeNode } from '@codama/node-types';\n\nimport { isNode } from '../Node';\nimport { TYPE_NODES } from './TypeNode';\n\nexport function resolveNestedTypeNode<TType extends TypeNode>(typeNode: NestedTypeNode<TType>): TType {\n    switch (typeNode.kind) {\n        case 'fixedSizeTypeNode':\n        case 'hiddenPrefixTypeNode':\n        case 'hiddenSuffixTypeNode':\n        case 'postOffsetTypeNode':\n        case 'preOffsetTypeNode':\n        case 'sentinelTypeNode':\n        case 'sizePrefixTypeNode':\n            return resolveNestedTypeNode<TType>(typeNode.type as NestedTypeNode<TType>);\n        default:\n            return typeNode;\n    }\n}\n\nexport function transformNestedTypeNode<TFrom extends TypeNode, TTo extends TypeNode>(\n    typeNode: NestedTypeNode<TFrom>,\n    map: (type: TFrom) => TTo,\n): NestedTypeNode<TTo> {\n    switch (typeNode.kind) {\n        case 'fixedSizeTypeNode':\n        case 'hiddenPrefixTypeNode':\n        case 'hiddenSuffixTypeNode':\n        case 'postOffsetTypeNode':\n        case 'preOffsetTypeNode':\n        case 'sentinelTypeNode':\n        case 'sizePrefixTypeNode':\n            return Object.freeze({\n                ...typeNode,\n                type: transformNestedTypeNode(typeNode.type as NestedTypeNode<TFrom>, map),\n            } as NestedTypeNode<TTo>);\n        default:\n            return map(typeNode);\n    }\n}\n\nexport function isNestedTypeNode<TKind extends TypeNode['kind']>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): node is NestedTypeNode<Extract<TypeNode, { kind: TKind }>> {\n    if (!isNode(node, TYPE_NODES)) return false;\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    const resolved = resolveNestedTypeNode(node);\n    return !!node && kinds.includes(resolved.kind as TKind);\n}\n\nexport function assertIsNestedTypeNode<TKind extends TypeNode['kind']>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): asserts node is NestedTypeNode<Extract<TypeNode, { kind: TKind }>> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    if (!isNestedTypeNode(node, kinds)) {\n        throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, {\n            expectedKinds: kinds,\n            kind: node?.kind ?? null,\n            node,\n        });\n    }\n}\n","import type { NestedTypeNode, NumberTypeNode, OptionTypeNode, TypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function optionTypeNode<\n    TItem extends TypeNode,\n    TPrefix extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>,\n>(\n    item: TItem,\n    options: {\n        readonly fixed?: boolean;\n        readonly prefix?: TPrefix;\n    } = {},\n): OptionTypeNode<TItem, TPrefix> {\n    return Object.freeze({\n        kind: 'optionTypeNode',\n\n        // Data.\n        fixed: options.fixed ?? false,\n\n        // Children.\n        item,\n        prefix: (options.prefix ?? numberTypeNode('u8')) as TPrefix,\n    });\n}\n","import type { PostOffsetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function postOffsetTypeNode<TType extends TypeNode>(\n    type: TType,\n    offset: number,\n    strategy?: PostOffsetTypeNode['strategy'],\n): PostOffsetTypeNode<TType> {\n    return Object.freeze({\n        kind: 'postOffsetTypeNode',\n\n        // Data.\n        offset,\n        strategy: strategy ?? 'relative',\n\n        // Children.\n        type,\n    });\n}\n","import type { PreOffsetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function preOffsetTypeNode<TType extends TypeNode>(\n    type: TType,\n    offset: number,\n    strategy?: PreOffsetTypeNode['strategy'],\n): PreOffsetTypeNode<TType> {\n    return Object.freeze({\n        kind: 'preOffsetTypeNode',\n\n        // Data.\n        offset,\n        strategy: strategy ?? 'relative',\n\n        // Children.\n        type,\n    });\n}\n","import type { RemainderOptionTypeNode, TypeNode } from '@codama/node-types';\n\nexport function remainderOptionTypeNode<TItem extends TypeNode>(item: TItem): RemainderOptionTypeNode<TItem> {\n    return Object.freeze({\n        kind: 'remainderOptionTypeNode',\n\n        // Children.\n        item,\n    });\n}\n","import type { ConstantValueNode, SentinelTypeNode, TypeNode } from '@codama/node-types';\n\nexport function sentinelTypeNode<TType extends TypeNode, TSentinel extends ConstantValueNode>(\n    type: TType,\n    sentinel: TSentinel,\n): SentinelTypeNode<TType, TSentinel> {\n    return Object.freeze({\n        kind: 'sentinelTypeNode',\n\n        // Children.\n        type,\n        sentinel,\n    });\n}\n","import type { CountNode, SetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function setTypeNode<TItem extends TypeNode, TCount extends CountNode>(\n    item: TItem,\n    count: TCount,\n): SetTypeNode<TItem, TCount> {\n    return Object.freeze({\n        kind: 'setTypeNode',\n\n        // Children.\n        item,\n        count,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, SizePrefixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function sizePrefixTypeNode<\n    TType extends TypeNode = TypeNode,\n    TPrefix extends NestedTypeNode<NumberTypeNode> = NestedTypeNode<NumberTypeNode>,\n>(type: TType, prefix: TPrefix): SizePrefixTypeNode<TType, TPrefix> {\n    return Object.freeze({\n        kind: 'sizePrefixTypeNode',\n\n        // Children.\n        type,\n        prefix,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, SolAmountTypeNode } from '@codama/node-types';\n\nexport function solAmountTypeNode<TNumber extends NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n): SolAmountTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'solAmountTypeNode',\n\n        // Children.\n        number,\n    });\n}\n","import type { StructFieldTypeNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport type StructFieldTypeNodeInput<\n    TType extends TypeNode = TypeNode,\n    TDefaultValue extends ValueNode | undefined = ValueNode | undefined,\n> = Omit<StructFieldTypeNode<TType, TDefaultValue>, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function structFieldTypeNode<TType extends TypeNode, TDefaultValue extends ValueNode | undefined = undefined>(\n    input: StructFieldTypeNodeInput<TType, TDefaultValue>,\n): StructFieldTypeNode<TType, TDefaultValue> {\n    return Object.freeze({\n        kind: 'structFieldTypeNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.defaultValueStrategy !== undefined && { defaultValueStrategy: input.defaultValueStrategy }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n","import type { StructFieldTypeNode, StructTypeNode } from '@codama/node-types';\n\nexport function structTypeNode<const TFields extends StructFieldTypeNode[] = StructFieldTypeNode[]>(\n    fields: TFields,\n): StructTypeNode<TFields> {\n    return Object.freeze({\n        kind: 'structTypeNode',\n\n        // Children.\n        fields,\n    });\n}\n","import type { TupleTypeNode, TypeNode } from '@codama/node-types';\n\nexport function tupleTypeNode<const TItems extends TypeNode[] = TypeNode[]>(items: TItems): TupleTypeNode<TItems> {\n    return Object.freeze({\n        kind: 'tupleTypeNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { ConstantValueNode, TypeNode, ZeroableOptionTypeNode } from '@codama/node-types';\n\nexport function zeroableOptionTypeNode<TItem extends TypeNode, TZeroValue extends ConstantValueNode | undefined>(\n    item: TItem,\n    zeroValue?: TZeroValue,\n): ZeroableOptionTypeNode<TItem, TZeroValue> {\n    return Object.freeze({\n        kind: 'zeroableOptionTypeNode',\n\n        // Children.\n        item,\n        ...(zeroValue !== undefined && { zeroValue }),\n    });\n}\n","import type { ArrayValueNode, ValueNode } from '@codama/node-types';\n\nexport function arrayValueNode<const TItems extends ValueNode[]>(items: TItems): ArrayValueNode<TItems> {\n    return Object.freeze({\n        kind: 'arrayValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import { BooleanValueNode } from '@codama/node-types';\n\nexport function booleanValueNode(boolean: boolean): BooleanValueNode {\n    return Object.freeze({\n        kind: 'booleanValueNode',\n\n        // Data.\n        boolean,\n    });\n}\n","import type { BytesEncoding, ConstantValueNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { bytesTypeNode, stringTypeNode } from '../typeNodes';\nimport { bytesValueNode } from './BytesValueNode';\nimport { stringValueNode } from './StringValueNode';\n\nexport function constantValueNode<TType extends TypeNode, TValue extends ValueNode>(\n    type: TType,\n    value: TValue,\n): ConstantValueNode<TType, TValue> {\n    return Object.freeze({\n        kind: 'constantValueNode',\n\n        // Children.\n        type,\n        value,\n    });\n}\n\nexport function constantValueNodeFromString<TEncoding extends BytesEncoding>(encoding: TEncoding, string: string) {\n    return constantValueNode(stringTypeNode(encoding), stringValueNode(string));\n}\n\nexport function constantValueNodeFromBytes<TEncoding extends BytesEncoding>(encoding: TEncoding, data: string) {\n    return constantValueNode(bytesTypeNode(), bytesValueNode(encoding, data));\n}\n","import type { DefinedTypeLinkNode, EnumValueNode, StructValueNode, TupleValueNode } from '@codama/node-types';\n\nimport { definedTypeLinkNode } from '../linkNodes';\nimport { camelCase } from '../shared';\n\nexport function enumValueNode<\n    TEnum extends DefinedTypeLinkNode = DefinedTypeLinkNode,\n    TValue extends StructValueNode | TupleValueNode | undefined = undefined,\n>(enumLink: TEnum | string, variant: string, value?: TValue): EnumValueNode<TEnum, TValue> {\n    return Object.freeze({\n        kind: 'enumValueNode',\n\n        // Data.\n        variant: camelCase(variant),\n\n        // Children.\n        enum: (typeof enumLink === 'string' ? definedTypeLinkNode(enumLink) : enumLink) as TEnum,\n        ...(value !== undefined && { value }),\n    });\n}\n","import type { MapEntryValueNode, ValueNode } from '@codama/node-types';\n\nexport function mapEntryValueNode<TKey extends ValueNode, TValue extends ValueNode>(\n    key: TKey,\n    value: TValue,\n): MapEntryValueNode<TKey, TValue> {\n    return Object.freeze({\n        kind: 'mapEntryValueNode',\n\n        // Children.\n        key,\n        value,\n    });\n}\n","import type { MapEntryValueNode, MapValueNode } from '@codama/node-types';\n\nexport function mapValueNode<const TEntries extends MapEntryValueNode[]>(entries: TEntries): MapValueNode<TEntries> {\n    return Object.freeze({\n        kind: 'mapValueNode',\n\n        // Children.\n        entries,\n    });\n}\n","import type { NoneValueNode } from '@codama/node-types';\n\nexport function noneValueNode(): NoneValueNode {\n    return Object.freeze({ kind: 'noneValueNode' });\n}\n","import type { NumberValueNode } from '@codama/node-types';\n\nexport function numberValueNode(number: number): NumberValueNode {\n    return Object.freeze({\n        kind: 'numberValueNode',\n\n        // Data.\n        number,\n    });\n}\n","import type { PublicKeyValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function publicKeyValueNode(publicKey: string, identifier?: string): PublicKeyValueNode {\n    return Object.freeze({\n        kind: 'publicKeyValueNode',\n\n        // Data.\n        publicKey,\n        ...(identifier !== undefined && { identifier: camelCase(identifier) }),\n    });\n}\n","import type { SetValueNode, ValueNode } from '@codama/node-types';\n\nexport function setValueNode<const TItems extends ValueNode[]>(items: TItems): SetValueNode<TItems> {\n    return Object.freeze({\n        kind: 'setValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { SomeValueNode, ValueNode } from '@codama/node-types';\n\nexport function someValueNode<TValue extends ValueNode>(value: TValue): SomeValueNode<TValue> {\n    return Object.freeze({\n        kind: 'someValueNode',\n\n        // Children.\n        value,\n    });\n}\n","import type { StructFieldValueNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function structFieldValueNode<TValue extends ValueNode>(\n    name: string,\n    value: TValue,\n): StructFieldValueNode<TValue> {\n    return Object.freeze({\n        kind: 'structFieldValueNode',\n\n        // Data.\n        name: camelCase(name),\n\n        // Children.\n        value,\n    });\n}\n","import type { StructFieldValueNode, StructValueNode } from '@codama/node-types';\n\nexport function structValueNode<const TFields extends StructFieldValueNode[]>(\n    fields: TFields,\n): StructValueNode<TFields> {\n    return Object.freeze({\n        kind: 'structValueNode',\n\n        // Children.\n        fields,\n    });\n}\n","import type { TupleValueNode, ValueNode } from '@codama/node-types';\n\nexport function tupleValueNode<const TItems extends ValueNode[]>(items: TItems): TupleValueNode<TItems> {\n    return Object.freeze({\n        kind: 'tupleValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { AccountNode, DiscriminatorNode, NestedTypeNode, PdaLinkNode, StructTypeNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\nimport { structTypeNode } from './typeNodes';\n\nexport type AccountNodeInput<\n    TData extends NestedTypeNode<StructTypeNode> = NestedTypeNode<StructTypeNode>,\n    TPda extends PdaLinkNode | undefined = PdaLinkNode | undefined,\n    TDiscriminators extends DiscriminatorNode[] | undefined = DiscriminatorNode[] | undefined,\n> = Omit<AccountNode<TData, TPda, TDiscriminators>, 'data' | 'docs' | 'kind' | 'name'> & {\n    readonly data?: TData;\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function accountNode<\n    TData extends NestedTypeNode<StructTypeNode> = StructTypeNode<[]>,\n    TPda extends PdaLinkNode | undefined = undefined,\n    const TDiscriminators extends DiscriminatorNode[] | undefined = undefined,\n>(input: AccountNodeInput<TData, TPda, TDiscriminators>): AccountNode<TData, TPda, TDiscriminators> {\n    return Object.freeze({\n        kind: 'accountNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.size === undefined ? {} : { size: input.size }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        data: (input.data ?? structTypeNode([])) as TData,\n        ...(input.pda !== undefined && { pda: input.pda }),\n        ...(input.discriminators !== undefined && { discriminators: input.discriminators }),\n    });\n}\n","import type { DefinedTypeNode, TypeNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type DefinedTypeNodeInput<TType extends TypeNode = TypeNode> = Omit<\n    DefinedTypeNode<TType>,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function definedTypeNode<TType extends TypeNode>(input: DefinedTypeNodeInput<TType>): DefinedTypeNode<TType> {\n    return Object.freeze({\n        kind: 'definedTypeNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n    });\n}\n","import type { ErrorNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type ErrorNodeInput = Omit<ErrorNode, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function errorNode(input: ErrorNodeInput): ErrorNode {\n    return Object.freeze({\n        kind: 'errorNode',\n\n        // Data.\n        name: camelCase(input.name),\n        code: input.code,\n        message: input.message,\n        docs: parseDocs(input.docs),\n    });\n}\n","import type { InstructionAccountNode, InstructionInputValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type InstructionAccountNodeInput<\n    TDefaultValue extends InstructionInputValueNode | undefined = InstructionInputValueNode | undefined,\n> = Omit<InstructionAccountNode<TDefaultValue>, 'docs' | 'isOptional' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly isOptional?: boolean;\n    readonly name: string;\n};\n\nexport function instructionAccountNode<TDefaultValue extends InstructionInputValueNode | undefined = undefined>(\n    input: InstructionAccountNodeInput<TDefaultValue>,\n): InstructionAccountNode<TDefaultValue> {\n    return Object.freeze({\n        kind: 'instructionAccountNode',\n\n        // Data.\n        name: camelCase(input.name),\n        isWritable: input.isWritable,\n        isSigner: input.isSigner,\n        isOptional: input.isOptional ?? false,\n        docs: parseDocs(input.docs),\n\n        // Children.\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n","import type { InstructionArgumentNode, InstructionInputValueNode } from '@codama/node-types';\n\nimport { isNode } from './Node';\nimport { camelCase, DocsInput, parseDocs } from './shared';\nimport { structFieldTypeNode } from './typeNodes/StructFieldTypeNode';\nimport { structTypeNode } from './typeNodes/StructTypeNode';\nimport { VALUE_NODES } from './valueNodes';\n\nexport type InstructionArgumentNodeInput<\n    TDefaultValue extends InstructionInputValueNode | undefined = InstructionInputValueNode | undefined,\n> = Omit<InstructionArgumentNode<TDefaultValue>, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function instructionArgumentNode<TDefaultValue extends InstructionInputValueNode | undefined = undefined>(\n    input: InstructionArgumentNodeInput<TDefaultValue>,\n): InstructionArgumentNode<TDefaultValue> {\n    return Object.freeze({\n        kind: 'instructionArgumentNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.defaultValueStrategy !== undefined && { defaultValueStrategy: input.defaultValueStrategy }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n\nexport function structTypeNodeFromInstructionArgumentNodes(nodes: InstructionArgumentNode[]) {\n    return structTypeNode(nodes.map(structFieldTypeNodeFromInstructionArgumentNode));\n}\n\nexport function structFieldTypeNodeFromInstructionArgumentNode(node: InstructionArgumentNode) {\n    if (isNode(node.defaultValue, VALUE_NODES)) {\n        return structFieldTypeNode({ ...node, defaultValue: node.defaultValue });\n    }\n    return structFieldTypeNode({\n        ...node,\n        defaultValue: undefined,\n        defaultValueStrategy: undefined,\n    });\n}\n","import type { InstructionByteDeltaNode } from '@codama/node-types';\n\nimport { isNode } from './Node';\n\nexport function instructionByteDeltaNode<TValue extends InstructionByteDeltaNode['value']>(\n    value: TValue,\n    options: {\n        subtract?: boolean;\n        withHeader?: boolean;\n    } = {},\n): InstructionByteDeltaNode<TValue> {\n    return Object.freeze({\n        kind: 'instructionByteDeltaNode',\n\n        // Data.\n        withHeader: options.withHeader ?? !isNode(value, 'resolverValueNode'),\n        ...(options.subtract !== undefined && { subtract: options.subtract }),\n\n        // Children.\n        value,\n    });\n}\n","import type {\n    AccountNode,\n    DefinedTypeNode,\n    ErrorNode,\n    InstructionNode,\n    PdaNode,\n    ProgramNode,\n    RootNode,\n} from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type ProgramNodeInput<\n    TPdas extends PdaNode[] = PdaNode[],\n    TAccounts extends AccountNode[] = AccountNode[],\n    TInstructions extends InstructionNode[] = InstructionNode[],\n    TDefinedTypes extends DefinedTypeNode[] = DefinedTypeNode[],\n    TErrors extends ErrorNode[] = ErrorNode[],\n> = Omit<\n    Partial<ProgramNode<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors>>,\n    'docs' | 'kind' | 'name' | 'publicKey'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n    readonly publicKey: ProgramNode['publicKey'];\n};\n\nexport function programNode<\n    const TPdas extends PdaNode[] = [],\n    const TAccounts extends AccountNode[] = [],\n    const TInstructions extends InstructionNode[] = [],\n    const TDefinedTypes extends DefinedTypeNode[] = [],\n    const TErrors extends ErrorNode[] = [],\n>(\n    input: ProgramNodeInput<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors>,\n): ProgramNode<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors> {\n    return Object.freeze({\n        kind: 'programNode',\n\n        // Data.\n        name: camelCase(input.name),\n        publicKey: input.publicKey,\n        version: input.version ?? '0.0.0',\n        ...(input.origin !== undefined && { origin: input.origin }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        accounts: (input.accounts ?? []) as TAccounts,\n        instructions: (input.instructions ?? []) as TInstructions,\n        definedTypes: (input.definedTypes ?? []) as TDefinedTypes,\n        pdas: (input.pdas ?? []) as TPdas,\n        errors: (input.errors ?? []) as TErrors,\n    });\n}\n\nexport function getAllPrograms(node: ProgramNode | ProgramNode[] | RootNode): ProgramNode[] {\n    if (Array.isArray(node)) return node;\n    if (node.kind === 'programNode') return [node];\n    return [node.program, ...node.additionalPrograms];\n}\n\nexport function getAllPdas(node: ProgramNode | ProgramNode[] | RootNode): PdaNode[] {\n    return getAllPrograms(node).flatMap(program => program.pdas);\n}\n\nexport function getAllAccounts(node: ProgramNode | ProgramNode[] | RootNode): AccountNode[] {\n    return getAllPrograms(node).flatMap(program => program.accounts);\n}\n\nexport function getAllDefinedTypes(node: ProgramNode | ProgramNode[] | RootNode): DefinedTypeNode[] {\n    return getAllPrograms(node).flatMap(program => program.definedTypes);\n}\n\nexport function getAllInstructions(node: ProgramNode | ProgramNode[] | RootNode): InstructionNode[] {\n    return getAllPrograms(node).flatMap(program => program.instructions);\n}\n\nexport function getAllErrors(node: ProgramNode | ProgramNode[] | RootNode): ErrorNode[] {\n    return getAllPrograms(node).flatMap(program => program.errors);\n}\n","import type {\n    DiscriminatorNode,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionByteDeltaNode,\n    InstructionNode,\n    InstructionRemainingAccountsNode,\n    OptionalAccountStrategy,\n    ProgramNode,\n    RootNode,\n} from '@codama/node-types';\n\nimport { isNode } from './Node';\nimport { getAllInstructions } from './ProgramNode';\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\ntype SubInstructionNode = InstructionNode;\n\nexport type InstructionNodeInput<\n    TAccounts extends InstructionAccountNode[] = InstructionAccountNode[],\n    TArguments extends InstructionArgumentNode[] = InstructionArgumentNode[],\n    TExtraArguments extends InstructionArgumentNode[] | undefined = InstructionArgumentNode[] | undefined,\n    TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined =\n        | InstructionRemainingAccountsNode[]\n        | undefined,\n    TByteDeltas extends InstructionByteDeltaNode[] | undefined = InstructionByteDeltaNode[] | undefined,\n    TDiscriminators extends DiscriminatorNode[] | undefined = DiscriminatorNode[] | undefined,\n    TSubInstructions extends SubInstructionNode[] | undefined = SubInstructionNode[] | undefined,\n> = Omit<\n    Partial<\n        InstructionNode<\n            TAccounts,\n            TArguments,\n            TExtraArguments,\n            TRemainingAccounts,\n            TByteDeltas,\n            TDiscriminators,\n            TSubInstructions\n        >\n    >,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function instructionNode<\n    const TAccounts extends InstructionAccountNode[] = [],\n    const TArguments extends InstructionArgumentNode[] = [],\n    const TExtraArguments extends InstructionArgumentNode[] | undefined = undefined,\n    const TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined = undefined,\n    const TByteDeltas extends InstructionByteDeltaNode[] | undefined = undefined,\n    const TDiscriminators extends DiscriminatorNode[] | undefined = undefined,\n    const TSubInstructions extends SubInstructionNode[] | undefined = undefined,\n>(\n    input: InstructionNodeInput<\n        TAccounts,\n        TArguments,\n        TExtraArguments,\n        TRemainingAccounts,\n        TByteDeltas,\n        TDiscriminators,\n        TSubInstructions\n    >,\n): InstructionNode<\n    TAccounts,\n    TArguments,\n    TExtraArguments,\n    TRemainingAccounts,\n    TByteDeltas,\n    TDiscriminators,\n    TSubInstructions\n> {\n    return Object.freeze({\n        kind: 'instructionNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n        optionalAccountStrategy: parseOptionalAccountStrategy(input.optionalAccountStrategy),\n        ...(input.status !== undefined && { status: input.status }),\n\n        // Children.\n        accounts: (input.accounts ?? []) as TAccounts,\n        arguments: (input.arguments ?? []) as TArguments,\n        extraArguments: input.extraArguments,\n        remainingAccounts: input.remainingAccounts,\n        byteDeltas: input.byteDeltas,\n        discriminators: input.discriminators,\n        subInstructions: input.subInstructions,\n    });\n}\n\nexport function parseOptionalAccountStrategy(\n    optionalAccountStrategy: OptionalAccountStrategy | undefined,\n): OptionalAccountStrategy {\n    return optionalAccountStrategy ?? 'programId';\n}\n\nexport function getAllInstructionArguments(node: InstructionNode): InstructionArgumentNode[] {\n    return [...node.arguments, ...(node.extraArguments ?? [])];\n}\n\nexport function getAllInstructionsWithSubs(\n    node: InstructionNode | ProgramNode | RootNode,\n    config: { leavesOnly?: boolean; subInstructionsFirst?: boolean } = {},\n): InstructionNode[] {\n    const { leavesOnly = false, subInstructionsFirst = false } = config;\n    if (isNode(node, 'instructionNode')) {\n        if (!node.subInstructions || node.subInstructions.length === 0) return [node];\n        const subInstructions = node.subInstructions.flatMap(sub => getAllInstructionsWithSubs(sub, config));\n        if (leavesOnly) return subInstructions;\n        return subInstructionsFirst ? [...subInstructions, node] : [node, ...subInstructions];\n    }\n\n    const instructions = isNode(node, 'programNode') ? node.instructions : getAllInstructions(node);\n\n    return instructions.flatMap(instruction => getAllInstructionsWithSubs(instruction, config));\n}\n","import type { ArgumentValueNode, InstructionRemainingAccountsNode, ResolverValueNode } from '@codama/node-types';\n\nimport { DocsInput, parseDocs } from './shared';\n\nexport function instructionRemainingAccountsNode<TValue extends ArgumentValueNode | ResolverValueNode>(\n    value: TValue,\n    options: {\n        docs?: DocsInput;\n        isOptional?: boolean;\n        isSigner?: boolean | 'either';\n        isWritable?: boolean;\n    } = {},\n): InstructionRemainingAccountsNode<TValue> {\n    return Object.freeze({\n        kind: 'instructionRemainingAccountsNode',\n\n        // Data.\n        ...(options.isOptional !== undefined && { isOptional: options.isOptional }),\n        ...(options.isSigner !== undefined && { isSigner: options.isSigner }),\n        ...(options.isWritable !== undefined && { isWritable: options.isWritable }),\n        docs: parseDocs(options.docs),\n\n        // Children.\n        value,\n    });\n}\n","import type { InstructionLifecycle, InstructionStatusNode } from '@codama/node-types';\n\nexport function instructionStatusNode(lifecycle: InstructionLifecycle, message?: string): InstructionStatusNode {\n    return Object.freeze({\n        kind: 'instructionStatusNode',\n\n        // Data.\n        lifecycle,\n        ...(message !== undefined && { message }),\n    });\n}\n","import type { PdaNode, PdaSeedNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type PdaNodeInput<TSeeds extends PdaSeedNode[] = PdaSeedNode[]> = Omit<\n    PdaNode<TSeeds>,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function pdaNode<const TSeeds extends PdaSeedNode[]>(input: PdaNodeInput<TSeeds>): PdaNode<TSeeds> {\n    return Object.freeze({\n        kind: 'pdaNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n        ...(input.programId && { programId: input.programId }),\n\n        // Children.\n        seeds: input.seeds,\n    });\n}\n","import type { CodamaVersion, ProgramNode, RootNode } from '@codama/node-types';\n\nexport function rootNode<TProgram extends ProgramNode, const TAdditionalPrograms extends ProgramNode[] = []>(\n    program: TProgram,\n    additionalPrograms?: TAdditionalPrograms,\n): RootNode<TProgram, TAdditionalPrograms> {\n    return Object.freeze({\n        kind: 'rootNode',\n\n        // Data.\n        standard: 'codama',\n        version: __VERSION__ as CodamaVersion,\n\n        // Children.\n        program,\n        additionalPrograms: (additionalPrograms ?? []) as TAdditionalPrograms,\n    });\n}\n"]}